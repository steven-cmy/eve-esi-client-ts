/* tslint:disable */
/* eslint-disable */
/**
 * EVE Swagger Interface
 * An OpenAPI for EVE Online
 *
 * The version of the OpenAPI document: 1.36
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Bad request model
 */
export interface BadRequest {
    /**
     * Bad request message
     */
    'error': string;
}
/**
 * Unprocessable entity
 */
export interface DeleteCharactersCharacterIdMailLabelsLabelIdUnprocessableEntity {
    /**
     * Unprocessable entity message
     */
    'error'?: string;
}
/**
 * Not found
 */
export interface DeleteFleetsFleetIdMembersMemberIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * Not found
 */
export interface DeleteFleetsFleetIdSquadsSquadIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * Not found
 */
export interface DeleteFleetsFleetIdWingsWingIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * Error limited model
 */
export interface ErrorLimited {
    /**
     * Error limited message
     */
    'error': string;
}
/**
 * Forbidden model
 */
export interface Forbidden {
    /**
     * Forbidden message
     */
    'error': string;
    /**
     * status code received from SSO
     */
    'sso_status'?: number;
}
/**
 * Gateway timeout model
 */
export interface GatewayTimeout {
    /**
     * Gateway timeout message
     */
    'error': string;
    /**
     * number of seconds the request was given
     */
    'timeout'?: number;
}
/**
 * 200 ok object
 */
export interface GetAlliancesAllianceIdContacts200Ok {
    /**
     * contact_id integer
     */
    'contact_id': number;
    /**
     * contact_type string
     */
    'contact_type': GetAlliancesAllianceIdContacts200OkContactTypeEnum;
    /**
     * label_ids array
     */
    'label_ids'?: Array<number>;
    /**
     * Standing of the contact
     */
    'standing': number;
}

export const GetAlliancesAllianceIdContacts200OkContactTypeEnum = {
    Character: 'character',
    Corporation: 'corporation',
    Alliance: 'alliance',
    Faction: 'faction'
} as const;

export type GetAlliancesAllianceIdContacts200OkContactTypeEnum = typeof GetAlliancesAllianceIdContacts200OkContactTypeEnum[keyof typeof GetAlliancesAllianceIdContacts200OkContactTypeEnum];

/**
 * 200 ok object
 */
export interface GetAlliancesAllianceIdContactsLabels200Ok {
    /**
     * label_id integer
     */
    'label_id': number;
    /**
     * label_name string
     */
    'label_name': string;
}
/**
 * No image server for this datasource
 */
export interface GetAlliancesAllianceIdIconsNotFound {
    /**
     * error message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetAlliancesAllianceIdIconsOk {
    /**
     * px128x128 string
     */
    'px128x128'?: string;
    /**
     * px64x64 string
     */
    'px64x64'?: string;
}
/**
 * Not found
 */
export interface GetAlliancesAllianceIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetAlliancesAllianceIdOk {
    /**
     * ID of the corporation that created the alliance
     */
    'creator_corporation_id': number;
    /**
     * ID of the character that created the alliance
     */
    'creator_id': number;
    /**
     * date_founded string
     */
    'date_founded': string;
    /**
     * the executor corporation ID, if this alliance is not closed
     */
    'executor_corporation_id'?: number;
    /**
     * Faction ID this alliance is fighting for, if this alliance is enlisted in factional warfare
     */
    'faction_id'?: number;
    /**
     * the full name of the alliance
     */
    'name': string;
    /**
     * the short name of the alliance
     */
    'ticker': string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdAgentsResearch200Ok {
    /**
     * agent_id integer
     */
    'agent_id': number;
    /**
     * points_per_day number
     */
    'points_per_day': number;
    /**
     * remainder_points number
     */
    'remainder_points': number;
    /**
     * skill_type_id integer
     */
    'skill_type_id': number;
    /**
     * started_at string
     */
    'started_at': string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdAssets200Ok {
    /**
     * is_blueprint_copy boolean
     */
    'is_blueprint_copy'?: boolean;
    /**
     * is_singleton boolean
     */
    'is_singleton': boolean;
    /**
     * item_id integer
     */
    'item_id': number;
    /**
     * location_flag string
     */
    'location_flag': GetCharactersCharacterIdAssets200OkLocationFlagEnum;
    /**
     * location_id integer
     */
    'location_id': number;
    /**
     * location_type string
     */
    'location_type': GetCharactersCharacterIdAssets200OkLocationTypeEnum;
    /**
     * quantity integer
     */
    'quantity': number;
    /**
     * type_id integer
     */
    'type_id': number;
}

export const GetCharactersCharacterIdAssets200OkLocationFlagEnum = {
    AssetSafety: 'AssetSafety',
    AutoFit: 'AutoFit',
    BoosterBay: 'BoosterBay',
    CapsuleerDeliveries: 'CapsuleerDeliveries',
    Cargo: 'Cargo',
    CorporationGoalDeliveries: 'CorporationGoalDeliveries',
    CorpseBay: 'CorpseBay',
    Deliveries: 'Deliveries',
    DroneBay: 'DroneBay',
    FighterBay: 'FighterBay',
    FighterTube0: 'FighterTube0',
    FighterTube1: 'FighterTube1',
    FighterTube2: 'FighterTube2',
    FighterTube3: 'FighterTube3',
    FighterTube4: 'FighterTube4',
    FleetHangar: 'FleetHangar',
    FrigateEscapeBay: 'FrigateEscapeBay',
    Hangar: 'Hangar',
    HangarAll: 'HangarAll',
    HiSlot0: 'HiSlot0',
    HiSlot1: 'HiSlot1',
    HiSlot2: 'HiSlot2',
    HiSlot3: 'HiSlot3',
    HiSlot4: 'HiSlot4',
    HiSlot5: 'HiSlot5',
    HiSlot6: 'HiSlot6',
    HiSlot7: 'HiSlot7',
    HiddenModifiers: 'HiddenModifiers',
    Implant: 'Implant',
    InfrastructureHangar: 'InfrastructureHangar',
    LoSlot0: 'LoSlot0',
    LoSlot1: 'LoSlot1',
    LoSlot2: 'LoSlot2',
    LoSlot3: 'LoSlot3',
    LoSlot4: 'LoSlot4',
    LoSlot5: 'LoSlot5',
    LoSlot6: 'LoSlot6',
    LoSlot7: 'LoSlot7',
    Locked: 'Locked',
    MedSlot0: 'MedSlot0',
    MedSlot1: 'MedSlot1',
    MedSlot2: 'MedSlot2',
    MedSlot3: 'MedSlot3',
    MedSlot4: 'MedSlot4',
    MedSlot5: 'MedSlot5',
    MedSlot6: 'MedSlot6',
    MedSlot7: 'MedSlot7',
    MobileDepotHold: 'MobileDepotHold',
    MoonMaterialBay: 'MoonMaterialBay',
    QuafeBay: 'QuafeBay',
    RigSlot0: 'RigSlot0',
    RigSlot1: 'RigSlot1',
    RigSlot2: 'RigSlot2',
    RigSlot3: 'RigSlot3',
    RigSlot4: 'RigSlot4',
    RigSlot5: 'RigSlot5',
    RigSlot6: 'RigSlot6',
    RigSlot7: 'RigSlot7',
    ShipHangar: 'ShipHangar',
    Skill: 'Skill',
    SpecializedAmmoHold: 'SpecializedAmmoHold',
    SpecializedAsteroidHold: 'SpecializedAsteroidHold',
    SpecializedCommandCenterHold: 'SpecializedCommandCenterHold',
    SpecializedFuelBay: 'SpecializedFuelBay',
    SpecializedGasHold: 'SpecializedGasHold',
    SpecializedIceHold: 'SpecializedIceHold',
    SpecializedIndustrialShipHold: 'SpecializedIndustrialShipHold',
    SpecializedLargeShipHold: 'SpecializedLargeShipHold',
    SpecializedMaterialBay: 'SpecializedMaterialBay',
    SpecializedMediumShipHold: 'SpecializedMediumShipHold',
    SpecializedMineralHold: 'SpecializedMineralHold',
    SpecializedOreHold: 'SpecializedOreHold',
    SpecializedPlanetaryCommoditiesHold: 'SpecializedPlanetaryCommoditiesHold',
    SpecializedSalvageHold: 'SpecializedSalvageHold',
    SpecializedShipHold: 'SpecializedShipHold',
    SpecializedSmallShipHold: 'SpecializedSmallShipHold',
    StructureDeedBay: 'StructureDeedBay',
    SubSystemBay: 'SubSystemBay',
    SubSystemSlot0: 'SubSystemSlot0',
    SubSystemSlot1: 'SubSystemSlot1',
    SubSystemSlot2: 'SubSystemSlot2',
    SubSystemSlot3: 'SubSystemSlot3',
    SubSystemSlot4: 'SubSystemSlot4',
    SubSystemSlot5: 'SubSystemSlot5',
    SubSystemSlot6: 'SubSystemSlot6',
    SubSystemSlot7: 'SubSystemSlot7',
    Unlocked: 'Unlocked',
    Wardrobe: 'Wardrobe'
} as const;

export type GetCharactersCharacterIdAssets200OkLocationFlagEnum = typeof GetCharactersCharacterIdAssets200OkLocationFlagEnum[keyof typeof GetCharactersCharacterIdAssets200OkLocationFlagEnum];
export const GetCharactersCharacterIdAssets200OkLocationTypeEnum = {
    Station: 'station',
    SolarSystem: 'solar_system',
    Item: 'item',
    Other: 'other'
} as const;

export type GetCharactersCharacterIdAssets200OkLocationTypeEnum = typeof GetCharactersCharacterIdAssets200OkLocationTypeEnum[keyof typeof GetCharactersCharacterIdAssets200OkLocationTypeEnum];

/**
 * Requested page does not exist
 */
export interface GetCharactersCharacterIdAssetsNotFound {
    /**
     * error message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdAttributesOk {
    /**
     * Neural remapping cooldown after a character uses remap accrued over time
     */
    'accrued_remap_cooldown_date'?: string;
    /**
     * Number of available bonus character neural remaps
     */
    'bonus_remaps'?: number;
    /**
     * charisma integer
     */
    'charisma': number;
    /**
     * intelligence integer
     */
    'intelligence': number;
    /**
     * Datetime of last neural remap, including usage of bonus remaps
     */
    'last_remap_date'?: string;
    /**
     * memory integer
     */
    'memory': number;
    /**
     * perception integer
     */
    'perception': number;
    /**
     * willpower integer
     */
    'willpower': number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdBlueprints200Ok {
    /**
     * Unique ID for this item.
     */
    'item_id': number;
    /**
     * Type of the location_id
     */
    'location_flag': GetCharactersCharacterIdBlueprints200OkLocationFlagEnum;
    /**
     * References a station, a ship or an item_id if this blueprint is located within a container. If the return value is an item_id, then the Character AssetList API must be queried to find the container using the given item_id to determine the correct location of the Blueprint.
     */
    'location_id': number;
    /**
     * Material Efficiency Level of the blueprint.
     */
    'material_efficiency': number;
    /**
     * A range of numbers with a minimum of -2 and no maximum value where -1 is an original and -2 is a copy. It can be a positive integer if it is a stack of blueprint originals fresh from the market (e.g. no activities performed on them yet).
     */
    'quantity': number;
    /**
     * Number of runs remaining if the blueprint is a copy, -1 if it is an original.
     */
    'runs': number;
    /**
     * Time Efficiency Level of the blueprint.
     */
    'time_efficiency': number;
    /**
     * type_id integer
     */
    'type_id': number;
}

export const GetCharactersCharacterIdBlueprints200OkLocationFlagEnum = {
    AutoFit: 'AutoFit',
    Cargo: 'Cargo',
    CorpseBay: 'CorpseBay',
    DroneBay: 'DroneBay',
    FleetHangar: 'FleetHangar',
    Deliveries: 'Deliveries',
    HiddenModifiers: 'HiddenModifiers',
    Hangar: 'Hangar',
    HangarAll: 'HangarAll',
    LoSlot0: 'LoSlot0',
    LoSlot1: 'LoSlot1',
    LoSlot2: 'LoSlot2',
    LoSlot3: 'LoSlot3',
    LoSlot4: 'LoSlot4',
    LoSlot5: 'LoSlot5',
    LoSlot6: 'LoSlot6',
    LoSlot7: 'LoSlot7',
    MedSlot0: 'MedSlot0',
    MedSlot1: 'MedSlot1',
    MedSlot2: 'MedSlot2',
    MedSlot3: 'MedSlot3',
    MedSlot4: 'MedSlot4',
    MedSlot5: 'MedSlot5',
    MedSlot6: 'MedSlot6',
    MedSlot7: 'MedSlot7',
    HiSlot0: 'HiSlot0',
    HiSlot1: 'HiSlot1',
    HiSlot2: 'HiSlot2',
    HiSlot3: 'HiSlot3',
    HiSlot4: 'HiSlot4',
    HiSlot5: 'HiSlot5',
    HiSlot6: 'HiSlot6',
    HiSlot7: 'HiSlot7',
    AssetSafety: 'AssetSafety',
    Locked: 'Locked',
    Unlocked: 'Unlocked',
    Implant: 'Implant',
    QuafeBay: 'QuafeBay',
    RigSlot0: 'RigSlot0',
    RigSlot1: 'RigSlot1',
    RigSlot2: 'RigSlot2',
    RigSlot3: 'RigSlot3',
    RigSlot4: 'RigSlot4',
    RigSlot5: 'RigSlot5',
    RigSlot6: 'RigSlot6',
    RigSlot7: 'RigSlot7',
    ShipHangar: 'ShipHangar',
    SpecializedFuelBay: 'SpecializedFuelBay',
    SpecializedOreHold: 'SpecializedOreHold',
    SpecializedGasHold: 'SpecializedGasHold',
    SpecializedMineralHold: 'SpecializedMineralHold',
    SpecializedSalvageHold: 'SpecializedSalvageHold',
    SpecializedShipHold: 'SpecializedShipHold',
    SpecializedSmallShipHold: 'SpecializedSmallShipHold',
    SpecializedMediumShipHold: 'SpecializedMediumShipHold',
    SpecializedLargeShipHold: 'SpecializedLargeShipHold',
    SpecializedIndustrialShipHold: 'SpecializedIndustrialShipHold',
    SpecializedAmmoHold: 'SpecializedAmmoHold',
    SpecializedCommandCenterHold: 'SpecializedCommandCenterHold',
    SpecializedPlanetaryCommoditiesHold: 'SpecializedPlanetaryCommoditiesHold',
    SpecializedMaterialBay: 'SpecializedMaterialBay',
    SubSystemSlot0: 'SubSystemSlot0',
    SubSystemSlot1: 'SubSystemSlot1',
    SubSystemSlot2: 'SubSystemSlot2',
    SubSystemSlot3: 'SubSystemSlot3',
    SubSystemSlot4: 'SubSystemSlot4',
    SubSystemSlot5: 'SubSystemSlot5',
    SubSystemSlot6: 'SubSystemSlot6',
    SubSystemSlot7: 'SubSystemSlot7',
    FighterBay: 'FighterBay',
    FighterTube0: 'FighterTube0',
    FighterTube1: 'FighterTube1',
    FighterTube2: 'FighterTube2',
    FighterTube3: 'FighterTube3',
    FighterTube4: 'FighterTube4',
    Module: 'Module'
} as const;

export type GetCharactersCharacterIdBlueprints200OkLocationFlagEnum = typeof GetCharactersCharacterIdBlueprints200OkLocationFlagEnum[keyof typeof GetCharactersCharacterIdBlueprints200OkLocationFlagEnum];

/**
 * event
 */
export interface GetCharactersCharacterIdCalendar200Ok {
    /**
     * event_date string
     */
    'event_date'?: string;
    /**
     * event_id integer
     */
    'event_id'?: number;
    /**
     * event_response string
     */
    'event_response'?: GetCharactersCharacterIdCalendar200OkEventResponseEnum;
    /**
     * importance integer
     */
    'importance'?: number;
    /**
     * title string
     */
    'title'?: string;
}

export const GetCharactersCharacterIdCalendar200OkEventResponseEnum = {
    Declined: 'declined',
    NotResponded: 'not_responded',
    Accepted: 'accepted',
    Tentative: 'tentative'
} as const;

export type GetCharactersCharacterIdCalendar200OkEventResponseEnum = typeof GetCharactersCharacterIdCalendar200OkEventResponseEnum[keyof typeof GetCharactersCharacterIdCalendar200OkEventResponseEnum];

/**
 * character_id and response of an attendee
 */
export interface GetCharactersCharacterIdCalendarEventIdAttendees200Ok {
    /**
     * character_id integer
     */
    'character_id'?: number;
    /**
     * event_response string
     */
    'event_response'?: GetCharactersCharacterIdCalendarEventIdAttendees200OkEventResponseEnum;
}

export const GetCharactersCharacterIdCalendarEventIdAttendees200OkEventResponseEnum = {
    Declined: 'declined',
    NotResponded: 'not_responded',
    Accepted: 'accepted',
    Tentative: 'tentative'
} as const;

export type GetCharactersCharacterIdCalendarEventIdAttendees200OkEventResponseEnum = typeof GetCharactersCharacterIdCalendarEventIdAttendees200OkEventResponseEnum[keyof typeof GetCharactersCharacterIdCalendarEventIdAttendees200OkEventResponseEnum];

/**
 * Not found
 */
export interface GetCharactersCharacterIdCalendarEventIdAttendeesNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * Not found
 */
export interface GetCharactersCharacterIdCalendarEventIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * Full details of a specific event
 */
export interface GetCharactersCharacterIdCalendarEventIdOk {
    /**
     * date string
     */
    'date': string;
    /**
     * Length in minutes
     */
    'duration': number;
    /**
     * event_id integer
     */
    'event_id': number;
    /**
     * importance integer
     */
    'importance': number;
    /**
     * owner_id integer
     */
    'owner_id': number;
    /**
     * owner_name string
     */
    'owner_name': string;
    /**
     * owner_type string
     */
    'owner_type': GetCharactersCharacterIdCalendarEventIdOkOwnerTypeEnum;
    /**
     * response string
     */
    'response': string;
    /**
     * text string
     */
    'text': string;
    /**
     * title string
     */
    'title': string;
}

export const GetCharactersCharacterIdCalendarEventIdOkOwnerTypeEnum = {
    EveServer: 'eve_server',
    Corporation: 'corporation',
    Faction: 'faction',
    Character: 'character',
    Alliance: 'alliance'
} as const;

export type GetCharactersCharacterIdCalendarEventIdOkOwnerTypeEnum = typeof GetCharactersCharacterIdCalendarEventIdOkOwnerTypeEnum[keyof typeof GetCharactersCharacterIdCalendarEventIdOkOwnerTypeEnum];

/**
 * home_location object
 */
export interface GetCharactersCharacterIdClonesHomeLocation {
    /**
     * location_id integer
     */
    'location_id'?: number;
    /**
     * location_type string
     */
    'location_type'?: GetCharactersCharacterIdClonesHomeLocationLocationTypeEnum;
}

export const GetCharactersCharacterIdClonesHomeLocationLocationTypeEnum = {
    Station: 'station',
    Structure: 'structure'
} as const;

export type GetCharactersCharacterIdClonesHomeLocationLocationTypeEnum = typeof GetCharactersCharacterIdClonesHomeLocationLocationTypeEnum[keyof typeof GetCharactersCharacterIdClonesHomeLocationLocationTypeEnum];

/**
 * jump_clone object
 */
export interface GetCharactersCharacterIdClonesJumpClone {
    /**
     * implants array
     */
    'implants': Array<number>;
    /**
     * jump_clone_id integer
     */
    'jump_clone_id': number;
    /**
     * location_id integer
     */
    'location_id': number;
    /**
     * location_type string
     */
    'location_type': GetCharactersCharacterIdClonesJumpCloneLocationTypeEnum;
    /**
     * name string
     */
    'name'?: string;
}

export const GetCharactersCharacterIdClonesJumpCloneLocationTypeEnum = {
    Station: 'station',
    Structure: 'structure'
} as const;

export type GetCharactersCharacterIdClonesJumpCloneLocationTypeEnum = typeof GetCharactersCharacterIdClonesJumpCloneLocationTypeEnum[keyof typeof GetCharactersCharacterIdClonesJumpCloneLocationTypeEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdClonesOk {
    'home_location'?: GetCharactersCharacterIdClonesHomeLocation;
    /**
     * jump_clones array
     */
    'jump_clones': Array<GetCharactersCharacterIdClonesJumpClone>;
    /**
     * last_clone_jump_date string
     */
    'last_clone_jump_date'?: string;
    /**
     * last_station_change_date string
     */
    'last_station_change_date'?: string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdContacts200Ok {
    /**
     * contact_id integer
     */
    'contact_id': number;
    /**
     * contact_type string
     */
    'contact_type': GetCharactersCharacterIdContacts200OkContactTypeEnum;
    /**
     * Whether this contact is in the blocked list. Note a missing value denotes unknown, not true or false
     */
    'is_blocked'?: boolean;
    /**
     * Whether this contact is being watched
     */
    'is_watched'?: boolean;
    /**
     * label_ids array
     */
    'label_ids'?: Array<number>;
    /**
     * Standing of the contact
     */
    'standing': number;
}

export const GetCharactersCharacterIdContacts200OkContactTypeEnum = {
    Character: 'character',
    Corporation: 'corporation',
    Alliance: 'alliance',
    Faction: 'faction'
} as const;

export type GetCharactersCharacterIdContacts200OkContactTypeEnum = typeof GetCharactersCharacterIdContacts200OkContactTypeEnum[keyof typeof GetCharactersCharacterIdContacts200OkContactTypeEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdContactsLabels200Ok {
    /**
     * label_id integer
     */
    'label_id': number;
    /**
     * label_name string
     */
    'label_name': string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdContracts200Ok {
    /**
     * Who will accept the contract
     */
    'acceptor_id': number;
    /**
     * ID to whom the contract is assigned, can be alliance, corporation or character ID
     */
    'assignee_id': number;
    /**
     * To whom the contract is available
     */
    'availability': GetCharactersCharacterIdContracts200OkAvailabilityEnum;
    /**
     * Buyout price (for Auctions only)
     */
    'buyout'?: number;
    /**
     * Collateral price (for Couriers only)
     */
    'collateral'?: number;
    /**
     * contract_id integer
     */
    'contract_id': number;
    /**
     * Date of confirmation of contract
     */
    'date_accepted'?: string;
    /**
     * Date of completed of contract
     */
    'date_completed'?: string;
    /**
     * Expiration date of the contract
     */
    'date_expired': string;
    /**
     * Сreation date of the contract
     */
    'date_issued': string;
    /**
     * Number of days to perform the contract
     */
    'days_to_complete'?: number;
    /**
     * End location ID (for Couriers contract)
     */
    'end_location_id'?: number;
    /**
     * true if the contract was issued on behalf of the issuer\'s corporation
     */
    'for_corporation': boolean;
    /**
     * Character\'s corporation ID for the issuer
     */
    'issuer_corporation_id': number;
    /**
     * Character ID for the issuer
     */
    'issuer_id': number;
    /**
     * Price of contract (for ItemsExchange and Auctions)
     */
    'price'?: number;
    /**
     * Remuneration for contract (for Couriers only)
     */
    'reward'?: number;
    /**
     * Start location ID (for Couriers contract)
     */
    'start_location_id'?: number;
    /**
     * Status of the the contract
     */
    'status': GetCharactersCharacterIdContracts200OkStatusEnum;
    /**
     * Title of the contract
     */
    'title'?: string;
    /**
     * Type of the contract
     */
    'type': GetCharactersCharacterIdContracts200OkTypeEnum;
    /**
     * Volume of items in the contract
     */
    'volume'?: number;
}

export const GetCharactersCharacterIdContracts200OkAvailabilityEnum = {
    Public: 'public',
    Personal: 'personal',
    Corporation: 'corporation',
    Alliance: 'alliance'
} as const;

export type GetCharactersCharacterIdContracts200OkAvailabilityEnum = typeof GetCharactersCharacterIdContracts200OkAvailabilityEnum[keyof typeof GetCharactersCharacterIdContracts200OkAvailabilityEnum];
export const GetCharactersCharacterIdContracts200OkStatusEnum = {
    Outstanding: 'outstanding',
    InProgress: 'in_progress',
    FinishedIssuer: 'finished_issuer',
    FinishedContractor: 'finished_contractor',
    Finished: 'finished',
    Cancelled: 'cancelled',
    Rejected: 'rejected',
    Failed: 'failed',
    Deleted: 'deleted',
    Reversed: 'reversed'
} as const;

export type GetCharactersCharacterIdContracts200OkStatusEnum = typeof GetCharactersCharacterIdContracts200OkStatusEnum[keyof typeof GetCharactersCharacterIdContracts200OkStatusEnum];
export const GetCharactersCharacterIdContracts200OkTypeEnum = {
    Unknown: 'unknown',
    ItemExchange: 'item_exchange',
    Auction: 'auction',
    Courier: 'courier',
    Loan: 'loan'
} as const;

export type GetCharactersCharacterIdContracts200OkTypeEnum = typeof GetCharactersCharacterIdContracts200OkTypeEnum[keyof typeof GetCharactersCharacterIdContracts200OkTypeEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdContractsContractIdBids200Ok {
    /**
     * The amount bid, in ISK
     */
    'amount': number;
    /**
     * Unique ID for the bid
     */
    'bid_id': number;
    /**
     * Character ID of the bidder
     */
    'bidder_id': number;
    /**
     * Datetime when the bid was placed
     */
    'date_bid': string;
}
/**
 * Not found
 */
export interface GetCharactersCharacterIdContractsContractIdBidsNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdContractsContractIdItems200Ok {
    /**
     * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
     */
    'is_included': boolean;
    /**
     * is_singleton boolean
     */
    'is_singleton': boolean;
    /**
     * Number of items in the stack
     */
    'quantity': number;
    /**
     * -1 indicates that the item is a singleton (non-stackable). If the item happens to be a Blueprint, -1 is an Original and -2 is a Blueprint Copy
     */
    'raw_quantity'?: number;
    /**
     * Unique ID for the item
     */
    'record_id': number;
    /**
     * Type ID for item
     */
    'type_id': number;
}
/**
 * Not found
 */
export interface GetCharactersCharacterIdContractsContractIdItemsNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdCorporationhistory200Ok {
    /**
     * corporation_id integer
     */
    'corporation_id': number;
    /**
     * True if the corporation has been deleted
     */
    'is_deleted'?: boolean;
    /**
     * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
     */
    'record_id': number;
    /**
     * start_date string
     */
    'start_date': string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdFatigueOk {
    /**
     * Character\'s jump fatigue expiry
     */
    'jump_fatigue_expire_date'?: string;
    /**
     * Character\'s last jump activation
     */
    'last_jump_date'?: string;
    /**
     * Character\'s last jump update
     */
    'last_update_date'?: string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdFittings200Ok {
    /**
     * description string
     */
    'description': string;
    /**
     * fitting_id integer
     */
    'fitting_id': number;
    /**
     * items array
     */
    'items': Array<GetCharactersCharacterIdFittingsItem>;
    /**
     * name string
     */
    'name': string;
    /**
     * ship_type_id integer
     */
    'ship_type_id': number;
}
/**
 * item object
 */
export interface GetCharactersCharacterIdFittingsItem {
    /**
     * flag string
     */
    'flag': GetCharactersCharacterIdFittingsItemFlagEnum;
    /**
     * quantity integer
     */
    'quantity': number;
    /**
     * type_id integer
     */
    'type_id': number;
}

export const GetCharactersCharacterIdFittingsItemFlagEnum = {
    Cargo: 'Cargo',
    DroneBay: 'DroneBay',
    FighterBay: 'FighterBay',
    HiSlot0: 'HiSlot0',
    HiSlot1: 'HiSlot1',
    HiSlot2: 'HiSlot2',
    HiSlot3: 'HiSlot3',
    HiSlot4: 'HiSlot4',
    HiSlot5: 'HiSlot5',
    HiSlot6: 'HiSlot6',
    HiSlot7: 'HiSlot7',
    Invalid: 'Invalid',
    LoSlot0: 'LoSlot0',
    LoSlot1: 'LoSlot1',
    LoSlot2: 'LoSlot2',
    LoSlot3: 'LoSlot3',
    LoSlot4: 'LoSlot4',
    LoSlot5: 'LoSlot5',
    LoSlot6: 'LoSlot6',
    LoSlot7: 'LoSlot7',
    MedSlot0: 'MedSlot0',
    MedSlot1: 'MedSlot1',
    MedSlot2: 'MedSlot2',
    MedSlot3: 'MedSlot3',
    MedSlot4: 'MedSlot4',
    MedSlot5: 'MedSlot5',
    MedSlot6: 'MedSlot6',
    MedSlot7: 'MedSlot7',
    RigSlot0: 'RigSlot0',
    RigSlot1: 'RigSlot1',
    RigSlot2: 'RigSlot2',
    ServiceSlot0: 'ServiceSlot0',
    ServiceSlot1: 'ServiceSlot1',
    ServiceSlot2: 'ServiceSlot2',
    ServiceSlot3: 'ServiceSlot3',
    ServiceSlot4: 'ServiceSlot4',
    ServiceSlot5: 'ServiceSlot5',
    ServiceSlot6: 'ServiceSlot6',
    ServiceSlot7: 'ServiceSlot7',
    SubSystemSlot0: 'SubSystemSlot0',
    SubSystemSlot1: 'SubSystemSlot1',
    SubSystemSlot2: 'SubSystemSlot2',
    SubSystemSlot3: 'SubSystemSlot3'
} as const;

export type GetCharactersCharacterIdFittingsItemFlagEnum = typeof GetCharactersCharacterIdFittingsItemFlagEnum[keyof typeof GetCharactersCharacterIdFittingsItemFlagEnum];

/**
 * Not found
 */
export interface GetCharactersCharacterIdFleetNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdFleetOk {
    /**
     * Character ID of the current fleet boss
     */
    'fleet_boss_id': number;
    /**
     * The character\'s current fleet ID
     */
    'fleet_id': number;
    /**
     * Member’s role in fleet
     */
    'role': GetCharactersCharacterIdFleetOkRoleEnum;
    /**
     * ID of the squad the member is in. If not applicable, will be set to -1
     */
    'squad_id': number;
    /**
     * ID of the wing the member is in. If not applicable, will be set to -1
     */
    'wing_id': number;
}

export const GetCharactersCharacterIdFleetOkRoleEnum = {
    FleetCommander: 'fleet_commander',
    SquadCommander: 'squad_commander',
    SquadMember: 'squad_member',
    WingCommander: 'wing_commander'
} as const;

export type GetCharactersCharacterIdFleetOkRoleEnum = typeof GetCharactersCharacterIdFleetOkRoleEnum[keyof typeof GetCharactersCharacterIdFleetOkRoleEnum];

/**
 * Summary of kills done by the given character against enemy factions
 */
export interface GetCharactersCharacterIdFwStatsKills {
    /**
     * Last week\'s total number of kills by a given character against enemy factions
     */
    'last_week': number;
    /**
     * Total number of kills by a given character against enemy factions since the character enlisted
     */
    'total': number;
    /**
     * Yesterday\'s total number of kills by a given character against enemy factions
     */
    'yesterday': number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdFwStatsOk {
    /**
     * The given character\'s current faction rank
     */
    'current_rank'?: number;
    /**
     * The enlistment date of the given character into faction warfare. Will not be included if character is not enlisted in faction warfare
     */
    'enlisted_on'?: string;
    /**
     * The faction the given character is enlisted to fight for. Will not be included if character is not enlisted in faction warfare
     */
    'faction_id'?: number;
    /**
     * The given character\'s highest faction rank achieved
     */
    'highest_rank'?: number;
    'kills': GetCharactersCharacterIdFwStatsKills;
    'victory_points': GetCharactersCharacterIdFwStatsVictoryPoints;
}
/**
 * Summary of victory points gained by the given character for the enlisted faction
 */
export interface GetCharactersCharacterIdFwStatsVictoryPoints {
    /**
     * Last week\'s victory points gained by the given character
     */
    'last_week': number;
    /**
     * Total victory points gained since the given character enlisted
     */
    'total': number;
    /**
     * Yesterday\'s victory points gained by the given character
     */
    'yesterday': number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdIndustryJobs200Ok {
    /**
     * Job activity ID
     */
    'activity_id': number;
    /**
     * blueprint_id integer
     */
    'blueprint_id': number;
    /**
     * Location ID of the location from which the blueprint was installed. Normally a station ID, but can also be an asset (e.g. container) or corporation facility
     */
    'blueprint_location_id': number;
    /**
     * blueprint_type_id integer
     */
    'blueprint_type_id': number;
    /**
     * ID of the character which completed this job
     */
    'completed_character_id'?: number;
    /**
     * Date and time when this job was completed
     */
    'completed_date'?: string;
    /**
     * The sume of job installation fee and industry facility tax
     */
    'cost'?: number;
    /**
     * Job duration in seconds
     */
    'duration': number;
    /**
     * Date and time when this job finished
     */
    'end_date': string;
    /**
     * ID of the facility where this job is running
     */
    'facility_id': number;
    /**
     * ID of the character which installed this job
     */
    'installer_id': number;
    /**
     * Unique job ID
     */
    'job_id': number;
    /**
     * Number of runs blueprint is licensed for
     */
    'licensed_runs'?: number;
    /**
     * Location ID of the location to which the output of the job will be delivered. Normally a station ID, but can also be a corporation facility
     */
    'output_location_id': number;
    /**
     * Date and time when this job was paused (i.e. time when the facility where this job was installed went offline)
     */
    'pause_date'?: string;
    /**
     * Chance of success for invention
     */
    'probability'?: number;
    /**
     * Type ID of product (manufactured, copied or invented)
     */
    'product_type_id'?: number;
    /**
     * Number of runs for a manufacturing job, or number of copies to make for a blueprint copy
     */
    'runs': number;
    /**
     * Date and time when this job started
     */
    'start_date': string;
    /**
     * ID of the station where industry facility is located
     */
    'station_id': number;
    /**
     * status string
     */
    'status': GetCharactersCharacterIdIndustryJobs200OkStatusEnum;
    /**
     * Number of successful runs for this job. Equal to runs unless this is an invention job
     */
    'successful_runs'?: number;
}

export const GetCharactersCharacterIdIndustryJobs200OkStatusEnum = {
    Active: 'active',
    Cancelled: 'cancelled',
    Delivered: 'delivered',
    Paused: 'paused',
    Ready: 'ready',
    Reverted: 'reverted'
} as const;

export type GetCharactersCharacterIdIndustryJobs200OkStatusEnum = typeof GetCharactersCharacterIdIndustryJobs200OkStatusEnum[keyof typeof GetCharactersCharacterIdIndustryJobs200OkStatusEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdKillmailsRecent200Ok {
    /**
     * A hash of this killmail
     */
    'killmail_hash': string;
    /**
     * ID of this killmail
     */
    'killmail_id': number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdLocationOk {
    /**
     * solar_system_id integer
     */
    'solar_system_id': number;
    /**
     * station_id integer
     */
    'station_id'?: number;
    /**
     * structure_id integer
     */
    'structure_id'?: number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdLoyaltyPoints200Ok {
    /**
     * corporation_id integer
     */
    'corporation_id': number;
    /**
     * loyalty_points integer
     */
    'loyalty_points': number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdMail200Ok {
    /**
     * From whom the mail was sent
     */
    'from'?: number;
    /**
     * is_read boolean
     */
    'is_read'?: boolean;
    /**
     * labels array
     */
    'labels'?: Set<number>;
    /**
     * mail_id integer
     */
    'mail_id'?: number;
    /**
     * Recipients of the mail
     */
    'recipients'?: Set<GetCharactersCharacterIdMailRecipient>;
    /**
     * Mail subject
     */
    'subject'?: string;
    /**
     * When the mail was sent
     */
    'timestamp'?: string;
}
/**
 * label object
 */
export interface GetCharactersCharacterIdMailLabelsLabel {
    /**
     * color string
     */
    'color'?: GetCharactersCharacterIdMailLabelsLabelColorEnum;
    /**
     * label_id integer
     */
    'label_id'?: number;
    /**
     * name string
     */
    'name'?: string;
    /**
     * unread_count integer
     */
    'unread_count'?: number;
}

export const GetCharactersCharacterIdMailLabelsLabelColorEnum = {
    _0000fe: '#0000fe',
    _006634: '#006634',
    _0099ff: '#0099ff',
    _00ff33: '#00ff33',
    _01ffff: '#01ffff',
    _349800: '#349800',
    _660066: '#660066',
    _666666: '#666666',
    _999999: '#999999',
    _99ffff: '#99ffff',
    _9a0000: '#9a0000',
    Ccff9a: '#ccff9a',
    E6e6e6: '#e6e6e6',
    Fe0000: '#fe0000',
    Ff6600: '#ff6600',
    Ffff01: '#ffff01',
    Ffffcd: '#ffffcd',
    Ffffff: '#ffffff'
} as const;

export type GetCharactersCharacterIdMailLabelsLabelColorEnum = typeof GetCharactersCharacterIdMailLabelsLabelColorEnum[keyof typeof GetCharactersCharacterIdMailLabelsLabelColorEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdMailLabelsOk {
    /**
     * labels array
     */
    'labels'?: Array<GetCharactersCharacterIdMailLabelsLabel>;
    /**
     * total_unread_count integer
     */
    'total_unread_count'?: number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdMailLists200Ok {
    /**
     * Mailing list ID
     */
    'mailing_list_id': number;
    /**
     * name string
     */
    'name': string;
}
/**
 * Not found
 */
export interface GetCharactersCharacterIdMailMailIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdMailMailIdOk {
    /**
     * Mail\'s body
     */
    'body'?: string;
    /**
     * From whom the mail was sent
     */
    'from'?: number;
    /**
     * Labels attached to the mail
     */
    'labels'?: Array<number>;
    /**
     * Whether the mail is flagged as read
     */
    'read'?: boolean;
    /**
     * Recipients of the mail
     */
    'recipients'?: Set<GetCharactersCharacterIdMailMailIdRecipient>;
    /**
     * Mail subject
     */
    'subject'?: string;
    /**
     * When the mail was sent
     */
    'timestamp'?: string;
}
/**
 * recipient object
 */
export interface GetCharactersCharacterIdMailMailIdRecipient {
    /**
     * recipient_id integer
     */
    'recipient_id': number;
    /**
     * recipient_type string
     */
    'recipient_type': GetCharactersCharacterIdMailMailIdRecipientRecipientTypeEnum;
}

export const GetCharactersCharacterIdMailMailIdRecipientRecipientTypeEnum = {
    Alliance: 'alliance',
    Character: 'character',
    Corporation: 'corporation',
    MailingList: 'mailing_list'
} as const;

export type GetCharactersCharacterIdMailMailIdRecipientRecipientTypeEnum = typeof GetCharactersCharacterIdMailMailIdRecipientRecipientTypeEnum[keyof typeof GetCharactersCharacterIdMailMailIdRecipientRecipientTypeEnum];

/**
 * recipient object
 */
export interface GetCharactersCharacterIdMailRecipient {
    /**
     * recipient_id integer
     */
    'recipient_id': number;
    /**
     * recipient_type string
     */
    'recipient_type': GetCharactersCharacterIdMailRecipientRecipientTypeEnum;
}

export const GetCharactersCharacterIdMailRecipientRecipientTypeEnum = {
    Alliance: 'alliance',
    Character: 'character',
    Corporation: 'corporation',
    MailingList: 'mailing_list'
} as const;

export type GetCharactersCharacterIdMailRecipientRecipientTypeEnum = typeof GetCharactersCharacterIdMailRecipientRecipientTypeEnum[keyof typeof GetCharactersCharacterIdMailRecipientRecipientTypeEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdMedals200Ok {
    /**
     * corporation_id integer
     */
    'corporation_id': number;
    /**
     * date string
     */
    'date': string;
    /**
     * description string
     */
    'description': string;
    /**
     * graphics array
     */
    'graphics': Array<GetCharactersCharacterIdMedalsGraphic>;
    /**
     * issuer_id integer
     */
    'issuer_id': number;
    /**
     * medal_id integer
     */
    'medal_id': number;
    /**
     * reason string
     */
    'reason': string;
    /**
     * status string
     */
    'status': GetCharactersCharacterIdMedals200OkStatusEnum;
    /**
     * title string
     */
    'title': string;
}

export const GetCharactersCharacterIdMedals200OkStatusEnum = {
    Public: 'public',
    Private: 'private'
} as const;

export type GetCharactersCharacterIdMedals200OkStatusEnum = typeof GetCharactersCharacterIdMedals200OkStatusEnum[keyof typeof GetCharactersCharacterIdMedals200OkStatusEnum];

/**
 * graphic object
 */
export interface GetCharactersCharacterIdMedalsGraphic {
    /**
     * color integer
     */
    'color'?: number;
    /**
     * graphic string
     */
    'graphic': string;
    /**
     * layer integer
     */
    'layer': number;
    /**
     * part integer
     */
    'part': number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdMining200Ok {
    /**
     * date string
     */
    'date': string;
    /**
     * quantity integer
     */
    'quantity': number;
    /**
     * solar_system_id integer
     */
    'solar_system_id': number;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * Not found
 */
export interface GetCharactersCharacterIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdNotifications200Ok {
    /**
     * is_read boolean
     */
    'is_read'?: boolean;
    /**
     * notification_id integer
     */
    'notification_id': number;
    /**
     * sender_id integer
     */
    'sender_id': number;
    /**
     * sender_type string
     */
    'sender_type': GetCharactersCharacterIdNotifications200OkSenderTypeEnum;
    /**
     * text string
     */
    'text'?: string;
    /**
     * timestamp string
     */
    'timestamp': string;
    /**
     * type string
     */
    'type': GetCharactersCharacterIdNotifications200OkTypeEnum;
}

export const GetCharactersCharacterIdNotifications200OkSenderTypeEnum = {
    Character: 'character',
    Corporation: 'corporation',
    Alliance: 'alliance',
    Faction: 'faction',
    Other: 'other'
} as const;

export type GetCharactersCharacterIdNotifications200OkSenderTypeEnum = typeof GetCharactersCharacterIdNotifications200OkSenderTypeEnum[keyof typeof GetCharactersCharacterIdNotifications200OkSenderTypeEnum];
export const GetCharactersCharacterIdNotifications200OkTypeEnum = {
    AcceptedAlly: 'AcceptedAlly',
    AcceptedSurrender: 'AcceptedSurrender',
    AgentRetiredTrigravian: 'AgentRetiredTrigravian',
    AllAnchoringMsg: 'AllAnchoringMsg',
    AllMaintenanceBillMsg: 'AllMaintenanceBillMsg',
    AllStrucInvulnerableMsg: 'AllStrucInvulnerableMsg',
    AllStructVulnerableMsg: 'AllStructVulnerableMsg',
    AllWarCorpJoinedAllianceMsg: 'AllWarCorpJoinedAllianceMsg',
    AllWarDeclaredMsg: 'AllWarDeclaredMsg',
    AllWarInvalidatedMsg: 'AllWarInvalidatedMsg',
    AllWarRetractedMsg: 'AllWarRetractedMsg',
    AllWarSurrenderMsg: 'AllWarSurrenderMsg',
    AllianceCapitalChanged: 'AllianceCapitalChanged',
    AllianceWarDeclaredV2: 'AllianceWarDeclaredV2',
    AllyContractCancelled: 'AllyContractCancelled',
    AllyJoinedWarAggressorMsg: 'AllyJoinedWarAggressorMsg',
    AllyJoinedWarAllyMsg: 'AllyJoinedWarAllyMsg',
    AllyJoinedWarDefenderMsg: 'AllyJoinedWarDefenderMsg',
    BattlePunishFriendlyFire: 'BattlePunishFriendlyFire',
    BillOutOfMoneyMsg: 'BillOutOfMoneyMsg',
    BillPaidCorpAllMsg: 'BillPaidCorpAllMsg',
    BountyClaimMsg: 'BountyClaimMsg',
    BountyEssShared: 'BountyESSShared',
    BountyEssTaken: 'BountyESSTaken',
    BountyPlacedAlliance: 'BountyPlacedAlliance',
    BountyPlacedChar: 'BountyPlacedChar',
    BountyPlacedCorp: 'BountyPlacedCorp',
    BountyYourBountyClaimed: 'BountyYourBountyClaimed',
    BuddyConnectContactAdd: 'BuddyConnectContactAdd',
    CharAppAcceptMsg: 'CharAppAcceptMsg',
    CharAppRejectMsg: 'CharAppRejectMsg',
    CharAppWithdrawMsg: 'CharAppWithdrawMsg',
    CharLeftCorpMsg: 'CharLeftCorpMsg',
    CharMedalMsg: 'CharMedalMsg',
    CharTerminationMsg: 'CharTerminationMsg',
    CloneActivationMsg: 'CloneActivationMsg',
    CloneActivationMsg2: 'CloneActivationMsg2',
    CloneMovedMsg: 'CloneMovedMsg',
    CloneRevokedMsg1: 'CloneRevokedMsg1',
    CloneRevokedMsg2: 'CloneRevokedMsg2',
    CombatOperationFinished: 'CombatOperationFinished',
    ContactAdd: 'ContactAdd',
    ContactEdit: 'ContactEdit',
    ContainerPasswordMsg: 'ContainerPasswordMsg',
    ContractRegionChangedToPochven: 'ContractRegionChangedToPochven',
    CorpAllBillMsg: 'CorpAllBillMsg',
    CorpAppAcceptMsg: 'CorpAppAcceptMsg',
    CorpAppInvitedMsg: 'CorpAppInvitedMsg',
    CorpAppNewMsg: 'CorpAppNewMsg',
    CorpAppRejectCustomMsg: 'CorpAppRejectCustomMsg',
    CorpAppRejectMsg: 'CorpAppRejectMsg',
    CorpBecameWarEligible: 'CorpBecameWarEligible',
    CorpDividendMsg: 'CorpDividendMsg',
    CorpFriendlyFireDisableTimerCompleted: 'CorpFriendlyFireDisableTimerCompleted',
    CorpFriendlyFireDisableTimerStarted: 'CorpFriendlyFireDisableTimerStarted',
    CorpFriendlyFireEnableTimerCompleted: 'CorpFriendlyFireEnableTimerCompleted',
    CorpFriendlyFireEnableTimerStarted: 'CorpFriendlyFireEnableTimerStarted',
    CorpKicked: 'CorpKicked',
    CorpLiquidationMsg: 'CorpLiquidationMsg',
    CorpNewCeoMsg: 'CorpNewCEOMsg',
    CorpNewsMsg: 'CorpNewsMsg',
    CorpNoLongerWarEligible: 'CorpNoLongerWarEligible',
    CorpOfficeExpirationMsg: 'CorpOfficeExpirationMsg',
    CorpStructLostMsg: 'CorpStructLostMsg',
    CorpTaxChangeMsg: 'CorpTaxChangeMsg',
    CorpVoteCeoRevokedMsg: 'CorpVoteCEORevokedMsg',
    CorpVoteMsg: 'CorpVoteMsg',
    CorpWarDeclaredMsg: 'CorpWarDeclaredMsg',
    CorpWarDeclaredV2: 'CorpWarDeclaredV2',
    CorpWarFightingLegalMsg: 'CorpWarFightingLegalMsg',
    CorpWarInvalidatedMsg: 'CorpWarInvalidatedMsg',
    CorpWarRetractedMsg: 'CorpWarRetractedMsg',
    CorpWarSurrenderMsg: 'CorpWarSurrenderMsg',
    CorporationGoalClosed: 'CorporationGoalClosed',
    CorporationGoalCompleted: 'CorporationGoalCompleted',
    CorporationGoalCreated: 'CorporationGoalCreated',
    CorporationGoalExpired: 'CorporationGoalExpired',
    CorporationGoalLimitReached: 'CorporationGoalLimitReached',
    CorporationGoalNameChange: 'CorporationGoalNameChange',
    CorporationLeft: 'CorporationLeft',
    CustomsMsg: 'CustomsMsg',
    DailyItemRewardAutoClaimed: 'DailyItemRewardAutoClaimed',
    DeclareWar: 'DeclareWar',
    DistrictAttacked: 'DistrictAttacked',
    DustAppAcceptedMsg: 'DustAppAcceptedMsg',
    EssMainBankLink: 'ESSMainBankLink',
    EntosisCaptureStarted: 'EntosisCaptureStarted',
    ExpertSystemExpired: 'ExpertSystemExpired',
    ExpertSystemExpiryImminent: 'ExpertSystemExpiryImminent',
    FwAllianceKickMsg: 'FWAllianceKickMsg',
    FwAllianceWarningMsg: 'FWAllianceWarningMsg',
    FwCharKickMsg: 'FWCharKickMsg',
    FwCharRankGainMsg: 'FWCharRankGainMsg',
    FwCharRankLossMsg: 'FWCharRankLossMsg',
    FwCharWarningMsg: 'FWCharWarningMsg',
    FwCorpJoinMsg: 'FWCorpJoinMsg',
    FwCorpKickMsg: 'FWCorpKickMsg',
    FwCorpLeaveMsg: 'FWCorpLeaveMsg',
    FwCorpWarningMsg: 'FWCorpWarningMsg',
    FacWarCorpJoinRequestMsg: 'FacWarCorpJoinRequestMsg',
    FacWarCorpJoinWithdrawMsg: 'FacWarCorpJoinWithdrawMsg',
    FacWarCorpLeaveRequestMsg: 'FacWarCorpLeaveRequestMsg',
    FacWarCorpLeaveWithdrawMsg: 'FacWarCorpLeaveWithdrawMsg',
    FacWarLpDisqualifiedEvent: 'FacWarLPDisqualifiedEvent',
    FacWarLpDisqualifiedKill: 'FacWarLPDisqualifiedKill',
    FacWarLpPayoutEvent: 'FacWarLPPayoutEvent',
    FacWarLpPayoutKill: 'FacWarLPPayoutKill',
    FreelanceProjectClosed: 'FreelanceProjectClosed',
    FreelanceProjectCompleted: 'FreelanceProjectCompleted',
    FreelanceProjectCreated: 'FreelanceProjectCreated',
    FreelanceProjectExpired: 'FreelanceProjectExpired',
    FreelanceProjectLimitReached: 'FreelanceProjectLimitReached',
    FreelanceProjectParticipantKicked: 'FreelanceProjectParticipantKicked',
    GameTimeAdded: 'GameTimeAdded',
    GameTimeReceived: 'GameTimeReceived',
    GameTimeSent: 'GameTimeSent',
    GiftReceived: 'GiftReceived',
    IHubDestroyedByBillFailure: 'IHubDestroyedByBillFailure',
    IncursionCompletedMsg: 'IncursionCompletedMsg',
    IndustryOperationFinished: 'IndustryOperationFinished',
    IndustryTeamAuctionLost: 'IndustryTeamAuctionLost',
    IndustryTeamAuctionWon: 'IndustryTeamAuctionWon',
    InfrastructureHubBillAboutToExpire: 'InfrastructureHubBillAboutToExpire',
    InsuranceExpirationMsg: 'InsuranceExpirationMsg',
    InsuranceFirstShipMsg: 'InsuranceFirstShipMsg',
    InsuranceInvalidatedMsg: 'InsuranceInvalidatedMsg',
    InsuranceIssuedMsg: 'InsuranceIssuedMsg',
    InsurancePayoutMsg: 'InsurancePayoutMsg',
    InvasionCompletedMsg: 'InvasionCompletedMsg',
    InvasionSystemLogin: 'InvasionSystemLogin',
    InvasionSystemStart: 'InvasionSystemStart',
    JumpCloneDeletedMsg1: 'JumpCloneDeletedMsg1',
    JumpCloneDeletedMsg2: 'JumpCloneDeletedMsg2',
    KillReportFinalBlow: 'KillReportFinalBlow',
    KillReportVictim: 'KillReportVictim',
    KillRightAvailable: 'KillRightAvailable',
    KillRightAvailableOpen: 'KillRightAvailableOpen',
    KillRightEarned: 'KillRightEarned',
    KillRightUnavailable: 'KillRightUnavailable',
    KillRightUnavailableOpen: 'KillRightUnavailableOpen',
    KillRightUsed: 'KillRightUsed',
    LpAutoRedeemed: 'LPAutoRedeemed',
    LocateCharMsg: 'LocateCharMsg',
    MadeWarMutual: 'MadeWarMutual',
    MercOfferRetractedMsg: 'MercOfferRetractedMsg',
    MercOfferedNegotiationMsg: 'MercOfferedNegotiationMsg',
    MercenaryDenAttacked: 'MercenaryDenAttacked',
    MercenaryDenNewMto: 'MercenaryDenNewMTO',
    MercenaryDenReinforced: 'MercenaryDenReinforced',
    MissionCanceledTriglavian: 'MissionCanceledTriglavian',
    MissionOfferExpirationMsg: 'MissionOfferExpirationMsg',
    MissionTimeoutMsg: 'MissionTimeoutMsg',
    MoonminingAutomaticFracture: 'MoonminingAutomaticFracture',
    MoonminingExtractionCancelled: 'MoonminingExtractionCancelled',
    MoonminingExtractionFinished: 'MoonminingExtractionFinished',
    MoonminingExtractionStarted: 'MoonminingExtractionStarted',
    MoonminingLaserFired: 'MoonminingLaserFired',
    MutualWarExpired: 'MutualWarExpired',
    MutualWarInviteAccepted: 'MutualWarInviteAccepted',
    MutualWarInviteRejected: 'MutualWarInviteRejected',
    MutualWarInviteSent: 'MutualWarInviteSent',
    NpcStandingsGained: 'NPCStandingsGained',
    NpcStandingsLost: 'NPCStandingsLost',
    OfferToAllyRetracted: 'OfferToAllyRetracted',
    OfferedSurrender: 'OfferedSurrender',
    OfferedToAlly: 'OfferedToAlly',
    OfficeLeaseCanceledInsufficientStandings: 'OfficeLeaseCanceledInsufficientStandings',
    OldLscMessages: 'OldLscMessages',
    OperationFinished: 'OperationFinished',
    OrbitalAttacked: 'OrbitalAttacked',
    OrbitalReinforced: 'OrbitalReinforced',
    OwnershipTransferred: 'OwnershipTransferred',
    RaffleCreated: 'RaffleCreated',
    RaffleExpired: 'RaffleExpired',
    RaffleFinished: 'RaffleFinished',
    ReimbursementMsg: 'ReimbursementMsg',
    ResearchMissionAvailableMsg: 'ResearchMissionAvailableMsg',
    RetractsWar: 'RetractsWar',
    SpAutoRedeemed: 'SPAutoRedeemed',
    SeasonalChallengeCompleted: 'SeasonalChallengeCompleted',
    SkinSequencingCompleted: 'SkinSequencingCompleted',
    SkyhookDeployed: 'SkyhookDeployed',
    SkyhookDestroyed: 'SkyhookDestroyed',
    SkyhookLostShields: 'SkyhookLostShields',
    SkyhookOnline: 'SkyhookOnline',
    SkyhookUnderAttack: 'SkyhookUnderAttack',
    SovAllClaimAquiredMsg: 'SovAllClaimAquiredMsg',
    SovAllClaimLostMsg: 'SovAllClaimLostMsg',
    SovCommandNodeEventStarted: 'SovCommandNodeEventStarted',
    SovCorpBillLateMsg: 'SovCorpBillLateMsg',
    SovCorpClaimFailMsg: 'SovCorpClaimFailMsg',
    SovDisruptorMsg: 'SovDisruptorMsg',
    SovStationEnteredFreeport: 'SovStationEnteredFreeport',
    SovStructureDestroyed: 'SovStructureDestroyed',
    SovStructureReinforced: 'SovStructureReinforced',
    SovStructureSelfDestructCancel: 'SovStructureSelfDestructCancel',
    SovStructureSelfDestructFinished: 'SovStructureSelfDestructFinished',
    SovStructureSelfDestructRequested: 'SovStructureSelfDestructRequested',
    SovereigntyIhDamageMsg: 'SovereigntyIHDamageMsg',
    SovereigntySbuDamageMsg: 'SovereigntySBUDamageMsg',
    SovereigntyTcuDamageMsg: 'SovereigntyTCUDamageMsg',
    StationAggressionMsg1: 'StationAggressionMsg1',
    StationAggressionMsg2: 'StationAggressionMsg2',
    StationConquerMsg: 'StationConquerMsg',
    StationServiceDisabled: 'StationServiceDisabled',
    StationServiceEnabled: 'StationServiceEnabled',
    StationStateChangeMsg: 'StationStateChangeMsg',
    StoryLineMissionAvailableMsg: 'StoryLineMissionAvailableMsg',
    StructureAnchoring: 'StructureAnchoring',
    StructureCourierContractChanged: 'StructureCourierContractChanged',
    StructureDestroyed: 'StructureDestroyed',
    StructureFuelAlert: 'StructureFuelAlert',
    StructureImpendingAbandonmentAssetsAtRisk: 'StructureImpendingAbandonmentAssetsAtRisk',
    StructureItemsDelivered: 'StructureItemsDelivered',
    StructureItemsMovedToSafety: 'StructureItemsMovedToSafety',
    StructureLostArmor: 'StructureLostArmor',
    StructureLostShields: 'StructureLostShields',
    StructureLowReagentsAlert: 'StructureLowReagentsAlert',
    StructureNoReagentsAlert: 'StructureNoReagentsAlert',
    StructureOnline: 'StructureOnline',
    StructurePaintPurchased: 'StructurePaintPurchased',
    StructureServicesOffline: 'StructureServicesOffline',
    StructureUnanchoring: 'StructureUnanchoring',
    StructureUnderAttack: 'StructureUnderAttack',
    StructureWentHighPower: 'StructureWentHighPower',
    StructureWentLowPower: 'StructureWentLowPower',
    StructuresJobsCancelled: 'StructuresJobsCancelled',
    StructuresJobsPaused: 'StructuresJobsPaused',
    StructuresReinforcementChanged: 'StructuresReinforcementChanged',
    TowerAlertMsg: 'TowerAlertMsg',
    TowerResourceAlertMsg: 'TowerResourceAlertMsg',
    TransactionReversalMsg: 'TransactionReversalMsg',
    TutorialMsg: 'TutorialMsg',
    WarAdopted: 'WarAdopted ',
    WarAllyInherited: 'WarAllyInherited',
    WarAllyOfferDeclinedMsg: 'WarAllyOfferDeclinedMsg',
    WarConcordInvalidates: 'WarConcordInvalidates',
    WarDeclared: 'WarDeclared',
    WarEndedHqSecurityDrop: 'WarEndedHqSecurityDrop',
    WarHqRemovedFromSpace: 'WarHQRemovedFromSpace',
    WarInherited: 'WarInherited',
    WarInvalid: 'WarInvalid',
    WarRetracted: 'WarRetracted',
    WarRetractedByConcord: 'WarRetractedByConcord',
    WarSurrenderDeclinedMsg: 'WarSurrenderDeclinedMsg',
    WarSurrenderOfferMsg: 'WarSurrenderOfferMsg'
} as const;

export type GetCharactersCharacterIdNotifications200OkTypeEnum = typeof GetCharactersCharacterIdNotifications200OkTypeEnum[keyof typeof GetCharactersCharacterIdNotifications200OkTypeEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdNotificationsContacts200Ok {
    /**
     * message string
     */
    'message': string;
    /**
     * notification_id integer
     */
    'notification_id': number;
    /**
     * send_date string
     */
    'send_date': string;
    /**
     * sender_character_id integer
     */
    'sender_character_id': number;
    /**
     * A number representing the standing level the receiver has been added at by the sender. The standing levels are as follows: -10 -> Terrible | -5 -> Bad |  0 -> Neutral |  5 -> Good |  10 -> Excellent
     */
    'standing_level': number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdOk {
    /**
     * The character\'s alliance ID
     */
    'alliance_id'?: number;
    /**
     * Creation date of the character
     */
    'birthday': string;
    /**
     * bloodline_id integer
     */
    'bloodline_id': number;
    /**
     * The character\'s corporation ID
     */
    'corporation_id': number;
    /**
     * description string
     */
    'description'?: string;
    /**
     * ID of the faction the character is fighting for, if the character is enlisted in Factional Warfare
     */
    'faction_id'?: number;
    /**
     * gender string
     */
    'gender': GetCharactersCharacterIdOkGenderEnum;
    /**
     * name string
     */
    'name': string;
    /**
     * race_id integer
     */
    'race_id': number;
    /**
     * security_status number
     */
    'security_status'?: number;
    /**
     * The individual title of the character
     */
    'title'?: string;
}

export const GetCharactersCharacterIdOkGenderEnum = {
    Female: 'female',
    Male: 'male'
} as const;

export type GetCharactersCharacterIdOkGenderEnum = typeof GetCharactersCharacterIdOkGenderEnum[keyof typeof GetCharactersCharacterIdOkGenderEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdOnlineOk {
    /**
     * Timestamp of the last login
     */
    'last_login'?: string;
    /**
     * Timestamp of the last logout
     */
    'last_logout'?: string;
    /**
     * Total number of times the character has logged in
     */
    'logins'?: number;
    /**
     * If the character is online
     */
    'online': boolean;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdOrders200Ok {
    /**
     * Number of days for which order is valid (starting from the issued date). An order expires at time issued + duration
     */
    'duration': number;
    /**
     * For buy orders, the amount of ISK in escrow
     */
    'escrow'?: number;
    /**
     * True if the order is a bid (buy) order
     */
    'is_buy_order'?: boolean;
    /**
     * Signifies whether the buy/sell order was placed on behalf of a corporation.
     */
    'is_corporation': boolean;
    /**
     * Date and time when this order was issued
     */
    'issued': string;
    /**
     * ID of the location where order was placed
     */
    'location_id': number;
    /**
     * For buy orders, the minimum quantity that will be accepted in a matching sell order
     */
    'min_volume'?: number;
    /**
     * Unique order ID
     */
    'order_id': number;
    /**
     * Cost per unit for this order
     */
    'price': number;
    /**
     * Valid order range, numbers are ranges in jumps
     */
    'range': GetCharactersCharacterIdOrders200OkRangeEnum;
    /**
     * ID of the region where order was placed
     */
    'region_id': number;
    /**
     * The type ID of the item transacted in this order
     */
    'type_id': number;
    /**
     * Quantity of items still required or offered
     */
    'volume_remain': number;
    /**
     * Quantity of items required or offered at time order was placed
     */
    'volume_total': number;
}

export const GetCharactersCharacterIdOrders200OkRangeEnum = {
    _1: '1',
    _10: '10',
    _2: '2',
    _20: '20',
    _3: '3',
    _30: '30',
    _4: '4',
    _40: '40',
    _5: '5',
    Region: 'region',
    Solarsystem: 'solarsystem',
    Station: 'station'
} as const;

export type GetCharactersCharacterIdOrders200OkRangeEnum = typeof GetCharactersCharacterIdOrders200OkRangeEnum[keyof typeof GetCharactersCharacterIdOrders200OkRangeEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdOrdersHistory200Ok {
    /**
     * Number of days the order was valid for (starting from the issued date). An order expires at time issued + duration
     */
    'duration': number;
    /**
     * For buy orders, the amount of ISK in escrow
     */
    'escrow'?: number;
    /**
     * True if the order is a bid (buy) order
     */
    'is_buy_order'?: boolean;
    /**
     * Signifies whether the buy/sell order was placed on behalf of a corporation.
     */
    'is_corporation': boolean;
    /**
     * Date and time when this order was issued
     */
    'issued': string;
    /**
     * ID of the location where order was placed
     */
    'location_id': number;
    /**
     * For buy orders, the minimum quantity that will be accepted in a matching sell order
     */
    'min_volume'?: number;
    /**
     * Unique order ID
     */
    'order_id': number;
    /**
     * Cost per unit for this order
     */
    'price': number;
    /**
     * Valid order range, numbers are ranges in jumps
     */
    'range': GetCharactersCharacterIdOrdersHistory200OkRangeEnum;
    /**
     * ID of the region where order was placed
     */
    'region_id': number;
    /**
     * Current order state
     */
    'state': GetCharactersCharacterIdOrdersHistory200OkStateEnum;
    /**
     * The type ID of the item transacted in this order
     */
    'type_id': number;
    /**
     * Quantity of items still required or offered
     */
    'volume_remain': number;
    /**
     * Quantity of items required or offered at time order was placed
     */
    'volume_total': number;
}

export const GetCharactersCharacterIdOrdersHistory200OkRangeEnum = {
    _1: '1',
    _10: '10',
    _2: '2',
    _20: '20',
    _3: '3',
    _30: '30',
    _4: '4',
    _40: '40',
    _5: '5',
    Region: 'region',
    Solarsystem: 'solarsystem',
    Station: 'station'
} as const;

export type GetCharactersCharacterIdOrdersHistory200OkRangeEnum = typeof GetCharactersCharacterIdOrdersHistory200OkRangeEnum[keyof typeof GetCharactersCharacterIdOrdersHistory200OkRangeEnum];
export const GetCharactersCharacterIdOrdersHistory200OkStateEnum = {
    Cancelled: 'cancelled',
    Expired: 'expired'
} as const;

export type GetCharactersCharacterIdOrdersHistory200OkStateEnum = typeof GetCharactersCharacterIdOrdersHistory200OkStateEnum[keyof typeof GetCharactersCharacterIdOrdersHistory200OkStateEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdPlanets200Ok {
    /**
     * last_update string
     */
    'last_update': string;
    /**
     * num_pins integer
     */
    'num_pins': number;
    /**
     * owner_id integer
     */
    'owner_id': number;
    /**
     * planet_id integer
     */
    'planet_id': number;
    /**
     * planet_type string
     */
    'planet_type': GetCharactersCharacterIdPlanets200OkPlanetTypeEnum;
    /**
     * solar_system_id integer
     */
    'solar_system_id': number;
    /**
     * upgrade_level integer
     */
    'upgrade_level': number;
}

export const GetCharactersCharacterIdPlanets200OkPlanetTypeEnum = {
    Temperate: 'temperate',
    Barren: 'barren',
    Oceanic: 'oceanic',
    Ice: 'ice',
    Gas: 'gas',
    Lava: 'lava',
    Storm: 'storm',
    Plasma: 'plasma'
} as const;

export type GetCharactersCharacterIdPlanets200OkPlanetTypeEnum = typeof GetCharactersCharacterIdPlanets200OkPlanetTypeEnum[keyof typeof GetCharactersCharacterIdPlanets200OkPlanetTypeEnum];

/**
 * content object
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdContent {
    /**
     * amount integer
     */
    'amount': number;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * extractor_details object
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails {
    /**
     * in seconds
     */
    'cycle_time'?: number;
    /**
     * head_radius number
     */
    'head_radius'?: number;
    /**
     * heads array
     */
    'heads': Array<GetCharactersCharacterIdPlanetsPlanetIdHead>;
    /**
     * product_type_id integer
     */
    'product_type_id'?: number;
    /**
     * qty_per_cycle integer
     */
    'qty_per_cycle'?: number;
}
/**
 * factory_details object
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails {
    /**
     * schematic_id integer
     */
    'schematic_id': number;
}
/**
 * head object
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdHead {
    /**
     * head_id integer
     */
    'head_id': number;
    /**
     * latitude number
     */
    'latitude': number;
    /**
     * longitude number
     */
    'longitude': number;
}
/**
 * link object
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdLink {
    /**
     * destination_pin_id integer
     */
    'destination_pin_id': number;
    /**
     * link_level integer
     */
    'link_level': number;
    /**
     * source_pin_id integer
     */
    'source_pin_id': number;
}
/**
 * Colony not found
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdNotFound {
    /**
     * error message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdOk {
    /**
     * links array
     */
    'links': Array<GetCharactersCharacterIdPlanetsPlanetIdLink>;
    /**
     * pins array
     */
    'pins': Array<GetCharactersCharacterIdPlanetsPlanetIdPin>;
    /**
     * routes array
     */
    'routes': Array<GetCharactersCharacterIdPlanetsPlanetIdRoute>;
}
/**
 * pin object
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdPin {
    /**
     * contents array
     */
    'contents'?: Array<GetCharactersCharacterIdPlanetsPlanetIdContent>;
    /**
     * expiry_time string
     */
    'expiry_time'?: string;
    'extractor_details'?: GetCharactersCharacterIdPlanetsPlanetIdExtractorDetails;
    'factory_details'?: GetCharactersCharacterIdPlanetsPlanetIdFactoryDetails;
    /**
     * install_time string
     */
    'install_time'?: string;
    /**
     * last_cycle_start string
     */
    'last_cycle_start'?: string;
    /**
     * latitude number
     */
    'latitude': number;
    /**
     * longitude number
     */
    'longitude': number;
    /**
     * pin_id integer
     */
    'pin_id': number;
    /**
     * schematic_id integer
     */
    'schematic_id'?: number;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * route object
 */
export interface GetCharactersCharacterIdPlanetsPlanetIdRoute {
    /**
     * content_type_id integer
     */
    'content_type_id': number;
    /**
     * destination_pin_id integer
     */
    'destination_pin_id': number;
    /**
     * quantity number
     */
    'quantity': number;
    /**
     * route_id integer
     */
    'route_id': number;
    /**
     * source_pin_id integer
     */
    'source_pin_id': number;
    /**
     * list of pin ID waypoints
     */
    'waypoints'?: Array<number>;
}
/**
 * No image server for this datasource
 */
export interface GetCharactersCharacterIdPortraitNotFound {
    /**
     * error message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdPortraitOk {
    /**
     * px128x128 string
     */
    'px128x128'?: string;
    /**
     * px256x256 string
     */
    'px256x256'?: string;
    /**
     * px512x512 string
     */
    'px512x512'?: string;
    /**
     * px64x64 string
     */
    'px64x64'?: string;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdRolesOk {
    /**
     * roles array
     */
    'roles'?: Array<GetCharactersCharacterIdRolesOkRolesEnum>;
    /**
     * roles_at_base array
     */
    'roles_at_base'?: Array<GetCharactersCharacterIdRolesOkRolesAtBaseEnum>;
    /**
     * roles_at_hq array
     */
    'roles_at_hq'?: Array<GetCharactersCharacterIdRolesOkRolesAtHqEnum>;
    /**
     * roles_at_other array
     */
    'roles_at_other'?: Array<GetCharactersCharacterIdRolesOkRolesAtOtherEnum>;
}

export const GetCharactersCharacterIdRolesOkRolesEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCharactersCharacterIdRolesOkRolesEnum = typeof GetCharactersCharacterIdRolesOkRolesEnum[keyof typeof GetCharactersCharacterIdRolesOkRolesEnum];
export const GetCharactersCharacterIdRolesOkRolesAtBaseEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCharactersCharacterIdRolesOkRolesAtBaseEnum = typeof GetCharactersCharacterIdRolesOkRolesAtBaseEnum[keyof typeof GetCharactersCharacterIdRolesOkRolesAtBaseEnum];
export const GetCharactersCharacterIdRolesOkRolesAtHqEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCharactersCharacterIdRolesOkRolesAtHqEnum = typeof GetCharactersCharacterIdRolesOkRolesAtHqEnum[keyof typeof GetCharactersCharacterIdRolesOkRolesAtHqEnum];
export const GetCharactersCharacterIdRolesOkRolesAtOtherEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCharactersCharacterIdRolesOkRolesAtOtherEnum = typeof GetCharactersCharacterIdRolesOkRolesAtOtherEnum[keyof typeof GetCharactersCharacterIdRolesOkRolesAtOtherEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdSearchOk {
    /**
     * agent array
     */
    'agent'?: Array<number>;
    /**
     * alliance array
     */
    'alliance'?: Array<number>;
    /**
     * character array
     */
    'character'?: Array<number>;
    /**
     * constellation array
     */
    'constellation'?: Array<number>;
    /**
     * corporation array
     */
    'corporation'?: Array<number>;
    /**
     * faction array
     */
    'faction'?: Array<number>;
    /**
     * inventory_type array
     */
    'inventory_type'?: Array<number>;
    /**
     * region array
     */
    'region'?: Array<number>;
    /**
     * solar_system array
     */
    'solar_system'?: Array<number>;
    /**
     * station array
     */
    'station'?: Array<number>;
    /**
     * structure array
     */
    'structure'?: Array<number>;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdShipOk {
    /**
     * Item id\'s are unique to a ship and persist until it is repackaged. This value can be used to track repeated uses of a ship, or detect when a pilot changes into a different instance of the same ship type.
     */
    'ship_item_id': number;
    /**
     * ship_name string
     */
    'ship_name': string;
    /**
     * ship_type_id integer
     */
    'ship_type_id': number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdSkillqueue200Ok {
    /**
     * Date on which training of the skill will complete. Omitted if the skill queue is paused.
     */
    'finish_date'?: string;
    /**
     * finished_level integer
     */
    'finished_level': number;
    /**
     * level_end_sp integer
     */
    'level_end_sp'?: number;
    /**
     * Amount of SP that was in the skill when it started training it\'s current level. Used to calculate % of current level complete.
     */
    'level_start_sp'?: number;
    /**
     * queue_position integer
     */
    'queue_position': number;
    /**
     * skill_id integer
     */
    'skill_id': number;
    /**
     * start_date string
     */
    'start_date'?: string;
    /**
     * training_start_sp integer
     */
    'training_start_sp'?: number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdSkillsOk {
    /**
     * skills array
     */
    'skills': Array<GetCharactersCharacterIdSkillsSkill>;
    /**
     * total_sp integer
     */
    'total_sp': number;
    /**
     * Skill points available to be assigned
     */
    'unallocated_sp'?: number;
}
/**
 * skill object
 */
export interface GetCharactersCharacterIdSkillsSkill {
    /**
     * active_skill_level integer
     */
    'active_skill_level': number;
    /**
     * skill_id integer
     */
    'skill_id': number;
    /**
     * skillpoints_in_skill integer
     */
    'skillpoints_in_skill': number;
    /**
     * trained_skill_level integer
     */
    'trained_skill_level': number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdStandings200Ok {
    /**
     * from_id integer
     */
    'from_id': number;
    /**
     * from_type string
     */
    'from_type': GetCharactersCharacterIdStandings200OkFromTypeEnum;
    /**
     * standing number
     */
    'standing': number;
}

export const GetCharactersCharacterIdStandings200OkFromTypeEnum = {
    Agent: 'agent',
    NpcCorp: 'npc_corp',
    Faction: 'faction'
} as const;

export type GetCharactersCharacterIdStandings200OkFromTypeEnum = typeof GetCharactersCharacterIdStandings200OkFromTypeEnum[keyof typeof GetCharactersCharacterIdStandings200OkFromTypeEnum];

/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdTitles200Ok {
    /**
     * name string
     */
    'name'?: string;
    /**
     * title_id integer
     */
    'title_id'?: number;
}
/**
 * 200 ok object
 */
export interface GetCharactersCharacterIdWalletJournal200Ok {
    /**
     * The amount of ISK given or taken from the wallet as a result of the given transaction. Positive when ISK is deposited into the wallet and negative when ISK is withdrawn
     */
    'amount'?: number;
    /**
     * Wallet balance after transaction occurred
     */
    'balance'?: number;
    /**
     * An ID that gives extra context to the particular transaction. Because of legacy reasons the context is completely different per ref_type and means different things. It is also possible to not have a context_id
     */
    'context_id'?: number;
    /**
     * The type of the given context_id if present
     */
    'context_id_type'?: GetCharactersCharacterIdWalletJournal200OkContextIdTypeEnum;
    /**
     * Date and time of transaction
     */
    'date': string;
    /**
     * The reason for the transaction, mirrors what is seen in the client
     */
    'description': string;
    /**
     * The id of the first party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
     */
    'first_party_id'?: number;
    /**
     * Unique journal reference ID
     */
    'id': number;
    /**
     * The user stated reason for the transaction. Only applies to some ref_types
     */
    'reason'?: string;
    /**
     * \"The transaction type for the given. transaction. Different transaction types will populate different attributes.\"
     */
    'ref_type': GetCharactersCharacterIdWalletJournal200OkRefTypeEnum;
    /**
     * The id of the second party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
     */
    'second_party_id'?: number;
    /**
     * Tax amount received. Only applies to tax related transactions
     */
    'tax'?: number;
    /**
     * The corporation ID receiving any tax paid. Only applies to tax related transactions
     */
    'tax_receiver_id'?: number;
}

export const GetCharactersCharacterIdWalletJournal200OkContextIdTypeEnum = {
    StructureId: 'structure_id',
    StationId: 'station_id',
    MarketTransactionId: 'market_transaction_id',
    CharacterId: 'character_id',
    CorporationId: 'corporation_id',
    AllianceId: 'alliance_id',
    EveSystem: 'eve_system',
    IndustryJobId: 'industry_job_id',
    ContractId: 'contract_id',
    PlanetId: 'planet_id',
    SystemId: 'system_id',
    TypeId: 'type_id'
} as const;

export type GetCharactersCharacterIdWalletJournal200OkContextIdTypeEnum = typeof GetCharactersCharacterIdWalletJournal200OkContextIdTypeEnum[keyof typeof GetCharactersCharacterIdWalletJournal200OkContextIdTypeEnum];
export const GetCharactersCharacterIdWalletJournal200OkRefTypeEnum = {
    AccelerationGateFee: 'acceleration_gate_fee',
    AdvertisementListingFee: 'advertisement_listing_fee',
    AgentDonation: 'agent_donation',
    AgentLocationServices: 'agent_location_services',
    AgentMiscellaneous: 'agent_miscellaneous',
    AgentMissionCollateralPaid: 'agent_mission_collateral_paid',
    AgentMissionCollateralRefunded: 'agent_mission_collateral_refunded',
    AgentMissionReward: 'agent_mission_reward',
    AgentMissionRewardCorporationTax: 'agent_mission_reward_corporation_tax',
    AgentMissionTimeBonusReward: 'agent_mission_time_bonus_reward',
    AgentMissionTimeBonusRewardCorporationTax: 'agent_mission_time_bonus_reward_corporation_tax',
    AgentSecurityServices: 'agent_security_services',
    AgentServicesRendered: 'agent_services_rendered',
    AgentsPreward: 'agents_preward',
    AirCareerProgramReward: 'air_career_program_reward',
    AllianceMaintainanceFee: 'alliance_maintainance_fee',
    AllianceRegistrationFee: 'alliance_registration_fee',
    AllignmentBasedGateToll: 'allignment_based_gate_toll',
    AssetSafetyRecoveryTax: 'asset_safety_recovery_tax',
    Bounty: 'bounty',
    BountyPrize: 'bounty_prize',
    BountyPrizeCorporationTax: 'bounty_prize_corporation_tax',
    BountyPrizes: 'bounty_prizes',
    BountyReimbursement: 'bounty_reimbursement',
    BountySurcharge: 'bounty_surcharge',
    BrokersFee: 'brokers_fee',
    CloneActivation: 'clone_activation',
    CloneTransfer: 'clone_transfer',
    ContrabandFine: 'contraband_fine',
    ContractAuctionBid: 'contract_auction_bid',
    ContractAuctionBidCorp: 'contract_auction_bid_corp',
    ContractAuctionBidRefund: 'contract_auction_bid_refund',
    ContractAuctionSold: 'contract_auction_sold',
    ContractBrokersFee: 'contract_brokers_fee',
    ContractBrokersFeeCorp: 'contract_brokers_fee_corp',
    ContractCollateral: 'contract_collateral',
    ContractCollateralDepositedCorp: 'contract_collateral_deposited_corp',
    ContractCollateralPayout: 'contract_collateral_payout',
    ContractCollateralRefund: 'contract_collateral_refund',
    ContractDeposit: 'contract_deposit',
    ContractDepositCorp: 'contract_deposit_corp',
    ContractDepositRefund: 'contract_deposit_refund',
    ContractDepositSalesTax: 'contract_deposit_sales_tax',
    ContractPrice: 'contract_price',
    ContractPricePaymentCorp: 'contract_price_payment_corp',
    ContractReversal: 'contract_reversal',
    ContractReward: 'contract_reward',
    ContractRewardDeposited: 'contract_reward_deposited',
    ContractRewardDepositedCorp: 'contract_reward_deposited_corp',
    ContractRewardRefund: 'contract_reward_refund',
    ContractSalesTax: 'contract_sales_tax',
    Copying: 'copying',
    CorporateRewardPayout: 'corporate_reward_payout',
    CorporateRewardTax: 'corporate_reward_tax',
    CorporationAccountWithdrawal: 'corporation_account_withdrawal',
    CorporationBulkPayment: 'corporation_bulk_payment',
    CorporationDividendPayment: 'corporation_dividend_payment',
    CorporationLiquidation: 'corporation_liquidation',
    CorporationLogoChangeCost: 'corporation_logo_change_cost',
    CorporationPayment: 'corporation_payment',
    CorporationRegistrationFee: 'corporation_registration_fee',
    CosmeticMarketComponentItemPurchase: 'cosmetic_market_component_item_purchase',
    CosmeticMarketSkinPurchase: 'cosmetic_market_skin_purchase',
    CosmeticMarketSkinSale: 'cosmetic_market_skin_sale',
    CosmeticMarketSkinSaleBrokerFee: 'cosmetic_market_skin_sale_broker_fee',
    CosmeticMarketSkinSaleTax: 'cosmetic_market_skin_sale_tax',
    CosmeticMarketSkinTransaction: 'cosmetic_market_skin_transaction',
    CourierMissionEscrow: 'courier_mission_escrow',
    Cspa: 'cspa',
    Cspaofflinerefund: 'cspaofflinerefund',
    DailyChallengeReward: 'daily_challenge_reward',
    DailyGoalPayouts: 'daily_goal_payouts',
    DailyGoalPayoutsTax: 'daily_goal_payouts_tax',
    DatacoreFee: 'datacore_fee',
    DnaModificationFee: 'dna_modification_fee',
    DockingFee: 'docking_fee',
    DuelWagerEscrow: 'duel_wager_escrow',
    DuelWagerPayment: 'duel_wager_payment',
    DuelWagerRefund: 'duel_wager_refund',
    EssEscrowTransfer: 'ess_escrow_transfer',
    ExternalTradeDelivery: 'external_trade_delivery',
    ExternalTradeFreeze: 'external_trade_freeze',
    ExternalTradeThaw: 'external_trade_thaw',
    FactorySlotRentalFee: 'factory_slot_rental_fee',
    FluxPayout: 'flux_payout',
    FluxTax: 'flux_tax',
    FluxTicketRepayment: 'flux_ticket_repayment',
    FluxTicketSale: 'flux_ticket_sale',
    FreelanceJobsBroadcastingFee: 'freelance_jobs_broadcasting_fee',
    FreelanceJobsDurationFee: 'freelance_jobs_duration_fee',
    FreelanceJobsEscrowRefund: 'freelance_jobs_escrow_refund',
    FreelanceJobsReward: 'freelance_jobs_reward',
    FreelanceJobsRewardCorporationTax: 'freelance_jobs_reward_corporation_tax',
    FreelanceJobsRewardEscrow: 'freelance_jobs_reward_escrow',
    GmCashTransfer: 'gm_cash_transfer',
    GmPlexFeeRefund: 'gm_plex_fee_refund',
    IndustryJobTax: 'industry_job_tax',
    InfrastructureHubMaintenance: 'infrastructure_hub_maintenance',
    Inheritance: 'inheritance',
    Insurance: 'insurance',
    InsurgencyCorruptionContributionReward: 'insurgency_corruption_contribution_reward',
    InsurgencySuppressionContributionReward: 'insurgency_suppression_contribution_reward',
    ItemTraderPayment: 'item_trader_payment',
    JumpCloneActivationFee: 'jump_clone_activation_fee',
    JumpCloneInstallationFee: 'jump_clone_installation_fee',
    KillRightFee: 'kill_right_fee',
    LpStore: 'lp_store',
    Manufacturing: 'manufacturing',
    MarketEscrow: 'market_escrow',
    MarketFinePaid: 'market_fine_paid',
    MarketProviderTax: 'market_provider_tax',
    MarketTransaction: 'market_transaction',
    MedalCreation: 'medal_creation',
    MedalIssued: 'medal_issued',
    MilestoneRewardPayment: 'milestone_reward_payment',
    MissionCompletion: 'mission_completion',
    MissionCost: 'mission_cost',
    MissionExpiration: 'mission_expiration',
    MissionReward: 'mission_reward',
    OfficeRentalFee: 'office_rental_fee',
    OperationBonus: 'operation_bonus',
    OpportunityReward: 'opportunity_reward',
    PlanetaryConstruction: 'planetary_construction',
    PlanetaryExportTax: 'planetary_export_tax',
    PlanetaryImportTax: 'planetary_import_tax',
    PlayerDonation: 'player_donation',
    PlayerTrading: 'player_trading',
    ProjectDiscoveryReward: 'project_discovery_reward',
    ProjectDiscoveryTax: 'project_discovery_tax',
    ProjectPayouts: 'project_payouts',
    Reaction: 'reaction',
    RedeemedIskToken: 'redeemed_isk_token',
    ReleaseOfImpoundedProperty: 'release_of_impounded_property',
    RepairBill: 'repair_bill',
    ReprocessingTax: 'reprocessing_tax',
    ResearchingMaterialProductivity: 'researching_material_productivity',
    ResearchingTechnology: 'researching_technology',
    ResearchingTimeProductivity: 'researching_time_productivity',
    ResourceWarsReward: 'resource_wars_reward',
    ReverseEngineering: 'reverse_engineering',
    SeasonChallengeReward: 'season_challenge_reward',
    SecurityProcessingFee: 'security_processing_fee',
    Shares: 'shares',
    SkillPurchase: 'skill_purchase',
    SkyhookClaimFee: 'skyhook_claim_fee',
    SovereignityBill: 'sovereignity_bill',
    StorePurchase: 'store_purchase',
    StorePurchaseRefund: 'store_purchase_refund',
    StructureGateJump: 'structure_gate_jump',
    TransactionTax: 'transaction_tax',
    UnderConstruction: 'under_construction',
    UpkeepAdjustmentFee: 'upkeep_adjustment_fee',
    WarAllyContract: 'war_ally_contract',
    WarFee: 'war_fee',
    WarFeeSurrender: 'war_fee_surrender'
} as const;

export type GetCharactersCharacterIdWalletJournal200OkRefTypeEnum = typeof GetCharactersCharacterIdWalletJournal200OkRefTypeEnum[keyof typeof GetCharactersCharacterIdWalletJournal200OkRefTypeEnum];

/**
 * wallet transaction
 */
export interface GetCharactersCharacterIdWalletTransactions200Ok {
    /**
     * client_id integer
     */
    'client_id': number;
    /**
     * Date and time of transaction
     */
    'date': string;
    /**
     * is_buy boolean
     */
    'is_buy': boolean;
    /**
     * is_personal boolean
     */
    'is_personal': boolean;
    /**
     * journal_ref_id integer
     */
    'journal_ref_id': number;
    /**
     * location_id integer
     */
    'location_id': number;
    /**
     * quantity integer
     */
    'quantity': number;
    /**
     * Unique transaction ID
     */
    'transaction_id': number;
    /**
     * type_id integer
     */
    'type_id': number;
    /**
     * Amount paid per unit
     */
    'unit_price': number;
}
/**
 * 200 ok object
 */
export interface GetContractsPublicBidsContractId200Ok {
    /**
     * The amount bid, in ISK
     */
    'amount': number;
    /**
     * Unique ID for the bid
     */
    'bid_id': number;
    /**
     * Datetime when the bid was placed
     */
    'date_bid': string;
}
/**
 * Forbidden
 */
export interface GetContractsPublicBidsContractIdForbidden {
    /**
     * Forbidden message
     */
    'error'?: string;
}
/**
 * Not found
 */
export interface GetContractsPublicBidsContractIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetContractsPublicItemsContractId200Ok {
    /**
     * is_blueprint_copy boolean
     */
    'is_blueprint_copy'?: boolean;
    /**
     * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
     */
    'is_included': boolean;
    /**
     * Unique ID for the item being sold. Not present if item is being requested by contract rather than sold with contract
     */
    'item_id'?: number;
    /**
     * Material Efficiency Level of the blueprint
     */
    'material_efficiency'?: number;
    /**
     * Number of items in the stack
     */
    'quantity': number;
    /**
     * Unique ID for the item, used by the contract system
     */
    'record_id': number;
    /**
     * Number of runs remaining if the blueprint is a copy, -1 if it is an original
     */
    'runs'?: number;
    /**
     * Time Efficiency Level of the blueprint
     */
    'time_efficiency'?: number;
    /**
     * Type ID for item
     */
    'type_id': number;
}
/**
 * Forbidden
 */
export interface GetContractsPublicItemsContractIdForbidden {
    /**
     * Forbidden message
     */
    'error'?: string;
}
/**
 * Not found
 */
export interface GetContractsPublicItemsContractIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetContractsPublicRegionId200Ok {
    /**
     * Buyout price (for Auctions only)
     */
    'buyout'?: number;
    /**
     * Collateral price (for Couriers only)
     */
    'collateral'?: number;
    /**
     * contract_id integer
     */
    'contract_id': number;
    /**
     * Expiration date of the contract
     */
    'date_expired': string;
    /**
     * Сreation date of the contract
     */
    'date_issued': string;
    /**
     * Number of days to perform the contract
     */
    'days_to_complete'?: number;
    /**
     * End location ID (for Couriers contract)
     */
    'end_location_id'?: number;
    /**
     * true if the contract was issued on behalf of the issuer\'s corporation
     */
    'for_corporation'?: boolean;
    /**
     * Character\'s corporation ID for the issuer
     */
    'issuer_corporation_id': number;
    /**
     * Character ID for the issuer
     */
    'issuer_id': number;
    /**
     * Price of contract (for ItemsExchange and Auctions)
     */
    'price'?: number;
    /**
     * Remuneration for contract (for Couriers only)
     */
    'reward'?: number;
    /**
     * Start location ID (for Couriers contract)
     */
    'start_location_id'?: number;
    /**
     * Title of the contract
     */
    'title'?: string;
    /**
     * Type of the contract
     */
    'type': GetContractsPublicRegionId200OkTypeEnum;
    /**
     * Volume of items in the contract
     */
    'volume'?: number;
}

export const GetContractsPublicRegionId200OkTypeEnum = {
    Unknown: 'unknown',
    ItemExchange: 'item_exchange',
    Auction: 'auction',
    Courier: 'courier',
    Loan: 'loan'
} as const;

export type GetContractsPublicRegionId200OkTypeEnum = typeof GetContractsPublicRegionId200OkTypeEnum[keyof typeof GetContractsPublicRegionId200OkTypeEnum];

/**
 * Not found
 */
export interface GetContractsPublicRegionIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCorporationCorporationIdMiningExtractions200Ok {
    /**
     * The time at which the chunk being extracted will arrive and can be fractured by the moon mining drill. 
     */
    'chunk_arrival_time': string;
    /**
     * The time at which the current extraction was initiated. 
     */
    'extraction_start_time': string;
    /**
     * moon_id integer
     */
    'moon_id': number;
    /**
     * The time at which the chunk being extracted will naturally fracture if it is not first fractured by the moon mining drill. 
     */
    'natural_decay_time': string;
    /**
     * structure_id integer
     */
    'structure_id': number;
}
/**
 * 200 ok object
 */
export interface GetCorporationCorporationIdMiningObservers200Ok {
    /**
     * last_updated string
     */
    'last_updated': string;
    /**
     * The entity that was observing the asteroid field when it was mined. 
     */
    'observer_id': number;
    /**
     * The category of the observing entity
     */
    'observer_type': GetCorporationCorporationIdMiningObservers200OkObserverTypeEnum;
}

export const GetCorporationCorporationIdMiningObservers200OkObserverTypeEnum = {
    Structure: 'structure'
} as const;

export type GetCorporationCorporationIdMiningObservers200OkObserverTypeEnum = typeof GetCorporationCorporationIdMiningObservers200OkObserverTypeEnum[keyof typeof GetCorporationCorporationIdMiningObservers200OkObserverTypeEnum];

/**
 * 200 ok object
 */
export interface GetCorporationCorporationIdMiningObserversObserverId200Ok {
    /**
     * The character that did the mining 
     */
    'character_id': number;
    /**
     * last_updated string
     */
    'last_updated': string;
    /**
     * quantity integer
     */
    'quantity': number;
    /**
     * The corporation id of the character at the time data was recorded. 
     */
    'recorded_corporation_id': number;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdAlliancehistory200Ok {
    /**
     * alliance_id integer
     */
    'alliance_id'?: number;
    /**
     * True if the alliance has been closed
     */
    'is_deleted'?: boolean;
    /**
     * An incrementing ID that can be used to canonically establish order of records in cases where dates may be ambiguous
     */
    'record_id': number;
    /**
     * start_date string
     */
    'start_date': string;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdAssets200Ok {
    /**
     * is_blueprint_copy boolean
     */
    'is_blueprint_copy'?: boolean;
    /**
     * is_singleton boolean
     */
    'is_singleton': boolean;
    /**
     * item_id integer
     */
    'item_id': number;
    /**
     * location_flag string
     */
    'location_flag': GetCorporationsCorporationIdAssets200OkLocationFlagEnum;
    /**
     * location_id integer
     */
    'location_id': number;
    /**
     * location_type string
     */
    'location_type': GetCorporationsCorporationIdAssets200OkLocationTypeEnum;
    /**
     * quantity integer
     */
    'quantity': number;
    /**
     * type_id integer
     */
    'type_id': number;
}

export const GetCorporationsCorporationIdAssets200OkLocationFlagEnum = {
    AssetSafety: 'AssetSafety',
    AutoFit: 'AutoFit',
    Bonus: 'Bonus',
    Booster: 'Booster',
    BoosterBay: 'BoosterBay',
    Capsule: 'Capsule',
    CapsuleerDeliveries: 'CapsuleerDeliveries',
    Cargo: 'Cargo',
    CorpDeliveries: 'CorpDeliveries',
    CorpSag1: 'CorpSAG1',
    CorpSag2: 'CorpSAG2',
    CorpSag3: 'CorpSAG3',
    CorpSag4: 'CorpSAG4',
    CorpSag5: 'CorpSAG5',
    CorpSag6: 'CorpSAG6',
    CorpSag7: 'CorpSAG7',
    CorporationGoalDeliveries: 'CorporationGoalDeliveries',
    CrateLoot: 'CrateLoot',
    Deliveries: 'Deliveries',
    DroneBay: 'DroneBay',
    DustBattle: 'DustBattle',
    DustDatabank: 'DustDatabank',
    FighterBay: 'FighterBay',
    FighterTube0: 'FighterTube0',
    FighterTube1: 'FighterTube1',
    FighterTube2: 'FighterTube2',
    FighterTube3: 'FighterTube3',
    FighterTube4: 'FighterTube4',
    FleetHangar: 'FleetHangar',
    FrigateEscapeBay: 'FrigateEscapeBay',
    Hangar: 'Hangar',
    HangarAll: 'HangarAll',
    HiSlot0: 'HiSlot0',
    HiSlot1: 'HiSlot1',
    HiSlot2: 'HiSlot2',
    HiSlot3: 'HiSlot3',
    HiSlot4: 'HiSlot4',
    HiSlot5: 'HiSlot5',
    HiSlot6: 'HiSlot6',
    HiSlot7: 'HiSlot7',
    HiddenModifiers: 'HiddenModifiers',
    Implant: 'Implant',
    Impounded: 'Impounded',
    InfrastructureHangar: 'InfrastructureHangar',
    JunkyardReprocessed: 'JunkyardReprocessed',
    JunkyardTrashed: 'JunkyardTrashed',
    LoSlot0: 'LoSlot0',
    LoSlot1: 'LoSlot1',
    LoSlot2: 'LoSlot2',
    LoSlot3: 'LoSlot3',
    LoSlot4: 'LoSlot4',
    LoSlot5: 'LoSlot5',
    LoSlot6: 'LoSlot6',
    LoSlot7: 'LoSlot7',
    Locked: 'Locked',
    MedSlot0: 'MedSlot0',
    MedSlot1: 'MedSlot1',
    MedSlot2: 'MedSlot2',
    MedSlot3: 'MedSlot3',
    MedSlot4: 'MedSlot4',
    MedSlot5: 'MedSlot5',
    MedSlot6: 'MedSlot6',
    MedSlot7: 'MedSlot7',
    MobileDepotHold: 'MobileDepotHold',
    MoonMaterialBay: 'MoonMaterialBay',
    OfficeFolder: 'OfficeFolder',
    Pilot: 'Pilot',
    PlanetSurface: 'PlanetSurface',
    QuafeBay: 'QuafeBay',
    QuantumCoreRoom: 'QuantumCoreRoom',
    Reward: 'Reward',
    RigSlot0: 'RigSlot0',
    RigSlot1: 'RigSlot1',
    RigSlot2: 'RigSlot2',
    RigSlot3: 'RigSlot3',
    RigSlot4: 'RigSlot4',
    RigSlot5: 'RigSlot5',
    RigSlot6: 'RigSlot6',
    RigSlot7: 'RigSlot7',
    SecondaryStorage: 'SecondaryStorage',
    ServiceSlot0: 'ServiceSlot0',
    ServiceSlot1: 'ServiceSlot1',
    ServiceSlot2: 'ServiceSlot2',
    ServiceSlot3: 'ServiceSlot3',
    ServiceSlot4: 'ServiceSlot4',
    ServiceSlot5: 'ServiceSlot5',
    ServiceSlot6: 'ServiceSlot6',
    ServiceSlot7: 'ServiceSlot7',
    ShipHangar: 'ShipHangar',
    ShipOffline: 'ShipOffline',
    Skill: 'Skill',
    SkillInTraining: 'SkillInTraining',
    SpecializedAmmoHold: 'SpecializedAmmoHold',
    SpecializedAsteroidHold: 'SpecializedAsteroidHold',
    SpecializedCommandCenterHold: 'SpecializedCommandCenterHold',
    SpecializedFuelBay: 'SpecializedFuelBay',
    SpecializedGasHold: 'SpecializedGasHold',
    SpecializedIceHold: 'SpecializedIceHold',
    SpecializedIndustrialShipHold: 'SpecializedIndustrialShipHold',
    SpecializedLargeShipHold: 'SpecializedLargeShipHold',
    SpecializedMaterialBay: 'SpecializedMaterialBay',
    SpecializedMediumShipHold: 'SpecializedMediumShipHold',
    SpecializedMineralHold: 'SpecializedMineralHold',
    SpecializedOreHold: 'SpecializedOreHold',
    SpecializedPlanetaryCommoditiesHold: 'SpecializedPlanetaryCommoditiesHold',
    SpecializedSalvageHold: 'SpecializedSalvageHold',
    SpecializedShipHold: 'SpecializedShipHold',
    SpecializedSmallShipHold: 'SpecializedSmallShipHold',
    StructureActive: 'StructureActive',
    StructureFuel: 'StructureFuel',
    StructureInactive: 'StructureInactive',
    StructureOffline: 'StructureOffline',
    SubSystemBay: 'SubSystemBay',
    SubSystemSlot0: 'SubSystemSlot0',
    SubSystemSlot1: 'SubSystemSlot1',
    SubSystemSlot2: 'SubSystemSlot2',
    SubSystemSlot3: 'SubSystemSlot3',
    SubSystemSlot4: 'SubSystemSlot4',
    SubSystemSlot5: 'SubSystemSlot5',
    SubSystemSlot6: 'SubSystemSlot6',
    SubSystemSlot7: 'SubSystemSlot7',
    Unlocked: 'Unlocked',
    Wallet: 'Wallet',
    Wardrobe: 'Wardrobe'
} as const;

export type GetCorporationsCorporationIdAssets200OkLocationFlagEnum = typeof GetCorporationsCorporationIdAssets200OkLocationFlagEnum[keyof typeof GetCorporationsCorporationIdAssets200OkLocationFlagEnum];
export const GetCorporationsCorporationIdAssets200OkLocationTypeEnum = {
    Station: 'station',
    SolarSystem: 'solar_system',
    Item: 'item',
    Other: 'other'
} as const;

export type GetCorporationsCorporationIdAssets200OkLocationTypeEnum = typeof GetCorporationsCorporationIdAssets200OkLocationTypeEnum[keyof typeof GetCorporationsCorporationIdAssets200OkLocationTypeEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdBlueprints200Ok {
    /**
     * Unique ID for this item.
     */
    'item_id': number;
    /**
     * Type of the location_id
     */
    'location_flag': GetCorporationsCorporationIdBlueprints200OkLocationFlagEnum;
    /**
     * References a station, a ship or an item_id if this blueprint is located within a container.
     */
    'location_id': number;
    /**
     * Material Efficiency Level of the blueprint.
     */
    'material_efficiency': number;
    /**
     * A range of numbers with a minimum of -2 and no maximum value where -1 is an original and -2 is a copy. It can be a positive integer if it is a stack of blueprint originals fresh from the market (e.g. no activities performed on them yet).
     */
    'quantity': number;
    /**
     * Number of runs remaining if the blueprint is a copy, -1 if it is an original.
     */
    'runs': number;
    /**
     * Time Efficiency Level of the blueprint.
     */
    'time_efficiency': number;
    /**
     * type_id integer
     */
    'type_id': number;
}

export const GetCorporationsCorporationIdBlueprints200OkLocationFlagEnum = {
    AssetSafety: 'AssetSafety',
    AutoFit: 'AutoFit',
    Bonus: 'Bonus',
    Booster: 'Booster',
    BoosterBay: 'BoosterBay',
    Capsule: 'Capsule',
    CapsuleerDeliveries: 'CapsuleerDeliveries',
    Cargo: 'Cargo',
    CorpDeliveries: 'CorpDeliveries',
    CorpSag1: 'CorpSAG1',
    CorpSag2: 'CorpSAG2',
    CorpSag3: 'CorpSAG3',
    CorpSag4: 'CorpSAG4',
    CorpSag5: 'CorpSAG5',
    CorpSag6: 'CorpSAG6',
    CorpSag7: 'CorpSAG7',
    CorporationGoalDeliveries: 'CorporationGoalDeliveries',
    CrateLoot: 'CrateLoot',
    Deliveries: 'Deliveries',
    DroneBay: 'DroneBay',
    DustBattle: 'DustBattle',
    DustDatabank: 'DustDatabank',
    FighterBay: 'FighterBay',
    FighterTube0: 'FighterTube0',
    FighterTube1: 'FighterTube1',
    FighterTube2: 'FighterTube2',
    FighterTube3: 'FighterTube3',
    FighterTube4: 'FighterTube4',
    FleetHangar: 'FleetHangar',
    FrigateEscapeBay: 'FrigateEscapeBay',
    Hangar: 'Hangar',
    HangarAll: 'HangarAll',
    HiSlot0: 'HiSlot0',
    HiSlot1: 'HiSlot1',
    HiSlot2: 'HiSlot2',
    HiSlot3: 'HiSlot3',
    HiSlot4: 'HiSlot4',
    HiSlot5: 'HiSlot5',
    HiSlot6: 'HiSlot6',
    HiSlot7: 'HiSlot7',
    HiddenModifiers: 'HiddenModifiers',
    Implant: 'Implant',
    Impounded: 'Impounded',
    InfrastructureHangar: 'InfrastructureHangar',
    JunkyardReprocessed: 'JunkyardReprocessed',
    JunkyardTrashed: 'JunkyardTrashed',
    LoSlot0: 'LoSlot0',
    LoSlot1: 'LoSlot1',
    LoSlot2: 'LoSlot2',
    LoSlot3: 'LoSlot3',
    LoSlot4: 'LoSlot4',
    LoSlot5: 'LoSlot5',
    LoSlot6: 'LoSlot6',
    LoSlot7: 'LoSlot7',
    Locked: 'Locked',
    MedSlot0: 'MedSlot0',
    MedSlot1: 'MedSlot1',
    MedSlot2: 'MedSlot2',
    MedSlot3: 'MedSlot3',
    MedSlot4: 'MedSlot4',
    MedSlot5: 'MedSlot5',
    MedSlot6: 'MedSlot6',
    MedSlot7: 'MedSlot7',
    MobileDepotHold: 'MobileDepotHold',
    MoonMaterialBay: 'MoonMaterialBay',
    OfficeFolder: 'OfficeFolder',
    Pilot: 'Pilot',
    PlanetSurface: 'PlanetSurface',
    QuafeBay: 'QuafeBay',
    QuantumCoreRoom: 'QuantumCoreRoom',
    Reward: 'Reward',
    RigSlot0: 'RigSlot0',
    RigSlot1: 'RigSlot1',
    RigSlot2: 'RigSlot2',
    RigSlot3: 'RigSlot3',
    RigSlot4: 'RigSlot4',
    RigSlot5: 'RigSlot5',
    RigSlot6: 'RigSlot6',
    RigSlot7: 'RigSlot7',
    SecondaryStorage: 'SecondaryStorage',
    ServiceSlot0: 'ServiceSlot0',
    ServiceSlot1: 'ServiceSlot1',
    ServiceSlot2: 'ServiceSlot2',
    ServiceSlot3: 'ServiceSlot3',
    ServiceSlot4: 'ServiceSlot4',
    ServiceSlot5: 'ServiceSlot5',
    ServiceSlot6: 'ServiceSlot6',
    ServiceSlot7: 'ServiceSlot7',
    ShipHangar: 'ShipHangar',
    ShipOffline: 'ShipOffline',
    Skill: 'Skill',
    SkillInTraining: 'SkillInTraining',
    SpecializedAmmoHold: 'SpecializedAmmoHold',
    SpecializedAsteroidHold: 'SpecializedAsteroidHold',
    SpecializedCommandCenterHold: 'SpecializedCommandCenterHold',
    SpecializedFuelBay: 'SpecializedFuelBay',
    SpecializedGasHold: 'SpecializedGasHold',
    SpecializedIceHold: 'SpecializedIceHold',
    SpecializedIndustrialShipHold: 'SpecializedIndustrialShipHold',
    SpecializedLargeShipHold: 'SpecializedLargeShipHold',
    SpecializedMaterialBay: 'SpecializedMaterialBay',
    SpecializedMediumShipHold: 'SpecializedMediumShipHold',
    SpecializedMineralHold: 'SpecializedMineralHold',
    SpecializedOreHold: 'SpecializedOreHold',
    SpecializedPlanetaryCommoditiesHold: 'SpecializedPlanetaryCommoditiesHold',
    SpecializedSalvageHold: 'SpecializedSalvageHold',
    SpecializedShipHold: 'SpecializedShipHold',
    SpecializedSmallShipHold: 'SpecializedSmallShipHold',
    StructureActive: 'StructureActive',
    StructureFuel: 'StructureFuel',
    StructureInactive: 'StructureInactive',
    StructureOffline: 'StructureOffline',
    SubSystemBay: 'SubSystemBay',
    SubSystemSlot0: 'SubSystemSlot0',
    SubSystemSlot1: 'SubSystemSlot1',
    SubSystemSlot2: 'SubSystemSlot2',
    SubSystemSlot3: 'SubSystemSlot3',
    SubSystemSlot4: 'SubSystemSlot4',
    SubSystemSlot5: 'SubSystemSlot5',
    SubSystemSlot6: 'SubSystemSlot6',
    SubSystemSlot7: 'SubSystemSlot7',
    Unlocked: 'Unlocked',
    Wallet: 'Wallet',
    Wardrobe: 'Wardrobe'
} as const;

export type GetCorporationsCorporationIdBlueprints200OkLocationFlagEnum = typeof GetCorporationsCorporationIdBlueprints200OkLocationFlagEnum[keyof typeof GetCorporationsCorporationIdBlueprints200OkLocationFlagEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdContacts200Ok {
    /**
     * contact_id integer
     */
    'contact_id': number;
    /**
     * contact_type string
     */
    'contact_type': GetCorporationsCorporationIdContacts200OkContactTypeEnum;
    /**
     * Whether this contact is being watched
     */
    'is_watched'?: boolean;
    /**
     * label_ids array
     */
    'label_ids'?: Array<number>;
    /**
     * Standing of the contact
     */
    'standing': number;
}

export const GetCorporationsCorporationIdContacts200OkContactTypeEnum = {
    Character: 'character',
    Corporation: 'corporation',
    Alliance: 'alliance',
    Faction: 'faction'
} as const;

export type GetCorporationsCorporationIdContacts200OkContactTypeEnum = typeof GetCorporationsCorporationIdContacts200OkContactTypeEnum[keyof typeof GetCorporationsCorporationIdContacts200OkContactTypeEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdContactsLabels200Ok {
    /**
     * label_id integer
     */
    'label_id': number;
    /**
     * label_name string
     */
    'label_name': string;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdContainersLogs200Ok {
    /**
     * action string
     */
    'action': GetCorporationsCorporationIdContainersLogs200OkActionEnum;
    /**
     * ID of the character who performed the action.
     */
    'character_id': number;
    /**
     * ID of the container
     */
    'container_id': number;
    /**
     * Type ID of the container
     */
    'container_type_id': number;
    /**
     * location_flag string
     */
    'location_flag': GetCorporationsCorporationIdContainersLogs200OkLocationFlagEnum;
    /**
     * location_id integer
     */
    'location_id': number;
    /**
     * Timestamp when this log was created
     */
    'logged_at': string;
    /**
     * new_config_bitmask integer
     */
    'new_config_bitmask'?: number;
    /**
     * old_config_bitmask integer
     */
    'old_config_bitmask'?: number;
    /**
     * Type of password set if action is of type SetPassword or EnterPassword
     */
    'password_type'?: GetCorporationsCorporationIdContainersLogs200OkPasswordTypeEnum;
    /**
     * Quantity of the item being acted upon
     */
    'quantity'?: number;
    /**
     * Type ID of the item being acted upon
     */
    'type_id'?: number;
}

export const GetCorporationsCorporationIdContainersLogs200OkActionEnum = {
    Add: 'add',
    Assemble: 'assemble',
    Configure: 'configure',
    EnterPassword: 'enter_password',
    Lock: 'lock',
    Move: 'move',
    Repackage: 'repackage',
    SetName: 'set_name',
    SetPassword: 'set_password',
    Unlock: 'unlock'
} as const;

export type GetCorporationsCorporationIdContainersLogs200OkActionEnum = typeof GetCorporationsCorporationIdContainersLogs200OkActionEnum[keyof typeof GetCorporationsCorporationIdContainersLogs200OkActionEnum];
export const GetCorporationsCorporationIdContainersLogs200OkLocationFlagEnum = {
    AssetSafety: 'AssetSafety',
    AutoFit: 'AutoFit',
    Bonus: 'Bonus',
    Booster: 'Booster',
    BoosterBay: 'BoosterBay',
    Capsule: 'Capsule',
    CapsuleerDeliveries: 'CapsuleerDeliveries',
    Cargo: 'Cargo',
    CorpDeliveries: 'CorpDeliveries',
    CorpSag1: 'CorpSAG1',
    CorpSag2: 'CorpSAG2',
    CorpSag3: 'CorpSAG3',
    CorpSag4: 'CorpSAG4',
    CorpSag5: 'CorpSAG5',
    CorpSag6: 'CorpSAG6',
    CorpSag7: 'CorpSAG7',
    CorporationGoalDeliveries: 'CorporationGoalDeliveries',
    CrateLoot: 'CrateLoot',
    Deliveries: 'Deliveries',
    DroneBay: 'DroneBay',
    DustBattle: 'DustBattle',
    DustDatabank: 'DustDatabank',
    FighterBay: 'FighterBay',
    FighterTube0: 'FighterTube0',
    FighterTube1: 'FighterTube1',
    FighterTube2: 'FighterTube2',
    FighterTube3: 'FighterTube3',
    FighterTube4: 'FighterTube4',
    FleetHangar: 'FleetHangar',
    FrigateEscapeBay: 'FrigateEscapeBay',
    Hangar: 'Hangar',
    HangarAll: 'HangarAll',
    HiSlot0: 'HiSlot0',
    HiSlot1: 'HiSlot1',
    HiSlot2: 'HiSlot2',
    HiSlot3: 'HiSlot3',
    HiSlot4: 'HiSlot4',
    HiSlot5: 'HiSlot5',
    HiSlot6: 'HiSlot6',
    HiSlot7: 'HiSlot7',
    HiddenModifiers: 'HiddenModifiers',
    Implant: 'Implant',
    Impounded: 'Impounded',
    InfrastructureHangar: 'InfrastructureHangar',
    JunkyardReprocessed: 'JunkyardReprocessed',
    JunkyardTrashed: 'JunkyardTrashed',
    LoSlot0: 'LoSlot0',
    LoSlot1: 'LoSlot1',
    LoSlot2: 'LoSlot2',
    LoSlot3: 'LoSlot3',
    LoSlot4: 'LoSlot4',
    LoSlot5: 'LoSlot5',
    LoSlot6: 'LoSlot6',
    LoSlot7: 'LoSlot7',
    Locked: 'Locked',
    MedSlot0: 'MedSlot0',
    MedSlot1: 'MedSlot1',
    MedSlot2: 'MedSlot2',
    MedSlot3: 'MedSlot3',
    MedSlot4: 'MedSlot4',
    MedSlot5: 'MedSlot5',
    MedSlot6: 'MedSlot6',
    MedSlot7: 'MedSlot7',
    MobileDepotHold: 'MobileDepotHold',
    MoonMaterialBay: 'MoonMaterialBay',
    OfficeFolder: 'OfficeFolder',
    Pilot: 'Pilot',
    PlanetSurface: 'PlanetSurface',
    QuafeBay: 'QuafeBay',
    QuantumCoreRoom: 'QuantumCoreRoom',
    Reward: 'Reward',
    RigSlot0: 'RigSlot0',
    RigSlot1: 'RigSlot1',
    RigSlot2: 'RigSlot2',
    RigSlot3: 'RigSlot3',
    RigSlot4: 'RigSlot4',
    RigSlot5: 'RigSlot5',
    RigSlot6: 'RigSlot6',
    RigSlot7: 'RigSlot7',
    SecondaryStorage: 'SecondaryStorage',
    ServiceSlot0: 'ServiceSlot0',
    ServiceSlot1: 'ServiceSlot1',
    ServiceSlot2: 'ServiceSlot2',
    ServiceSlot3: 'ServiceSlot3',
    ServiceSlot4: 'ServiceSlot4',
    ServiceSlot5: 'ServiceSlot5',
    ServiceSlot6: 'ServiceSlot6',
    ServiceSlot7: 'ServiceSlot7',
    ShipHangar: 'ShipHangar',
    ShipOffline: 'ShipOffline',
    Skill: 'Skill',
    SkillInTraining: 'SkillInTraining',
    SpecializedAmmoHold: 'SpecializedAmmoHold',
    SpecializedAsteroidHold: 'SpecializedAsteroidHold',
    SpecializedCommandCenterHold: 'SpecializedCommandCenterHold',
    SpecializedFuelBay: 'SpecializedFuelBay',
    SpecializedGasHold: 'SpecializedGasHold',
    SpecializedIceHold: 'SpecializedIceHold',
    SpecializedIndustrialShipHold: 'SpecializedIndustrialShipHold',
    SpecializedLargeShipHold: 'SpecializedLargeShipHold',
    SpecializedMaterialBay: 'SpecializedMaterialBay',
    SpecializedMediumShipHold: 'SpecializedMediumShipHold',
    SpecializedMineralHold: 'SpecializedMineralHold',
    SpecializedOreHold: 'SpecializedOreHold',
    SpecializedPlanetaryCommoditiesHold: 'SpecializedPlanetaryCommoditiesHold',
    SpecializedSalvageHold: 'SpecializedSalvageHold',
    SpecializedShipHold: 'SpecializedShipHold',
    SpecializedSmallShipHold: 'SpecializedSmallShipHold',
    StructureActive: 'StructureActive',
    StructureFuel: 'StructureFuel',
    StructureInactive: 'StructureInactive',
    StructureOffline: 'StructureOffline',
    SubSystemBay: 'SubSystemBay',
    SubSystemSlot0: 'SubSystemSlot0',
    SubSystemSlot1: 'SubSystemSlot1',
    SubSystemSlot2: 'SubSystemSlot2',
    SubSystemSlot3: 'SubSystemSlot3',
    SubSystemSlot4: 'SubSystemSlot4',
    SubSystemSlot5: 'SubSystemSlot5',
    SubSystemSlot6: 'SubSystemSlot6',
    SubSystemSlot7: 'SubSystemSlot7',
    Unlocked: 'Unlocked',
    Wallet: 'Wallet',
    Wardrobe: 'Wardrobe'
} as const;

export type GetCorporationsCorporationIdContainersLogs200OkLocationFlagEnum = typeof GetCorporationsCorporationIdContainersLogs200OkLocationFlagEnum[keyof typeof GetCorporationsCorporationIdContainersLogs200OkLocationFlagEnum];
export const GetCorporationsCorporationIdContainersLogs200OkPasswordTypeEnum = {
    Config: 'config',
    General: 'general'
} as const;

export type GetCorporationsCorporationIdContainersLogs200OkPasswordTypeEnum = typeof GetCorporationsCorporationIdContainersLogs200OkPasswordTypeEnum[keyof typeof GetCorporationsCorporationIdContainersLogs200OkPasswordTypeEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdContracts200Ok {
    /**
     * Who will accept the contract
     */
    'acceptor_id': number;
    /**
     * ID to whom the contract is assigned, can be corporation or character ID
     */
    'assignee_id': number;
    /**
     * To whom the contract is available
     */
    'availability': GetCorporationsCorporationIdContracts200OkAvailabilityEnum;
    /**
     * Buyout price (for Auctions only)
     */
    'buyout'?: number;
    /**
     * Collateral price (for Couriers only)
     */
    'collateral'?: number;
    /**
     * contract_id integer
     */
    'contract_id': number;
    /**
     * Date of confirmation of contract
     */
    'date_accepted'?: string;
    /**
     * Date of completed of contract
     */
    'date_completed'?: string;
    /**
     * Expiration date of the contract
     */
    'date_expired': string;
    /**
     * Сreation date of the contract
     */
    'date_issued': string;
    /**
     * Number of days to perform the contract
     */
    'days_to_complete'?: number;
    /**
     * End location ID (for Couriers contract)
     */
    'end_location_id'?: number;
    /**
     * true if the contract was issued on behalf of the issuer\'s corporation
     */
    'for_corporation': boolean;
    /**
     * Character\'s corporation ID for the issuer
     */
    'issuer_corporation_id': number;
    /**
     * Character ID for the issuer
     */
    'issuer_id': number;
    /**
     * Price of contract (for ItemsExchange and Auctions)
     */
    'price'?: number;
    /**
     * Remuneration for contract (for Couriers only)
     */
    'reward'?: number;
    /**
     * Start location ID (for Couriers contract)
     */
    'start_location_id'?: number;
    /**
     * Status of the the contract
     */
    'status': GetCorporationsCorporationIdContracts200OkStatusEnum;
    /**
     * Title of the contract
     */
    'title'?: string;
    /**
     * Type of the contract
     */
    'type': GetCorporationsCorporationIdContracts200OkTypeEnum;
    /**
     * Volume of items in the contract
     */
    'volume'?: number;
}

export const GetCorporationsCorporationIdContracts200OkAvailabilityEnum = {
    Public: 'public',
    Personal: 'personal',
    Corporation: 'corporation',
    Alliance: 'alliance'
} as const;

export type GetCorporationsCorporationIdContracts200OkAvailabilityEnum = typeof GetCorporationsCorporationIdContracts200OkAvailabilityEnum[keyof typeof GetCorporationsCorporationIdContracts200OkAvailabilityEnum];
export const GetCorporationsCorporationIdContracts200OkStatusEnum = {
    Outstanding: 'outstanding',
    InProgress: 'in_progress',
    FinishedIssuer: 'finished_issuer',
    FinishedContractor: 'finished_contractor',
    Finished: 'finished',
    Cancelled: 'cancelled',
    Rejected: 'rejected',
    Failed: 'failed',
    Deleted: 'deleted',
    Reversed: 'reversed'
} as const;

export type GetCorporationsCorporationIdContracts200OkStatusEnum = typeof GetCorporationsCorporationIdContracts200OkStatusEnum[keyof typeof GetCorporationsCorporationIdContracts200OkStatusEnum];
export const GetCorporationsCorporationIdContracts200OkTypeEnum = {
    Unknown: 'unknown',
    ItemExchange: 'item_exchange',
    Auction: 'auction',
    Courier: 'courier',
    Loan: 'loan'
} as const;

export type GetCorporationsCorporationIdContracts200OkTypeEnum = typeof GetCorporationsCorporationIdContracts200OkTypeEnum[keyof typeof GetCorporationsCorporationIdContracts200OkTypeEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdContractsContractIdBids200Ok {
    /**
     * The amount bid, in ISK
     */
    'amount': number;
    /**
     * Unique ID for the bid
     */
    'bid_id': number;
    /**
     * Character ID of the bidder
     */
    'bidder_id': number;
    /**
     * Datetime when the bid was placed
     */
    'date_bid': string;
}
/**
 * Not found
 */
export interface GetCorporationsCorporationIdContractsContractIdBidsNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdContractsContractIdItems200Ok {
    /**
     * true if the contract issuer has submitted this item with the contract, false if the isser is asking for this item in the contract
     */
    'is_included': boolean;
    /**
     * is_singleton boolean
     */
    'is_singleton': boolean;
    /**
     * Number of items in the stack
     */
    'quantity': number;
    /**
     * -1 indicates that the item is a singleton (non-stackable). If the item happens to be a Blueprint, -1 is an Original and -2 is a Blueprint Copy
     */
    'raw_quantity'?: number;
    /**
     * Unique ID for the item
     */
    'record_id': number;
    /**
     * Type ID for item
     */
    'type_id': number;
}
/**
 * Error 520
 */
export interface GetCorporationsCorporationIdContractsContractIdItemsError520 {
    /**
     * Error 520 message
     */
    'error'?: string;
}
/**
 * Not found
 */
export interface GetCorporationsCorporationIdContractsContractIdItemsNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdCustomsOffices200Ok {
    /**
     * Only present if alliance access is allowed
     */
    'alliance_tax_rate'?: number;
    /**
     * standing_level and any standing related tax rate only present when this is true
     */
    'allow_access_with_standings': boolean;
    /**
     * allow_alliance_access boolean
     */
    'allow_alliance_access': boolean;
    /**
     * bad_standing_tax_rate number
     */
    'bad_standing_tax_rate'?: number;
    /**
     * corporation_tax_rate number
     */
    'corporation_tax_rate'?: number;
    /**
     * Tax rate for entities with excellent level of standing, only present if this level is allowed, same for all other standing related tax rates
     */
    'excellent_standing_tax_rate'?: number;
    /**
     * good_standing_tax_rate number
     */
    'good_standing_tax_rate'?: number;
    /**
     * neutral_standing_tax_rate number
     */
    'neutral_standing_tax_rate'?: number;
    /**
     * unique ID of this customs office
     */
    'office_id': number;
    /**
     * reinforce_exit_end integer
     */
    'reinforce_exit_end': number;
    /**
     * Together with reinforce_exit_end, marks a 2-hour period where this customs office could exit reinforcement mode during the day after initial attack
     */
    'reinforce_exit_start': number;
    /**
     * Access is allowed only for entities with this level of standing or better
     */
    'standing_level'?: GetCorporationsCorporationIdCustomsOffices200OkStandingLevelEnum;
    /**
     * ID of the solar system this customs office is located in
     */
    'system_id': number;
    /**
     * terrible_standing_tax_rate number
     */
    'terrible_standing_tax_rate'?: number;
}

export const GetCorporationsCorporationIdCustomsOffices200OkStandingLevelEnum = {
    Bad: 'bad',
    Excellent: 'excellent',
    Good: 'good',
    Neutral: 'neutral',
    Terrible: 'terrible'
} as const;

export type GetCorporationsCorporationIdCustomsOffices200OkStandingLevelEnum = typeof GetCorporationsCorporationIdCustomsOffices200OkStandingLevelEnum[keyof typeof GetCorporationsCorporationIdCustomsOffices200OkStandingLevelEnum];

/**
 * hangar object
 */
export interface GetCorporationsCorporationIdDivisionsHangarHangar {
    /**
     * division integer
     */
    'division'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdDivisionsOk {
    /**
     * hangar array
     */
    'hangar'?: Array<GetCorporationsCorporationIdDivisionsHangarHangar>;
    /**
     * wallet array
     */
    'wallet'?: Array<GetCorporationsCorporationIdDivisionsWalletWallet>;
}
/**
 * wallet object
 */
export interface GetCorporationsCorporationIdDivisionsWalletWallet {
    /**
     * division integer
     */
    'division'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdFacilities200Ok {
    /**
     * facility_id integer
     */
    'facility_id': number;
    /**
     * system_id integer
     */
    'system_id': number;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * Summary of kills done by the given corporation against enemy factions
 */
export interface GetCorporationsCorporationIdFwStatsKills {
    /**
     * Last week\'s total number of kills by members of the given corporation against enemy factions
     */
    'last_week': number;
    /**
     * Total number of kills by members of the given corporation against enemy factions since the corporation enlisted
     */
    'total': number;
    /**
     * Yesterday\'s total number of kills by members of the given corporation against enemy factions
     */
    'yesterday': number;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdFwStatsOk {
    /**
     * The enlistment date of the given corporation into faction warfare. Will not be included if corporation is not enlisted in faction warfare
     */
    'enlisted_on'?: string;
    /**
     * The faction the given corporation is enlisted to fight for. Will not be included if corporation is not enlisted in faction warfare
     */
    'faction_id'?: number;
    'kills': GetCorporationsCorporationIdFwStatsKills;
    /**
     * How many pilots the enlisted corporation has. Will not be included if corporation is not enlisted in faction warfare
     */
    'pilots'?: number;
    'victory_points': GetCorporationsCorporationIdFwStatsVictoryPoints;
}
/**
 * Summary of victory points gained by the given corporation for the enlisted faction
 */
export interface GetCorporationsCorporationIdFwStatsVictoryPoints {
    /**
     * Last week\'s victory points gained by members of the given corporation
     */
    'last_week': number;
    /**
     * Total victory points gained since the given corporation enlisted
     */
    'total': number;
    /**
     * Yesterday\'s victory points gained by members of the given corporation
     */
    'yesterday': number;
}
/**
 * No image server for this datasource
 */
export interface GetCorporationsCorporationIdIconsNotFound {
    /**
     * error message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdIconsOk {
    /**
     * px128x128 string
     */
    'px128x128'?: string;
    /**
     * px256x256 string
     */
    'px256x256'?: string;
    /**
     * px64x64 string
     */
    'px64x64'?: string;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdIndustryJobs200Ok {
    /**
     * Job activity ID
     */
    'activity_id': number;
    /**
     * blueprint_id integer
     */
    'blueprint_id': number;
    /**
     * Location ID of the location from which the blueprint was installed. Normally a station ID, but can also be an asset (e.g. container) or corporation facility
     */
    'blueprint_location_id': number;
    /**
     * blueprint_type_id integer
     */
    'blueprint_type_id': number;
    /**
     * ID of the character which completed this job
     */
    'completed_character_id'?: number;
    /**
     * Date and time when this job was completed
     */
    'completed_date'?: string;
    /**
     * The sume of job installation fee and industry facility tax
     */
    'cost'?: number;
    /**
     * Job duration in seconds
     */
    'duration': number;
    /**
     * Date and time when this job finished
     */
    'end_date': string;
    /**
     * ID of the facility where this job is running
     */
    'facility_id': number;
    /**
     * ID of the character which installed this job
     */
    'installer_id': number;
    /**
     * Unique job ID
     */
    'job_id': number;
    /**
     * Number of runs blueprint is licensed for
     */
    'licensed_runs'?: number;
    /**
     * ID of the location for the industry facility
     */
    'location_id': number;
    /**
     * Location ID of the location to which the output of the job will be delivered. Normally a station ID, but can also be a corporation facility
     */
    'output_location_id': number;
    /**
     * Date and time when this job was paused (i.e. time when the facility where this job was installed went offline)
     */
    'pause_date'?: string;
    /**
     * Chance of success for invention
     */
    'probability'?: number;
    /**
     * Type ID of product (manufactured, copied or invented)
     */
    'product_type_id'?: number;
    /**
     * Number of runs for a manufacturing job, or number of copies to make for a blueprint copy
     */
    'runs': number;
    /**
     * Date and time when this job started
     */
    'start_date': string;
    /**
     * status string
     */
    'status': GetCorporationsCorporationIdIndustryJobs200OkStatusEnum;
    /**
     * Number of successful runs for this job. Equal to runs unless this is an invention job
     */
    'successful_runs'?: number;
}

export const GetCorporationsCorporationIdIndustryJobs200OkStatusEnum = {
    Active: 'active',
    Cancelled: 'cancelled',
    Delivered: 'delivered',
    Paused: 'paused',
    Ready: 'ready',
    Reverted: 'reverted'
} as const;

export type GetCorporationsCorporationIdIndustryJobs200OkStatusEnum = typeof GetCorporationsCorporationIdIndustryJobs200OkStatusEnum[keyof typeof GetCorporationsCorporationIdIndustryJobs200OkStatusEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdKillmailsRecent200Ok {
    /**
     * A hash of this killmail
     */
    'killmail_hash': string;
    /**
     * ID of this killmail
     */
    'killmail_id': number;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdMedals200Ok {
    /**
     * created_at string
     */
    'created_at': string;
    /**
     * ID of the character who created this medal
     */
    'creator_id': number;
    /**
     * description string
     */
    'description': string;
    /**
     * medal_id integer
     */
    'medal_id': number;
    /**
     * title string
     */
    'title': string;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdMedalsIssued200Ok {
    /**
     * ID of the character who was rewarded this medal
     */
    'character_id': number;
    /**
     * issued_at string
     */
    'issued_at': string;
    /**
     * ID of the character who issued the medal
     */
    'issuer_id': number;
    /**
     * medal_id integer
     */
    'medal_id': number;
    /**
     * reason string
     */
    'reason': string;
    /**
     * status string
     */
    'status': GetCorporationsCorporationIdMedalsIssued200OkStatusEnum;
}

export const GetCorporationsCorporationIdMedalsIssued200OkStatusEnum = {
    Private: 'private',
    Public: 'public'
} as const;

export type GetCorporationsCorporationIdMedalsIssued200OkStatusEnum = typeof GetCorporationsCorporationIdMedalsIssued200OkStatusEnum[keyof typeof GetCorporationsCorporationIdMedalsIssued200OkStatusEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdMembersTitles200Ok {
    /**
     * character_id integer
     */
    'character_id': number;
    /**
     * A list of title_id
     */
    'titles': Array<number>;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdMembertracking200Ok {
    /**
     * base_id integer
     */
    'base_id'?: number;
    /**
     * character_id integer
     */
    'character_id': number;
    /**
     * location_id integer
     */
    'location_id'?: number;
    /**
     * logoff_date string
     */
    'logoff_date'?: string;
    /**
     * logon_date string
     */
    'logon_date'?: string;
    /**
     * ship_type_id integer
     */
    'ship_type_id'?: number;
    /**
     * start_date string
     */
    'start_date'?: string;
}
/**
 * Not found
 */
export interface GetCorporationsCorporationIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdOk {
    /**
     * ID of the alliance that corporation is a member of, if any
     */
    'alliance_id'?: number;
    /**
     * ceo_id integer
     */
    'ceo_id': number;
    /**
     * creator_id integer
     */
    'creator_id': number;
    /**
     * date_founded string
     */
    'date_founded'?: string;
    /**
     * description string
     */
    'description'?: string;
    /**
     * faction_id integer
     */
    'faction_id'?: number;
    /**
     * home_station_id integer
     */
    'home_station_id'?: number;
    /**
     * member_count integer
     */
    'member_count': number;
    /**
     * the full name of the corporation
     */
    'name': string;
    /**
     * shares integer
     */
    'shares'?: number;
    /**
     * tax_rate number
     */
    'tax_rate': number;
    /**
     * the short name of the corporation
     */
    'ticker': string;
    /**
     * url string
     */
    'url'?: string;
    /**
     * war_eligible boolean
     */
    'war_eligible'?: boolean;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdOrders200Ok {
    /**
     * Number of days for which order is valid (starting from the issued date). An order expires at time issued + duration
     */
    'duration': number;
    /**
     * For buy orders, the amount of ISK in escrow
     */
    'escrow'?: number;
    /**
     * True if the order is a bid (buy) order
     */
    'is_buy_order'?: boolean;
    /**
     * Date and time when this order was issued
     */
    'issued': string;
    /**
     * The character who issued this order
     */
    'issued_by': number;
    /**
     * ID of the location where order was placed
     */
    'location_id': number;
    /**
     * For buy orders, the minimum quantity that will be accepted in a matching sell order
     */
    'min_volume'?: number;
    /**
     * Unique order ID
     */
    'order_id': number;
    /**
     * Cost per unit for this order
     */
    'price': number;
    /**
     * Valid order range, numbers are ranges in jumps
     */
    'range': GetCorporationsCorporationIdOrders200OkRangeEnum;
    /**
     * ID of the region where order was placed
     */
    'region_id': number;
    /**
     * The type ID of the item transacted in this order
     */
    'type_id': number;
    /**
     * Quantity of items still required or offered
     */
    'volume_remain': number;
    /**
     * Quantity of items required or offered at time order was placed
     */
    'volume_total': number;
    /**
     * The corporation wallet division used for this order.
     */
    'wallet_division': number;
}

export const GetCorporationsCorporationIdOrders200OkRangeEnum = {
    _1: '1',
    _10: '10',
    _2: '2',
    _20: '20',
    _3: '3',
    _30: '30',
    _4: '4',
    _40: '40',
    _5: '5',
    Region: 'region',
    Solarsystem: 'solarsystem',
    Station: 'station'
} as const;

export type GetCorporationsCorporationIdOrders200OkRangeEnum = typeof GetCorporationsCorporationIdOrders200OkRangeEnum[keyof typeof GetCorporationsCorporationIdOrders200OkRangeEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdOrdersHistory200Ok {
    /**
     * Number of days the order was valid for (starting from the issued date). An order expires at time issued + duration
     */
    'duration': number;
    /**
     * For buy orders, the amount of ISK in escrow
     */
    'escrow'?: number;
    /**
     * True if the order is a bid (buy) order
     */
    'is_buy_order'?: boolean;
    /**
     * Date and time when this order was issued
     */
    'issued': string;
    /**
     * The character who issued this order
     */
    'issued_by'?: number;
    /**
     * ID of the location where order was placed
     */
    'location_id': number;
    /**
     * For buy orders, the minimum quantity that will be accepted in a matching sell order
     */
    'min_volume'?: number;
    /**
     * Unique order ID
     */
    'order_id': number;
    /**
     * Cost per unit for this order
     */
    'price': number;
    /**
     * Valid order range, numbers are ranges in jumps
     */
    'range': GetCorporationsCorporationIdOrdersHistory200OkRangeEnum;
    /**
     * ID of the region where order was placed
     */
    'region_id': number;
    /**
     * Current order state
     */
    'state': GetCorporationsCorporationIdOrdersHistory200OkStateEnum;
    /**
     * The type ID of the item transacted in this order
     */
    'type_id': number;
    /**
     * Quantity of items still required or offered
     */
    'volume_remain': number;
    /**
     * Quantity of items required or offered at time order was placed
     */
    'volume_total': number;
    /**
     * The corporation wallet division used for this order
     */
    'wallet_division': number;
}

export const GetCorporationsCorporationIdOrdersHistory200OkRangeEnum = {
    _1: '1',
    _10: '10',
    _2: '2',
    _20: '20',
    _3: '3',
    _30: '30',
    _4: '4',
    _40: '40',
    _5: '5',
    Region: 'region',
    Solarsystem: 'solarsystem',
    Station: 'station'
} as const;

export type GetCorporationsCorporationIdOrdersHistory200OkRangeEnum = typeof GetCorporationsCorporationIdOrdersHistory200OkRangeEnum[keyof typeof GetCorporationsCorporationIdOrdersHistory200OkRangeEnum];
export const GetCorporationsCorporationIdOrdersHistory200OkStateEnum = {
    Cancelled: 'cancelled',
    Expired: 'expired'
} as const;

export type GetCorporationsCorporationIdOrdersHistory200OkStateEnum = typeof GetCorporationsCorporationIdOrdersHistory200OkStateEnum[keyof typeof GetCorporationsCorporationIdOrdersHistory200OkStateEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdRoles200Ok {
    /**
     * character_id integer
     */
    'character_id': number;
    /**
     * grantable_roles array
     */
    'grantable_roles'?: Array<GetCorporationsCorporationIdRoles200OkGrantableRolesEnum>;
    /**
     * grantable_roles_at_base array
     */
    'grantable_roles_at_base'?: Array<GetCorporationsCorporationIdRoles200OkGrantableRolesAtBaseEnum>;
    /**
     * grantable_roles_at_hq array
     */
    'grantable_roles_at_hq'?: Array<GetCorporationsCorporationIdRoles200OkGrantableRolesAtHqEnum>;
    /**
     * grantable_roles_at_other array
     */
    'grantable_roles_at_other'?: Array<GetCorporationsCorporationIdRoles200OkGrantableRolesAtOtherEnum>;
    /**
     * roles array
     */
    'roles'?: Array<GetCorporationsCorporationIdRoles200OkRolesEnum>;
    /**
     * roles_at_base array
     */
    'roles_at_base'?: Array<GetCorporationsCorporationIdRoles200OkRolesAtBaseEnum>;
    /**
     * roles_at_hq array
     */
    'roles_at_hq'?: Array<GetCorporationsCorporationIdRoles200OkRolesAtHqEnum>;
    /**
     * roles_at_other array
     */
    'roles_at_other'?: Array<GetCorporationsCorporationIdRoles200OkRolesAtOtherEnum>;
}

export const GetCorporationsCorporationIdRoles200OkGrantableRolesEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdRoles200OkGrantableRolesEnum = typeof GetCorporationsCorporationIdRoles200OkGrantableRolesEnum[keyof typeof GetCorporationsCorporationIdRoles200OkGrantableRolesEnum];
export const GetCorporationsCorporationIdRoles200OkGrantableRolesAtBaseEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdRoles200OkGrantableRolesAtBaseEnum = typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtBaseEnum[keyof typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtBaseEnum];
export const GetCorporationsCorporationIdRoles200OkGrantableRolesAtHqEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdRoles200OkGrantableRolesAtHqEnum = typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtHqEnum[keyof typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtHqEnum];
export const GetCorporationsCorporationIdRoles200OkGrantableRolesAtOtherEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdRoles200OkGrantableRolesAtOtherEnum = typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtOtherEnum[keyof typeof GetCorporationsCorporationIdRoles200OkGrantableRolesAtOtherEnum];
export const GetCorporationsCorporationIdRoles200OkRolesEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdRoles200OkRolesEnum = typeof GetCorporationsCorporationIdRoles200OkRolesEnum[keyof typeof GetCorporationsCorporationIdRoles200OkRolesEnum];
export const GetCorporationsCorporationIdRoles200OkRolesAtBaseEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdRoles200OkRolesAtBaseEnum = typeof GetCorporationsCorporationIdRoles200OkRolesAtBaseEnum[keyof typeof GetCorporationsCorporationIdRoles200OkRolesAtBaseEnum];
export const GetCorporationsCorporationIdRoles200OkRolesAtHqEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdRoles200OkRolesAtHqEnum = typeof GetCorporationsCorporationIdRoles200OkRolesAtHqEnum[keyof typeof GetCorporationsCorporationIdRoles200OkRolesAtHqEnum];
export const GetCorporationsCorporationIdRoles200OkRolesAtOtherEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdRoles200OkRolesAtOtherEnum = typeof GetCorporationsCorporationIdRoles200OkRolesAtOtherEnum[keyof typeof GetCorporationsCorporationIdRoles200OkRolesAtOtherEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdRolesHistory200Ok {
    /**
     * changed_at string
     */
    'changed_at': string;
    /**
     * The character whose roles are changed
     */
    'character_id': number;
    /**
     * ID of the character who issued this change
     */
    'issuer_id': number;
    /**
     * new_roles array
     */
    'new_roles': Array<GetCorporationsCorporationIdRolesHistory200OkNewRolesEnum>;
    /**
     * old_roles array
     */
    'old_roles': Array<GetCorporationsCorporationIdRolesHistory200OkOldRolesEnum>;
    /**
     * role_type string
     */
    'role_type': GetCorporationsCorporationIdRolesHistory200OkRoleTypeEnum;
}

export const GetCorporationsCorporationIdRolesHistory200OkNewRolesEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdRolesHistory200OkNewRolesEnum = typeof GetCorporationsCorporationIdRolesHistory200OkNewRolesEnum[keyof typeof GetCorporationsCorporationIdRolesHistory200OkNewRolesEnum];
export const GetCorporationsCorporationIdRolesHistory200OkOldRolesEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdRolesHistory200OkOldRolesEnum = typeof GetCorporationsCorporationIdRolesHistory200OkOldRolesEnum[keyof typeof GetCorporationsCorporationIdRolesHistory200OkOldRolesEnum];
export const GetCorporationsCorporationIdRolesHistory200OkRoleTypeEnum = {
    GrantableRoles: 'grantable_roles',
    GrantableRolesAtBase: 'grantable_roles_at_base',
    GrantableRolesAtHq: 'grantable_roles_at_hq',
    GrantableRolesAtOther: 'grantable_roles_at_other',
    Roles: 'roles',
    RolesAtBase: 'roles_at_base',
    RolesAtHq: 'roles_at_hq',
    RolesAtOther: 'roles_at_other'
} as const;

export type GetCorporationsCorporationIdRolesHistory200OkRoleTypeEnum = typeof GetCorporationsCorporationIdRolesHistory200OkRoleTypeEnum[keyof typeof GetCorporationsCorporationIdRolesHistory200OkRoleTypeEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdShareholders200Ok {
    /**
     * share_count integer
     */
    'share_count': number;
    /**
     * shareholder_id integer
     */
    'shareholder_id': number;
    /**
     * shareholder_type string
     */
    'shareholder_type': GetCorporationsCorporationIdShareholders200OkShareholderTypeEnum;
}

export const GetCorporationsCorporationIdShareholders200OkShareholderTypeEnum = {
    Character: 'character',
    Corporation: 'corporation'
} as const;

export type GetCorporationsCorporationIdShareholders200OkShareholderTypeEnum = typeof GetCorporationsCorporationIdShareholders200OkShareholderTypeEnum[keyof typeof GetCorporationsCorporationIdShareholders200OkShareholderTypeEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdStandings200Ok {
    /**
     * from_id integer
     */
    'from_id': number;
    /**
     * from_type string
     */
    'from_type': GetCorporationsCorporationIdStandings200OkFromTypeEnum;
    /**
     * standing number
     */
    'standing': number;
}

export const GetCorporationsCorporationIdStandings200OkFromTypeEnum = {
    Agent: 'agent',
    NpcCorp: 'npc_corp',
    Faction: 'faction'
} as const;

export type GetCorporationsCorporationIdStandings200OkFromTypeEnum = typeof GetCorporationsCorporationIdStandings200OkFromTypeEnum[keyof typeof GetCorporationsCorporationIdStandings200OkFromTypeEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdStarbases200Ok {
    /**
     * The moon this starbase (POS) is anchored on, unanchored POSes do not have this information
     */
    'moon_id'?: number;
    /**
     * When the POS onlined, for starbases (POSes) in online state
     */
    'onlined_since'?: string;
    /**
     * When the POS will be out of reinforcement, for starbases (POSes) in reinforced state
     */
    'reinforced_until'?: string;
    /**
     * Unique ID for this starbase (POS)
     */
    'starbase_id': number;
    /**
     * state string
     */
    'state'?: GetCorporationsCorporationIdStarbases200OkStateEnum;
    /**
     * The solar system this starbase (POS) is in, unanchored POSes have this information
     */
    'system_id': number;
    /**
     * Starbase (POS) type
     */
    'type_id': number;
    /**
     * When the POS started unanchoring, for starbases (POSes) in unanchoring state
     */
    'unanchor_at'?: string;
}

export const GetCorporationsCorporationIdStarbases200OkStateEnum = {
    Offline: 'offline',
    Online: 'online',
    Onlining: 'onlining',
    Reinforced: 'reinforced',
    Unanchoring: 'unanchoring'
} as const;

export type GetCorporationsCorporationIdStarbases200OkStateEnum = typeof GetCorporationsCorporationIdStarbases200OkStateEnum[keyof typeof GetCorporationsCorporationIdStarbases200OkStateEnum];

/**
 * fuel object
 */
export interface GetCorporationsCorporationIdStarbasesStarbaseIdFuel {
    /**
     * quantity integer
     */
    'quantity': number;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdStarbasesStarbaseIdOk {
    /**
     * allow_alliance_members boolean
     */
    'allow_alliance_members': boolean;
    /**
     * allow_corporation_members boolean
     */
    'allow_corporation_members': boolean;
    /**
     * Who can anchor starbase (POS) and its structures
     */
    'anchor': GetCorporationsCorporationIdStarbasesStarbaseIdOkAnchorEnum;
    /**
     * attack_if_at_war boolean
     */
    'attack_if_at_war': boolean;
    /**
     * attack_if_other_security_status_dropping boolean
     */
    'attack_if_other_security_status_dropping': boolean;
    /**
     * Starbase (POS) will attack if target\'s security standing is lower than this value
     */
    'attack_security_status_threshold'?: number;
    /**
     * Starbase (POS) will attack if target\'s standing is lower than this value
     */
    'attack_standing_threshold'?: number;
    /**
     * Who can take fuel blocks out of the starbase (POS)\'s fuel bay
     */
    'fuel_bay_take': GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayTakeEnum;
    /**
     * Who can view the starbase (POS)\'s fule bay. Characters either need to have required role or belong to the starbase (POS) owner\'s corporation or alliance, as described by the enum, all other access settings follows the same scheme
     */
    'fuel_bay_view': GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayViewEnum;
    /**
     * Fuel blocks and other things that will be consumed when operating a starbase (POS)
     */
    'fuels'?: Array<GetCorporationsCorporationIdStarbasesStarbaseIdFuel>;
    /**
     * Who can offline starbase (POS) and its structures
     */
    'offline': GetCorporationsCorporationIdStarbasesStarbaseIdOkOfflineEnum;
    /**
     * Who can online starbase (POS) and its structures
     */
    'online': GetCorporationsCorporationIdStarbasesStarbaseIdOkOnlineEnum;
    /**
     * Who can unanchor starbase (POS) and its structures
     */
    'unanchor': GetCorporationsCorporationIdStarbasesStarbaseIdOkUnanchorEnum;
    /**
     * True if the starbase (POS) is using alliance standings, otherwise using corporation\'s
     */
    'use_alliance_standings': boolean;
}

export const GetCorporationsCorporationIdStarbasesStarbaseIdOkAnchorEnum = {
    AllianceMember: 'alliance_member',
    ConfigStarbaseEquipmentRole: 'config_starbase_equipment_role',
    CorporationMember: 'corporation_member',
    StarbaseFuelTechnicianRole: 'starbase_fuel_technician_role'
} as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkAnchorEnum = typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkAnchorEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkAnchorEnum];
export const GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayTakeEnum = {
    AllianceMember: 'alliance_member',
    ConfigStarbaseEquipmentRole: 'config_starbase_equipment_role',
    CorporationMember: 'corporation_member',
    StarbaseFuelTechnicianRole: 'starbase_fuel_technician_role'
} as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayTakeEnum = typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayTakeEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayTakeEnum];
export const GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayViewEnum = {
    AllianceMember: 'alliance_member',
    ConfigStarbaseEquipmentRole: 'config_starbase_equipment_role',
    CorporationMember: 'corporation_member',
    StarbaseFuelTechnicianRole: 'starbase_fuel_technician_role'
} as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayViewEnum = typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayViewEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkFuelBayViewEnum];
export const GetCorporationsCorporationIdStarbasesStarbaseIdOkOfflineEnum = {
    AllianceMember: 'alliance_member',
    ConfigStarbaseEquipmentRole: 'config_starbase_equipment_role',
    CorporationMember: 'corporation_member',
    StarbaseFuelTechnicianRole: 'starbase_fuel_technician_role'
} as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkOfflineEnum = typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkOfflineEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkOfflineEnum];
export const GetCorporationsCorporationIdStarbasesStarbaseIdOkOnlineEnum = {
    AllianceMember: 'alliance_member',
    ConfigStarbaseEquipmentRole: 'config_starbase_equipment_role',
    CorporationMember: 'corporation_member',
    StarbaseFuelTechnicianRole: 'starbase_fuel_technician_role'
} as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkOnlineEnum = typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkOnlineEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkOnlineEnum];
export const GetCorporationsCorporationIdStarbasesStarbaseIdOkUnanchorEnum = {
    AllianceMember: 'alliance_member',
    ConfigStarbaseEquipmentRole: 'config_starbase_equipment_role',
    CorporationMember: 'corporation_member',
    StarbaseFuelTechnicianRole: 'starbase_fuel_technician_role'
} as const;

export type GetCorporationsCorporationIdStarbasesStarbaseIdOkUnanchorEnum = typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkUnanchorEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdOkUnanchorEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdStructures200Ok {
    /**
     * ID of the corporation that owns the structure
     */
    'corporation_id': number;
    /**
     * Date on which the structure will run out of fuel
     */
    'fuel_expires'?: string;
    /**
     * The structure name
     */
    'name'?: string;
    /**
     * The date and time when the structure\'s newly requested reinforcement times (e.g. next_reinforce_hour and next_reinforce_day) will take effect
     */
    'next_reinforce_apply'?: string;
    /**
     * The requested change to reinforce_hour that will take effect at the time shown by next_reinforce_apply
     */
    'next_reinforce_hour'?: number;
    /**
     * The id of the ACL profile for this citadel
     */
    'profile_id': number;
    /**
     * The hour of day that determines the four hour window when the structure will randomly exit its reinforcement periods and become vulnerable to attack against its armor and/or hull. The structure will become vulnerable at a random time that is +/- 2 hours centered on the value of this property
     */
    'reinforce_hour'?: number;
    /**
     * Contains a list of service upgrades, and their state
     */
    'services'?: Array<GetCorporationsCorporationIdStructuresService>;
    /**
     * state string
     */
    'state': GetCorporationsCorporationIdStructures200OkStateEnum;
    /**
     * Date at which the structure will move to it\'s next state
     */
    'state_timer_end'?: string;
    /**
     * Date at which the structure entered it\'s current state
     */
    'state_timer_start'?: string;
    /**
     * The Item ID of the structure
     */
    'structure_id': number;
    /**
     * The solar system the structure is in
     */
    'system_id': number;
    /**
     * The type id of the structure
     */
    'type_id': number;
    /**
     * Date at which the structure will unanchor
     */
    'unanchors_at'?: string;
}

export const GetCorporationsCorporationIdStructures200OkStateEnum = {
    AnchorVulnerable: 'anchor_vulnerable',
    Anchoring: 'anchoring',
    ArmorReinforce: 'armor_reinforce',
    ArmorVulnerable: 'armor_vulnerable',
    DeployVulnerable: 'deploy_vulnerable',
    FittingInvulnerable: 'fitting_invulnerable',
    HullReinforce: 'hull_reinforce',
    HullVulnerable: 'hull_vulnerable',
    OnlineDeprecated: 'online_deprecated',
    OnliningVulnerable: 'onlining_vulnerable',
    ShieldVulnerable: 'shield_vulnerable',
    Unanchored: 'unanchored',
    Unknown: 'unknown'
} as const;

export type GetCorporationsCorporationIdStructures200OkStateEnum = typeof GetCorporationsCorporationIdStructures200OkStateEnum[keyof typeof GetCorporationsCorporationIdStructures200OkStateEnum];

/**
 * service object
 */
export interface GetCorporationsCorporationIdStructuresService {
    /**
     * name string
     */
    'name': string;
    /**
     * state string
     */
    'state': GetCorporationsCorporationIdStructuresServiceStateEnum;
}

export const GetCorporationsCorporationIdStructuresServiceStateEnum = {
    Online: 'online',
    Offline: 'offline',
    Cleanup: 'cleanup'
} as const;

export type GetCorporationsCorporationIdStructuresServiceStateEnum = typeof GetCorporationsCorporationIdStructuresServiceStateEnum[keyof typeof GetCorporationsCorporationIdStructuresServiceStateEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdTitles200Ok {
    /**
     * grantable_roles array
     */
    'grantable_roles'?: Array<GetCorporationsCorporationIdTitles200OkGrantableRolesEnum>;
    /**
     * grantable_roles_at_base array
     */
    'grantable_roles_at_base'?: Array<GetCorporationsCorporationIdTitles200OkGrantableRolesAtBaseEnum>;
    /**
     * grantable_roles_at_hq array
     */
    'grantable_roles_at_hq'?: Array<GetCorporationsCorporationIdTitles200OkGrantableRolesAtHqEnum>;
    /**
     * grantable_roles_at_other array
     */
    'grantable_roles_at_other'?: Array<GetCorporationsCorporationIdTitles200OkGrantableRolesAtOtherEnum>;
    /**
     * name string
     */
    'name'?: string;
    /**
     * roles array
     */
    'roles'?: Array<GetCorporationsCorporationIdTitles200OkRolesEnum>;
    /**
     * roles_at_base array
     */
    'roles_at_base'?: Array<GetCorporationsCorporationIdTitles200OkRolesAtBaseEnum>;
    /**
     * roles_at_hq array
     */
    'roles_at_hq'?: Array<GetCorporationsCorporationIdTitles200OkRolesAtHqEnum>;
    /**
     * roles_at_other array
     */
    'roles_at_other'?: Array<GetCorporationsCorporationIdTitles200OkRolesAtOtherEnum>;
    /**
     * title_id integer
     */
    'title_id'?: number;
}

export const GetCorporationsCorporationIdTitles200OkGrantableRolesEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdTitles200OkGrantableRolesEnum = typeof GetCorporationsCorporationIdTitles200OkGrantableRolesEnum[keyof typeof GetCorporationsCorporationIdTitles200OkGrantableRolesEnum];
export const GetCorporationsCorporationIdTitles200OkGrantableRolesAtBaseEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdTitles200OkGrantableRolesAtBaseEnum = typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtBaseEnum[keyof typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtBaseEnum];
export const GetCorporationsCorporationIdTitles200OkGrantableRolesAtHqEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdTitles200OkGrantableRolesAtHqEnum = typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtHqEnum[keyof typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtHqEnum];
export const GetCorporationsCorporationIdTitles200OkGrantableRolesAtOtherEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdTitles200OkGrantableRolesAtOtherEnum = typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtOtherEnum[keyof typeof GetCorporationsCorporationIdTitles200OkGrantableRolesAtOtherEnum];
export const GetCorporationsCorporationIdTitles200OkRolesEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdTitles200OkRolesEnum = typeof GetCorporationsCorporationIdTitles200OkRolesEnum[keyof typeof GetCorporationsCorporationIdTitles200OkRolesEnum];
export const GetCorporationsCorporationIdTitles200OkRolesAtBaseEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdTitles200OkRolesAtBaseEnum = typeof GetCorporationsCorporationIdTitles200OkRolesAtBaseEnum[keyof typeof GetCorporationsCorporationIdTitles200OkRolesAtBaseEnum];
export const GetCorporationsCorporationIdTitles200OkRolesAtHqEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdTitles200OkRolesAtHqEnum = typeof GetCorporationsCorporationIdTitles200OkRolesAtHqEnum[keyof typeof GetCorporationsCorporationIdTitles200OkRolesAtHqEnum];
export const GetCorporationsCorporationIdTitles200OkRolesAtOtherEnum = {
    AccountTake1: 'Account_Take_1',
    AccountTake2: 'Account_Take_2',
    AccountTake3: 'Account_Take_3',
    AccountTake4: 'Account_Take_4',
    AccountTake5: 'Account_Take_5',
    AccountTake6: 'Account_Take_6',
    AccountTake7: 'Account_Take_7',
    Accountant: 'Accountant',
    Auditor: 'Auditor',
    BrandManager: 'Brand_Manager',
    CommunicationsOfficer: 'Communications_Officer',
    ConfigEquipment: 'Config_Equipment',
    ConfigStarbaseEquipment: 'Config_Starbase_Equipment',
    ContainerTake1: 'Container_Take_1',
    ContainerTake2: 'Container_Take_2',
    ContainerTake3: 'Container_Take_3',
    ContainerTake4: 'Container_Take_4',
    ContainerTake5: 'Container_Take_5',
    ContainerTake6: 'Container_Take_6',
    ContainerTake7: 'Container_Take_7',
    ContractManager: 'Contract_Manager',
    DeliveriesContainerTake: 'Deliveries_Container_Take',
    DeliveriesQuery: 'Deliveries_Query',
    DeliveriesTake: 'Deliveries_Take',
    Diplomat: 'Diplomat',
    Director: 'Director',
    FactoryManager: 'Factory_Manager',
    FittingManager: 'Fitting_Manager',
    HangarQuery1: 'Hangar_Query_1',
    HangarQuery2: 'Hangar_Query_2',
    HangarQuery3: 'Hangar_Query_3',
    HangarQuery4: 'Hangar_Query_4',
    HangarQuery5: 'Hangar_Query_5',
    HangarQuery6: 'Hangar_Query_6',
    HangarQuery7: 'Hangar_Query_7',
    HangarTake1: 'Hangar_Take_1',
    HangarTake2: 'Hangar_Take_2',
    HangarTake3: 'Hangar_Take_3',
    HangarTake4: 'Hangar_Take_4',
    HangarTake5: 'Hangar_Take_5',
    HangarTake6: 'Hangar_Take_6',
    HangarTake7: 'Hangar_Take_7',
    JuniorAccountant: 'Junior_Accountant',
    PersonnelManager: 'Personnel_Manager',
    ProjectManager: 'Project_Manager',
    RentFactoryFacility: 'Rent_Factory_Facility',
    RentOffice: 'Rent_Office',
    RentResearchFacility: 'Rent_Research_Facility',
    SecurityOfficer: 'Security_Officer',
    SkillPlanManager: 'Skill_Plan_Manager',
    StarbaseDefenseOperator: 'Starbase_Defense_Operator',
    StarbaseFuelTechnician: 'Starbase_Fuel_Technician',
    StationManager: 'Station_Manager',
    Trader: 'Trader'
} as const;

export type GetCorporationsCorporationIdTitles200OkRolesAtOtherEnum = typeof GetCorporationsCorporationIdTitles200OkRolesAtOtherEnum[keyof typeof GetCorporationsCorporationIdTitles200OkRolesAtOtherEnum];

/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdWallets200Ok {
    /**
     * balance number
     */
    'balance': number;
    /**
     * division integer
     */
    'division': number;
}
/**
 * 200 ok object
 */
export interface GetCorporationsCorporationIdWalletsDivisionJournal200Ok {
    /**
     * The amount of ISK given or taken from the wallet as a result of the given transaction. Positive when ISK is deposited into the wallet and negative when ISK is withdrawn
     */
    'amount'?: number;
    /**
     * Wallet balance after transaction occurred
     */
    'balance'?: number;
    /**
     * An ID that gives extra context to the particular transaction. Because of legacy reasons the context is completely different per ref_type and means different things. It is also possible to not have a context_id
     */
    'context_id'?: number;
    /**
     * The type of the given context_id if present
     */
    'context_id_type'?: GetCorporationsCorporationIdWalletsDivisionJournal200OkContextIdTypeEnum;
    /**
     * Date and time of transaction
     */
    'date': string;
    /**
     * The reason for the transaction, mirrors what is seen in the client
     */
    'description': string;
    /**
     * The id of the first party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
     */
    'first_party_id'?: number;
    /**
     * Unique journal reference ID
     */
    'id': number;
    /**
     * The user stated reason for the transaction. Only applies to some ref_types
     */
    'reason'?: string;
    /**
     * \"The transaction type for the given. transaction. Different transaction types will populate different attributes. Note: If you have an existing XML API application that is using ref_types, you will need to know which string ESI ref_type maps to which integer. You can look at the following file to see string->int mappings: https://github.com/ccpgames/eve-glue/blob/master/eve_glue/wallet_journal_ref.py\"
     */
    'ref_type': GetCorporationsCorporationIdWalletsDivisionJournal200OkRefTypeEnum;
    /**
     * The id of the second party involved in the transaction. This attribute has no consistency and is different or non existant for particular ref_types. The description attribute will help make sense of what this attribute means. For more info about the given ID it can be dropped into the /universe/names/ ESI route to determine its type and name
     */
    'second_party_id'?: number;
    /**
     * Tax amount received. Only applies to tax related transactions
     */
    'tax'?: number;
    /**
     * The corporation ID receiving any tax paid. Only applies to tax related transactions
     */
    'tax_receiver_id'?: number;
}

export const GetCorporationsCorporationIdWalletsDivisionJournal200OkContextIdTypeEnum = {
    StructureId: 'structure_id',
    StationId: 'station_id',
    MarketTransactionId: 'market_transaction_id',
    CharacterId: 'character_id',
    CorporationId: 'corporation_id',
    AllianceId: 'alliance_id',
    EveSystem: 'eve_system',
    IndustryJobId: 'industry_job_id',
    ContractId: 'contract_id',
    PlanetId: 'planet_id',
    SystemId: 'system_id',
    TypeId: 'type_id'
} as const;

export type GetCorporationsCorporationIdWalletsDivisionJournal200OkContextIdTypeEnum = typeof GetCorporationsCorporationIdWalletsDivisionJournal200OkContextIdTypeEnum[keyof typeof GetCorporationsCorporationIdWalletsDivisionJournal200OkContextIdTypeEnum];
export const GetCorporationsCorporationIdWalletsDivisionJournal200OkRefTypeEnum = {
    AccelerationGateFee: 'acceleration_gate_fee',
    AdvertisementListingFee: 'advertisement_listing_fee',
    AgentDonation: 'agent_donation',
    AgentLocationServices: 'agent_location_services',
    AgentMiscellaneous: 'agent_miscellaneous',
    AgentMissionCollateralPaid: 'agent_mission_collateral_paid',
    AgentMissionCollateralRefunded: 'agent_mission_collateral_refunded',
    AgentMissionReward: 'agent_mission_reward',
    AgentMissionRewardCorporationTax: 'agent_mission_reward_corporation_tax',
    AgentMissionTimeBonusReward: 'agent_mission_time_bonus_reward',
    AgentMissionTimeBonusRewardCorporationTax: 'agent_mission_time_bonus_reward_corporation_tax',
    AgentSecurityServices: 'agent_security_services',
    AgentServicesRendered: 'agent_services_rendered',
    AgentsPreward: 'agents_preward',
    AirCareerProgramReward: 'air_career_program_reward',
    AllianceMaintainanceFee: 'alliance_maintainance_fee',
    AllianceRegistrationFee: 'alliance_registration_fee',
    AllignmentBasedGateToll: 'allignment_based_gate_toll',
    AssetSafetyRecoveryTax: 'asset_safety_recovery_tax',
    Bounty: 'bounty',
    BountyPrize: 'bounty_prize',
    BountyPrizeCorporationTax: 'bounty_prize_corporation_tax',
    BountyPrizes: 'bounty_prizes',
    BountyReimbursement: 'bounty_reimbursement',
    BountySurcharge: 'bounty_surcharge',
    BrokersFee: 'brokers_fee',
    CloneActivation: 'clone_activation',
    CloneTransfer: 'clone_transfer',
    ContrabandFine: 'contraband_fine',
    ContractAuctionBid: 'contract_auction_bid',
    ContractAuctionBidCorp: 'contract_auction_bid_corp',
    ContractAuctionBidRefund: 'contract_auction_bid_refund',
    ContractAuctionSold: 'contract_auction_sold',
    ContractBrokersFee: 'contract_brokers_fee',
    ContractBrokersFeeCorp: 'contract_brokers_fee_corp',
    ContractCollateral: 'contract_collateral',
    ContractCollateralDepositedCorp: 'contract_collateral_deposited_corp',
    ContractCollateralPayout: 'contract_collateral_payout',
    ContractCollateralRefund: 'contract_collateral_refund',
    ContractDeposit: 'contract_deposit',
    ContractDepositCorp: 'contract_deposit_corp',
    ContractDepositRefund: 'contract_deposit_refund',
    ContractDepositSalesTax: 'contract_deposit_sales_tax',
    ContractPrice: 'contract_price',
    ContractPricePaymentCorp: 'contract_price_payment_corp',
    ContractReversal: 'contract_reversal',
    ContractReward: 'contract_reward',
    ContractRewardDeposited: 'contract_reward_deposited',
    ContractRewardDepositedCorp: 'contract_reward_deposited_corp',
    ContractRewardRefund: 'contract_reward_refund',
    ContractSalesTax: 'contract_sales_tax',
    Copying: 'copying',
    CorporateRewardPayout: 'corporate_reward_payout',
    CorporateRewardTax: 'corporate_reward_tax',
    CorporationAccountWithdrawal: 'corporation_account_withdrawal',
    CorporationBulkPayment: 'corporation_bulk_payment',
    CorporationDividendPayment: 'corporation_dividend_payment',
    CorporationLiquidation: 'corporation_liquidation',
    CorporationLogoChangeCost: 'corporation_logo_change_cost',
    CorporationPayment: 'corporation_payment',
    CorporationRegistrationFee: 'corporation_registration_fee',
    CosmeticMarketComponentItemPurchase: 'cosmetic_market_component_item_purchase',
    CosmeticMarketSkinPurchase: 'cosmetic_market_skin_purchase',
    CosmeticMarketSkinSale: 'cosmetic_market_skin_sale',
    CosmeticMarketSkinSaleBrokerFee: 'cosmetic_market_skin_sale_broker_fee',
    CosmeticMarketSkinSaleTax: 'cosmetic_market_skin_sale_tax',
    CosmeticMarketSkinTransaction: 'cosmetic_market_skin_transaction',
    CourierMissionEscrow: 'courier_mission_escrow',
    Cspa: 'cspa',
    Cspaofflinerefund: 'cspaofflinerefund',
    DailyChallengeReward: 'daily_challenge_reward',
    DailyGoalPayouts: 'daily_goal_payouts',
    DailyGoalPayoutsTax: 'daily_goal_payouts_tax',
    DatacoreFee: 'datacore_fee',
    DnaModificationFee: 'dna_modification_fee',
    DockingFee: 'docking_fee',
    DuelWagerEscrow: 'duel_wager_escrow',
    DuelWagerPayment: 'duel_wager_payment',
    DuelWagerRefund: 'duel_wager_refund',
    EssEscrowTransfer: 'ess_escrow_transfer',
    ExternalTradeDelivery: 'external_trade_delivery',
    ExternalTradeFreeze: 'external_trade_freeze',
    ExternalTradeThaw: 'external_trade_thaw',
    FactorySlotRentalFee: 'factory_slot_rental_fee',
    FluxPayout: 'flux_payout',
    FluxTax: 'flux_tax',
    FluxTicketRepayment: 'flux_ticket_repayment',
    FluxTicketSale: 'flux_ticket_sale',
    FreelanceJobsBroadcastingFee: 'freelance_jobs_broadcasting_fee',
    FreelanceJobsDurationFee: 'freelance_jobs_duration_fee',
    FreelanceJobsEscrowRefund: 'freelance_jobs_escrow_refund',
    FreelanceJobsReward: 'freelance_jobs_reward',
    FreelanceJobsRewardCorporationTax: 'freelance_jobs_reward_corporation_tax',
    FreelanceJobsRewardEscrow: 'freelance_jobs_reward_escrow',
    GmCashTransfer: 'gm_cash_transfer',
    GmPlexFeeRefund: 'gm_plex_fee_refund',
    IndustryJobTax: 'industry_job_tax',
    InfrastructureHubMaintenance: 'infrastructure_hub_maintenance',
    Inheritance: 'inheritance',
    Insurance: 'insurance',
    InsurgencyCorruptionContributionReward: 'insurgency_corruption_contribution_reward',
    InsurgencySuppressionContributionReward: 'insurgency_suppression_contribution_reward',
    ItemTraderPayment: 'item_trader_payment',
    JumpCloneActivationFee: 'jump_clone_activation_fee',
    JumpCloneInstallationFee: 'jump_clone_installation_fee',
    KillRightFee: 'kill_right_fee',
    LpStore: 'lp_store',
    Manufacturing: 'manufacturing',
    MarketEscrow: 'market_escrow',
    MarketFinePaid: 'market_fine_paid',
    MarketProviderTax: 'market_provider_tax',
    MarketTransaction: 'market_transaction',
    MedalCreation: 'medal_creation',
    MedalIssued: 'medal_issued',
    MilestoneRewardPayment: 'milestone_reward_payment',
    MissionCompletion: 'mission_completion',
    MissionCost: 'mission_cost',
    MissionExpiration: 'mission_expiration',
    MissionReward: 'mission_reward',
    OfficeRentalFee: 'office_rental_fee',
    OperationBonus: 'operation_bonus',
    OpportunityReward: 'opportunity_reward',
    PlanetaryConstruction: 'planetary_construction',
    PlanetaryExportTax: 'planetary_export_tax',
    PlanetaryImportTax: 'planetary_import_tax',
    PlayerDonation: 'player_donation',
    PlayerTrading: 'player_trading',
    ProjectDiscoveryReward: 'project_discovery_reward',
    ProjectDiscoveryTax: 'project_discovery_tax',
    ProjectPayouts: 'project_payouts',
    Reaction: 'reaction',
    RedeemedIskToken: 'redeemed_isk_token',
    ReleaseOfImpoundedProperty: 'release_of_impounded_property',
    RepairBill: 'repair_bill',
    ReprocessingTax: 'reprocessing_tax',
    ResearchingMaterialProductivity: 'researching_material_productivity',
    ResearchingTechnology: 'researching_technology',
    ResearchingTimeProductivity: 'researching_time_productivity',
    ResourceWarsReward: 'resource_wars_reward',
    ReverseEngineering: 'reverse_engineering',
    SeasonChallengeReward: 'season_challenge_reward',
    SecurityProcessingFee: 'security_processing_fee',
    Shares: 'shares',
    SkillPurchase: 'skill_purchase',
    SkyhookClaimFee: 'skyhook_claim_fee',
    SovereignityBill: 'sovereignity_bill',
    StorePurchase: 'store_purchase',
    StorePurchaseRefund: 'store_purchase_refund',
    StructureGateJump: 'structure_gate_jump',
    TransactionTax: 'transaction_tax',
    UnderConstruction: 'under_construction',
    UpkeepAdjustmentFee: 'upkeep_adjustment_fee',
    WarAllyContract: 'war_ally_contract',
    WarFee: 'war_fee',
    WarFeeSurrender: 'war_fee_surrender'
} as const;

export type GetCorporationsCorporationIdWalletsDivisionJournal200OkRefTypeEnum = typeof GetCorporationsCorporationIdWalletsDivisionJournal200OkRefTypeEnum[keyof typeof GetCorporationsCorporationIdWalletsDivisionJournal200OkRefTypeEnum];

/**
 * wallet transaction
 */
export interface GetCorporationsCorporationIdWalletsDivisionTransactions200Ok {
    /**
     * client_id integer
     */
    'client_id': number;
    /**
     * Date and time of transaction
     */
    'date': string;
    /**
     * is_buy boolean
     */
    'is_buy': boolean;
    /**
     * -1 if there is no corresponding wallet journal entry
     */
    'journal_ref_id': number;
    /**
     * location_id integer
     */
    'location_id': number;
    /**
     * quantity integer
     */
    'quantity': number;
    /**
     * Unique transaction ID
     */
    'transaction_id': number;
    /**
     * type_id integer
     */
    'type_id': number;
    /**
     * Amount paid per unit
     */
    'unit_price': number;
}
/**
 * Not found
 */
export interface GetDogmaAttributesAttributeIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetDogmaAttributesAttributeIdOk {
    /**
     * attribute_id integer
     */
    'attribute_id': number;
    /**
     * default_value number
     */
    'default_value'?: number;
    /**
     * description string
     */
    'description'?: string;
    /**
     * display_name string
     */
    'display_name'?: string;
    /**
     * high_is_good boolean
     */
    'high_is_good'?: boolean;
    /**
     * icon_id integer
     */
    'icon_id'?: number;
    /**
     * name string
     */
    'name'?: string;
    /**
     * published boolean
     */
    'published'?: boolean;
    /**
     * stackable boolean
     */
    'stackable'?: boolean;
    /**
     * unit_id integer
     */
    'unit_id'?: number;
}
/**
 * dogma_attribute object
 */
export interface GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute {
    /**
     * attribute_id integer
     */
    'attribute_id': number;
    /**
     * value number
     */
    'value': number;
}
/**
 * dogma_effect object
 */
export interface GetDogmaDynamicItemsTypeIdItemIdDogmaEffect {
    /**
     * effect_id integer
     */
    'effect_id': number;
    /**
     * is_default boolean
     */
    'is_default': boolean;
}
/**
 * Not found
 */
export interface GetDogmaDynamicItemsTypeIdItemIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetDogmaDynamicItemsTypeIdItemIdOk {
    /**
     * The ID of the character who created the item
     */
    'created_by': number;
    /**
     * dogma_attributes array
     */
    'dogma_attributes': Array<GetDogmaDynamicItemsTypeIdItemIdDogmaAttribute>;
    /**
     * dogma_effects array
     */
    'dogma_effects': Array<GetDogmaDynamicItemsTypeIdItemIdDogmaEffect>;
    /**
     * The type ID of the mutator used to generate the dynamic item.
     */
    'mutator_type_id': number;
    /**
     * The type ID of the source item the mutator was applied to create the dynamic item.
     */
    'source_type_id': number;
}
/**
 * modifier object
 */
export interface GetDogmaEffectsEffectIdModifier {
    /**
     * domain string
     */
    'domain'?: string;
    /**
     * effect_id integer
     */
    'effect_id'?: number;
    /**
     * func string
     */
    'func': string;
    /**
     * modified_attribute_id integer
     */
    'modified_attribute_id'?: number;
    /**
     * modifying_attribute_id integer
     */
    'modifying_attribute_id'?: number;
    /**
     * operator integer
     */
    'operator'?: number;
}
/**
 * Not found
 */
export interface GetDogmaEffectsEffectIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetDogmaEffectsEffectIdOk {
    /**
     * description string
     */
    'description'?: string;
    /**
     * disallow_auto_repeat boolean
     */
    'disallow_auto_repeat'?: boolean;
    /**
     * discharge_attribute_id integer
     */
    'discharge_attribute_id'?: number;
    /**
     * display_name string
     */
    'display_name'?: string;
    /**
     * duration_attribute_id integer
     */
    'duration_attribute_id'?: number;
    /**
     * effect_category integer
     */
    'effect_category'?: number;
    /**
     * effect_id integer
     */
    'effect_id': number;
    /**
     * electronic_chance boolean
     */
    'electronic_chance'?: boolean;
    /**
     * falloff_attribute_id integer
     */
    'falloff_attribute_id'?: number;
    /**
     * icon_id integer
     */
    'icon_id'?: number;
    /**
     * is_assistance boolean
     */
    'is_assistance'?: boolean;
    /**
     * is_offensive boolean
     */
    'is_offensive'?: boolean;
    /**
     * is_warp_safe boolean
     */
    'is_warp_safe'?: boolean;
    /**
     * modifiers array
     */
    'modifiers'?: Array<GetDogmaEffectsEffectIdModifier>;
    /**
     * name string
     */
    'name'?: string;
    /**
     * post_expression integer
     */
    'post_expression'?: number;
    /**
     * pre_expression integer
     */
    'pre_expression'?: number;
    /**
     * published boolean
     */
    'published'?: boolean;
    /**
     * range_attribute_id integer
     */
    'range_attribute_id'?: number;
    /**
     * range_chance boolean
     */
    'range_chance'?: boolean;
    /**
     * tracking_speed_attribute_id integer
     */
    'tracking_speed_attribute_id'?: number;
}
/**
 * 200 ok object
 */
export interface GetFleetsFleetIdMembers200Ok {
    /**
     * character_id integer
     */
    'character_id': number;
    /**
     * join_time string
     */
    'join_time': string;
    /**
     * Member’s role in fleet
     */
    'role': GetFleetsFleetIdMembers200OkRoleEnum;
    /**
     * Localized role names
     */
    'role_name': string;
    /**
     * ship_type_id integer
     */
    'ship_type_id': number;
    /**
     * Solar system the member is located in
     */
    'solar_system_id': number;
    /**
     * ID of the squad the member is in. If not applicable, will be set to -1
     */
    'squad_id': number;
    /**
     * Station in which the member is docked in, if applicable
     */
    'station_id'?: number;
    /**
     * Whether the member take fleet warps
     */
    'takes_fleet_warp': boolean;
    /**
     * ID of the wing the member is in. If not applicable, will be set to -1
     */
    'wing_id': number;
}

export const GetFleetsFleetIdMembers200OkRoleEnum = {
    FleetCommander: 'fleet_commander',
    WingCommander: 'wing_commander',
    SquadCommander: 'squad_commander',
    SquadMember: 'squad_member'
} as const;

export type GetFleetsFleetIdMembers200OkRoleEnum = typeof GetFleetsFleetIdMembers200OkRoleEnum[keyof typeof GetFleetsFleetIdMembers200OkRoleEnum];

/**
 * Not found
 */
export interface GetFleetsFleetIdMembersNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * Not found
 */
export interface GetFleetsFleetIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetFleetsFleetIdOk {
    /**
     * Is free-move enabled
     */
    'is_free_move': boolean;
    /**
     * Does the fleet have an active fleet advertisement
     */
    'is_registered': boolean;
    /**
     * Is EVE Voice enabled
     */
    'is_voice_enabled': boolean;
    /**
     * Fleet MOTD in CCP flavoured HTML
     */
    'motd': string;
}
/**
 * 200 ok object
 */
export interface GetFleetsFleetIdWings200Ok {
    /**
     * id integer
     */
    'id': number;
    /**
     * name string
     */
    'name': string;
    /**
     * squads array
     */
    'squads': Array<GetFleetsFleetIdWingsSquad>;
}
/**
 * Not found
 */
export interface GetFleetsFleetIdWingsNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * squad object
 */
export interface GetFleetsFleetIdWingsSquad {
    /**
     * id integer
     */
    'id': number;
    /**
     * name string
     */
    'name': string;
}
/**
 * active_total object
 */
export interface GetFwLeaderboardsActiveTotalActiveTotal {
    /**
     * Amount of kills
     */
    'amount'?: number;
    /**
     * faction_id integer
     */
    'faction_id'?: number;
}
/**
 * active_total object
 */
export interface GetFwLeaderboardsActiveTotalActiveTotal1 {
    /**
     * Amount of victory points
     */
    'amount'?: number;
    /**
     * faction_id integer
     */
    'faction_id'?: number;
}
/**
 * active_total object
 */
export interface GetFwLeaderboardsCharactersActiveTotalActiveTotal {
    /**
     * Amount of kills
     */
    'amount'?: number;
    /**
     * character_id integer
     */
    'character_id'?: number;
}
/**
 * active_total object
 */
export interface GetFwLeaderboardsCharactersActiveTotalActiveTotal1 {
    /**
     * Amount of victory points
     */
    'amount'?: number;
    /**
     * character_id integer
     */
    'character_id'?: number;
}
/**
 * Top 100 rankings of pilots by number of kills from yesterday, last week and in total
 */
export interface GetFwLeaderboardsCharactersKills {
    /**
     * Top 100 ranking of pilots active in faction warfare by total kills. A pilot is considered \"active\" if they have participated in faction warfare in the past 14 days
     */
    'active_total': Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal>;
    /**
     * Top 100 ranking of pilots by kills in the past week
     */
    'last_week': Array<GetFwLeaderboardsCharactersLastWeekLastWeek>;
    /**
     * Top 100 ranking of pilots by kills in the past day
     */
    'yesterday': Array<GetFwLeaderboardsCharactersYesterdayYesterday>;
}
/**
 * last_week object
 */
export interface GetFwLeaderboardsCharactersLastWeekLastWeek {
    /**
     * Amount of kills
     */
    'amount'?: number;
    /**
     * character_id integer
     */
    'character_id'?: number;
}
/**
 * last_week object
 */
export interface GetFwLeaderboardsCharactersLastWeekLastWeek1 {
    /**
     * Amount of victory points
     */
    'amount'?: number;
    /**
     * character_id integer
     */
    'character_id'?: number;
}
/**
 * 200 ok object
 */
export interface GetFwLeaderboardsCharactersOk {
    'kills': GetFwLeaderboardsCharactersKills;
    'victory_points': GetFwLeaderboardsCharactersVictoryPoints;
}
/**
 * Top 100 rankings of pilots by victory points from yesterday, last week and in total
 */
export interface GetFwLeaderboardsCharactersVictoryPoints {
    /**
     * Top 100 ranking of pilots active in faction warfare by total victory points. A pilot is considered \"active\" if they have participated in faction warfare in the past 14 days
     */
    'active_total': Array<GetFwLeaderboardsCharactersActiveTotalActiveTotal1>;
    /**
     * Top 100 ranking of pilots by victory points in the past week
     */
    'last_week': Array<GetFwLeaderboardsCharactersLastWeekLastWeek1>;
    /**
     * Top 100 ranking of pilots by victory points in the past day
     */
    'yesterday': Array<GetFwLeaderboardsCharactersYesterdayYesterday1>;
}
/**
 * yesterday object
 */
export interface GetFwLeaderboardsCharactersYesterdayYesterday {
    /**
     * Amount of kills
     */
    'amount'?: number;
    /**
     * character_id integer
     */
    'character_id'?: number;
}
/**
 * yesterday object
 */
export interface GetFwLeaderboardsCharactersYesterdayYesterday1 {
    /**
     * Amount of victory points
     */
    'amount'?: number;
    /**
     * character_id integer
     */
    'character_id'?: number;
}
/**
 * active_total object
 */
export interface GetFwLeaderboardsCorporationsActiveTotalActiveTotal {
    /**
     * Amount of kills
     */
    'amount'?: number;
    /**
     * corporation_id integer
     */
    'corporation_id'?: number;
}
/**
 * active_total object
 */
export interface GetFwLeaderboardsCorporationsActiveTotalActiveTotal1 {
    /**
     * Amount of victory points
     */
    'amount'?: number;
    /**
     * corporation_id integer
     */
    'corporation_id'?: number;
}
/**
 * Top 10 rankings of corporations by number of kills from yesterday, last week and in total
 */
export interface GetFwLeaderboardsCorporationsKills {
    /**
     * Top 10 ranking of corporations active in faction warfare by total kills. A corporation is considered \"active\" if they have participated in faction warfare in the past 14 days
     */
    'active_total': Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal>;
    /**
     * Top 10 ranking of corporations by kills in the past week
     */
    'last_week': Array<GetFwLeaderboardsCorporationsLastWeekLastWeek>;
    /**
     * Top 10 ranking of corporations by kills in the past day
     */
    'yesterday': Array<GetFwLeaderboardsCorporationsYesterdayYesterday>;
}
/**
 * last_week object
 */
export interface GetFwLeaderboardsCorporationsLastWeekLastWeek {
    /**
     * Amount of kills
     */
    'amount'?: number;
    /**
     * corporation_id integer
     */
    'corporation_id'?: number;
}
/**
 * last_week object
 */
export interface GetFwLeaderboardsCorporationsLastWeekLastWeek1 {
    /**
     * Amount of victory points
     */
    'amount'?: number;
    /**
     * corporation_id integer
     */
    'corporation_id'?: number;
}
/**
 * 200 ok object
 */
export interface GetFwLeaderboardsCorporationsOk {
    'kills': GetFwLeaderboardsCorporationsKills;
    'victory_points': GetFwLeaderboardsCorporationsVictoryPoints;
}
/**
 * Top 10 rankings of corporations by victory points from yesterday, last week and in total
 */
export interface GetFwLeaderboardsCorporationsVictoryPoints {
    /**
     * Top 10 ranking of corporations active in faction warfare by total victory points. A corporation is considered \"active\" if they have participated in faction warfare in the past 14 days
     */
    'active_total': Array<GetFwLeaderboardsCorporationsActiveTotalActiveTotal1>;
    /**
     * Top 10 ranking of corporations by victory points in the past week
     */
    'last_week': Array<GetFwLeaderboardsCorporationsLastWeekLastWeek1>;
    /**
     * Top 10 ranking of corporations by victory points in the past day
     */
    'yesterday': Array<GetFwLeaderboardsCorporationsYesterdayYesterday1>;
}
/**
 * yesterday object
 */
export interface GetFwLeaderboardsCorporationsYesterdayYesterday {
    /**
     * Amount of kills
     */
    'amount'?: number;
    /**
     * corporation_id integer
     */
    'corporation_id'?: number;
}
/**
 * yesterday object
 */
export interface GetFwLeaderboardsCorporationsYesterdayYesterday1 {
    /**
     * Amount of victory points
     */
    'amount'?: number;
    /**
     * corporation_id integer
     */
    'corporation_id'?: number;
}
/**
 * Top 4 rankings of factions by number of kills from yesterday, last week and in total
 */
export interface GetFwLeaderboardsKills {
    /**
     * Top 4 ranking of factions active in faction warfare by total kills. A faction is considered \"active\" if they have participated in faction warfare in the past 14 days
     */
    'active_total': Array<GetFwLeaderboardsActiveTotalActiveTotal>;
    /**
     * Top 4 ranking of factions by kills in the past week
     */
    'last_week': Array<GetFwLeaderboardsLastWeekLastWeek>;
    /**
     * Top 4 ranking of factions by kills in the past day
     */
    'yesterday': Array<GetFwLeaderboardsYesterdayYesterday>;
}
/**
 * last_week object
 */
export interface GetFwLeaderboardsLastWeekLastWeek {
    /**
     * Amount of kills
     */
    'amount'?: number;
    /**
     * faction_id integer
     */
    'faction_id'?: number;
}
/**
 * last_week object
 */
export interface GetFwLeaderboardsLastWeekLastWeek1 {
    /**
     * Amount of victory points
     */
    'amount'?: number;
    /**
     * faction_id integer
     */
    'faction_id'?: number;
}
/**
 * 200 ok object
 */
export interface GetFwLeaderboardsOk {
    'kills': GetFwLeaderboardsKills;
    'victory_points': GetFwLeaderboardsVictoryPoints;
}
/**
 * Top 4 rankings of factions by victory points from yesterday, last week and in total
 */
export interface GetFwLeaderboardsVictoryPoints {
    /**
     * Top 4 ranking of factions active in faction warfare by total victory points. A faction is considered \"active\" if they have participated in faction warfare in the past 14 days
     */
    'active_total': Array<GetFwLeaderboardsActiveTotalActiveTotal1>;
    /**
     * Top 4 ranking of factions by victory points in the past week
     */
    'last_week': Array<GetFwLeaderboardsLastWeekLastWeek1>;
    /**
     * Top 4 ranking of factions by victory points in the past day
     */
    'yesterday': Array<GetFwLeaderboardsYesterdayYesterday1>;
}
/**
 * yesterday object
 */
export interface GetFwLeaderboardsYesterdayYesterday {
    /**
     * Amount of kills
     */
    'amount'?: number;
    /**
     * faction_id integer
     */
    'faction_id'?: number;
}
/**
 * yesterday object
 */
export interface GetFwLeaderboardsYesterdayYesterday1 {
    /**
     * Amount of victory points
     */
    'amount'?: number;
    /**
     * faction_id integer
     */
    'faction_id'?: number;
}
/**
 * 200 ok object
 */
export interface GetFwStats200Ok {
    /**
     * faction_id integer
     */
    'faction_id': number;
    'kills': GetFwStatsKills;
    /**
     * How many pilots fight for the given faction
     */
    'pilots': number;
    /**
     * The number of solar systems controlled by the given faction
     */
    'systems_controlled': number;
    'victory_points': GetFwStatsVictoryPoints;
}
/**
 * Summary of kills against an enemy faction for the given faction
 */
export interface GetFwStatsKills {
    /**
     * Last week\'s total number of kills against enemy factions
     */
    'last_week': number;
    /**
     * Total number of kills against enemy factions since faction warfare began
     */
    'total': number;
    /**
     * Yesterday\'s total number of kills against enemy factions
     */
    'yesterday': number;
}
/**
 * Summary of victory points gained for the given faction
 */
export interface GetFwStatsVictoryPoints {
    /**
     * Last week\'s victory points gained
     */
    'last_week': number;
    /**
     * Total victory points gained since faction warfare began
     */
    'total': number;
    /**
     * Yesterday\'s victory points gained
     */
    'yesterday': number;
}
/**
 * 200 ok object
 */
export interface GetFwSystems200Ok {
    /**
     * contested string
     */
    'contested': GetFwSystems200OkContestedEnum;
    /**
     * occupier_faction_id integer
     */
    'occupier_faction_id': number;
    /**
     * owner_faction_id integer
     */
    'owner_faction_id': number;
    /**
     * solar_system_id integer
     */
    'solar_system_id': number;
    /**
     * victory_points integer
     */
    'victory_points': number;
    /**
     * victory_points_threshold integer
     */
    'victory_points_threshold': number;
}

export const GetFwSystems200OkContestedEnum = {
    Captured: 'captured',
    Contested: 'contested',
    Uncontested: 'uncontested',
    Vulnerable: 'vulnerable'
} as const;

export type GetFwSystems200OkContestedEnum = typeof GetFwSystems200OkContestedEnum[keyof typeof GetFwSystems200OkContestedEnum];

/**
 * 200 ok object
 */
export interface GetFwWars200Ok {
    /**
     * The faction ID of the enemy faction.
     */
    'against_id': number;
    /**
     * faction_id integer
     */
    'faction_id': number;
}
/**
 * 200 ok object
 */
export interface GetIncursions200Ok {
    /**
     * The constellation id in which this incursion takes place
     */
    'constellation_id': number;
    /**
     * The attacking faction\'s id
     */
    'faction_id': number;
    /**
     * Whether the final encounter has boss or not
     */
    'has_boss': boolean;
    /**
     * A list of infested solar system ids that are a part of this incursion
     */
    'infested_solar_systems': Array<number>;
    /**
     * Influence of this incursion as a float from 0 to 1
     */
    'influence': number;
    /**
     * Staging solar system for this incursion
     */
    'staging_solar_system_id': number;
    /**
     * The state of this incursion
     */
    'state': GetIncursions200OkStateEnum;
    /**
     * The type of this incursion
     */
    'type': string;
}

export const GetIncursions200OkStateEnum = {
    Withdrawing: 'withdrawing',
    Mobilizing: 'mobilizing',
    Established: 'established'
} as const;

export type GetIncursions200OkStateEnum = typeof GetIncursions200OkStateEnum[keyof typeof GetIncursions200OkStateEnum];

/**
 * 200 ok object
 */
export interface GetIndustryFacilities200Ok {
    /**
     * ID of the facility
     */
    'facility_id': number;
    /**
     * Owner of the facility
     */
    'owner_id': number;
    /**
     * Region ID where the facility is
     */
    'region_id': number;
    /**
     * Solar system ID where the facility is
     */
    'solar_system_id': number;
    /**
     * Tax imposed by the facility
     */
    'tax'?: number;
    /**
     * Type ID of the facility
     */
    'type_id': number;
}
/**
 * 200 ok object
 */
export interface GetIndustrySystems200Ok {
    /**
     * cost_indices array
     */
    'cost_indices': Array<GetIndustrySystemsCostIndice>;
    /**
     * solar_system_id integer
     */
    'solar_system_id': number;
}
/**
 * cost_indice object
 */
export interface GetIndustrySystemsCostIndice {
    /**
     * activity string
     */
    'activity': GetIndustrySystemsCostIndiceActivityEnum;
    /**
     * cost_index number
     */
    'cost_index': number;
}

export const GetIndustrySystemsCostIndiceActivityEnum = {
    Copying: 'copying',
    Duplicating: 'duplicating',
    Invention: 'invention',
    Manufacturing: 'manufacturing',
    None: 'none',
    Reaction: 'reaction',
    ResearchingMaterialEfficiency: 'researching_material_efficiency',
    ResearchingTechnology: 'researching_technology',
    ResearchingTimeEfficiency: 'researching_time_efficiency',
    ReverseEngineering: 'reverse_engineering'
} as const;

export type GetIndustrySystemsCostIndiceActivityEnum = typeof GetIndustrySystemsCostIndiceActivityEnum[keyof typeof GetIndustrySystemsCostIndiceActivityEnum];

/**
 * 200 ok object
 */
export interface GetInsurancePrices200Ok {
    /**
     * A list of a available insurance levels for this ship type
     */
    'levels': Array<GetInsurancePricesLevel>;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * level object
 */
export interface GetInsurancePricesLevel {
    /**
     * cost number
     */
    'cost': number;
    /**
     * Localized insurance level
     */
    'name': string;
    /**
     * payout number
     */
    'payout': number;
}
/**
 * attacker object
 */
export interface GetKillmailsKillmailIdKillmailHashAttacker {
    /**
     * alliance_id integer
     */
    'alliance_id'?: number;
    /**
     * character_id integer
     */
    'character_id'?: number;
    /**
     * corporation_id integer
     */
    'corporation_id'?: number;
    /**
     * damage_done integer
     */
    'damage_done': number;
    /**
     * faction_id integer
     */
    'faction_id'?: number;
    /**
     * Was the attacker the one to achieve the final blow 
     */
    'final_blow': boolean;
    /**
     * Security status for the attacker 
     */
    'security_status': number;
    /**
     * What ship was the attacker flying 
     */
    'ship_type_id'?: number;
    /**
     * What weapon was used by the attacker for the kill 
     */
    'weapon_type_id'?: number;
}
/**
 * item object
 */
export interface GetKillmailsKillmailIdKillmailHashItem {
    /**
     * Flag for the location of the item 
     */
    'flag': number;
    /**
     * item_type_id integer
     */
    'item_type_id': number;
    /**
     * items array
     */
    'items'?: Array<GetKillmailsKillmailIdKillmailHashItemsItem>;
    /**
     * How many of the item were destroyed if any 
     */
    'quantity_destroyed'?: number;
    /**
     * How many of the item were dropped if any 
     */
    'quantity_dropped'?: number;
    /**
     * singleton integer
     */
    'singleton': number;
}
/**
 * item object
 */
export interface GetKillmailsKillmailIdKillmailHashItemsItem {
    /**
     * flag integer
     */
    'flag': number;
    /**
     * item_type_id integer
     */
    'item_type_id': number;
    /**
     * quantity_destroyed integer
     */
    'quantity_destroyed'?: number;
    /**
     * quantity_dropped integer
     */
    'quantity_dropped'?: number;
    /**
     * singleton integer
     */
    'singleton': number;
}
/**
 * 200 ok object
 */
export interface GetKillmailsKillmailIdKillmailHashOk {
    /**
     * attackers array
     */
    'attackers': Array<GetKillmailsKillmailIdKillmailHashAttacker>;
    /**
     * ID of the killmail
     */
    'killmail_id': number;
    /**
     * Time that the victim was killed and the killmail generated 
     */
    'killmail_time': string;
    /**
     * Moon if the kill took place at one
     */
    'moon_id'?: number;
    /**
     * Solar system that the kill took place in 
     */
    'solar_system_id': number;
    'victim': GetKillmailsKillmailIdKillmailHashVictim;
    /**
     * War if the killmail is generated in relation to an official war 
     */
    'war_id'?: number;
}
/**
 * Coordinates of the victim in Cartesian space relative to the Sun 
 */
export interface GetKillmailsKillmailIdKillmailHashPosition {
    /**
     * x number
     */
    'x': number;
    /**
     * y number
     */
    'y': number;
    /**
     * z number
     */
    'z': number;
}
/**
 * Unprocessable entity
 */
export interface GetKillmailsKillmailIdKillmailHashUnprocessableEntity {
    /**
     * Unprocessable entity message
     */
    'error'?: string;
}
/**
 * victim object
 */
export interface GetKillmailsKillmailIdKillmailHashVictim {
    /**
     * alliance_id integer
     */
    'alliance_id'?: number;
    /**
     * character_id integer
     */
    'character_id'?: number;
    /**
     * corporation_id integer
     */
    'corporation_id'?: number;
    /**
     * How much total damage was taken by the victim 
     */
    'damage_taken': number;
    /**
     * faction_id integer
     */
    'faction_id'?: number;
    /**
     * items array
     */
    'items'?: Array<GetKillmailsKillmailIdKillmailHashItem>;
    'position'?: GetKillmailsKillmailIdKillmailHashPosition;
    /**
     * The ship that the victim was piloting and was destroyed 
     */
    'ship_type_id': number;
}
/**
 * 200 ok object
 */
export interface GetLoyaltyStoresCorporationIdOffers200Ok {
    /**
     * Analysis kredit cost
     */
    'ak_cost'?: number;
    /**
     * isk_cost integer
     */
    'isk_cost': number;
    /**
     * lp_cost integer
     */
    'lp_cost': number;
    /**
     * offer_id integer
     */
    'offer_id': number;
    /**
     * quantity integer
     */
    'quantity': number;
    /**
     * required_items array
     */
    'required_items': Array<GetLoyaltyStoresCorporationIdOffersRequiredItem>;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * Not found
 */
export interface GetLoyaltyStoresCorporationIdOffersNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * required_item object
 */
export interface GetLoyaltyStoresCorporationIdOffersRequiredItem {
    /**
     * quantity integer
     */
    'quantity': number;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * Not found
 */
export interface GetMarketsGroupsMarketGroupIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetMarketsGroupsMarketGroupIdOk {
    /**
     * description string
     */
    'description': string;
    /**
     * market_group_id integer
     */
    'market_group_id': number;
    /**
     * name string
     */
    'name': string;
    /**
     * parent_group_id integer
     */
    'parent_group_id'?: number;
    /**
     * types array
     */
    'types': Array<number>;
}
/**
 * 200 ok object
 */
export interface GetMarketsPrices200Ok {
    /**
     * adjusted_price number
     */
    'adjusted_price'?: number;
    /**
     * average_price number
     */
    'average_price'?: number;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * 200 ok object
 */
export interface GetMarketsRegionIdHistory200Ok {
    /**
     * average number
     */
    'average': number;
    /**
     * The date of this historical statistic entry
     */
    'date': string;
    /**
     * highest number
     */
    'highest': number;
    /**
     * lowest number
     */
    'lowest': number;
    /**
     * Total number of orders happened that day
     */
    'order_count': number;
    /**
     * Total
     */
    'volume': number;
}
/**
 * Error 520
 */
export interface GetMarketsRegionIdHistoryError520 {
    /**
     * Error 520 message
     */
    'error'?: string;
}
/**
 * Not found
 */
export interface GetMarketsRegionIdHistoryNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * Unprocessable entity
 */
export interface GetMarketsRegionIdHistoryUnprocessableEntity {
    /**
     * Unprocessable entity message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetMarketsRegionIdOrders200Ok {
    /**
     * duration integer
     */
    'duration': number;
    /**
     * is_buy_order boolean
     */
    'is_buy_order': boolean;
    /**
     * issued string
     */
    'issued': string;
    /**
     * location_id integer
     */
    'location_id': number;
    /**
     * min_volume integer
     */
    'min_volume': number;
    /**
     * order_id integer
     */
    'order_id': number;
    /**
     * price number
     */
    'price': number;
    /**
     * range string
     */
    'range': GetMarketsRegionIdOrders200OkRangeEnum;
    /**
     * The solar system this order was placed
     */
    'system_id': number;
    /**
     * type_id integer
     */
    'type_id': number;
    /**
     * volume_remain integer
     */
    'volume_remain': number;
    /**
     * volume_total integer
     */
    'volume_total': number;
}

export const GetMarketsRegionIdOrders200OkRangeEnum = {
    Station: 'station',
    Region: 'region',
    Solarsystem: 'solarsystem',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _10: '10',
    _20: '20',
    _30: '30',
    _40: '40'
} as const;

export type GetMarketsRegionIdOrders200OkRangeEnum = typeof GetMarketsRegionIdOrders200OkRangeEnum[keyof typeof GetMarketsRegionIdOrders200OkRangeEnum];

/**
 * Not found
 */
export interface GetMarketsRegionIdOrdersNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * Unprocessable entity
 */
export interface GetMarketsRegionIdOrdersUnprocessableEntity {
    /**
     * Unprocessable entity message
     */
    'error'?: string;
}
/**
 * Not found
 */
export interface GetMarketsRegionIdTypesNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetMarketsStructuresStructureId200Ok {
    /**
     * duration integer
     */
    'duration': number;
    /**
     * is_buy_order boolean
     */
    'is_buy_order': boolean;
    /**
     * issued string
     */
    'issued': string;
    /**
     * location_id integer
     */
    'location_id': number;
    /**
     * min_volume integer
     */
    'min_volume': number;
    /**
     * order_id integer
     */
    'order_id': number;
    /**
     * price number
     */
    'price': number;
    /**
     * range string
     */
    'range': GetMarketsStructuresStructureId200OkRangeEnum;
    /**
     * type_id integer
     */
    'type_id': number;
    /**
     * volume_remain integer
     */
    'volume_remain': number;
    /**
     * volume_total integer
     */
    'volume_total': number;
}

export const GetMarketsStructuresStructureId200OkRangeEnum = {
    Station: 'station',
    Region: 'region',
    Solarsystem: 'solarsystem',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _10: '10',
    _20: '20',
    _30: '30',
    _40: '40'
} as const;

export type GetMarketsStructuresStructureId200OkRangeEnum = typeof GetMarketsStructuresStructureId200OkRangeEnum[keyof typeof GetMarketsStructuresStructureId200OkRangeEnum];

/**
 * Not found
 */
export interface GetRouteOriginDestinationNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetSovereigntyCampaigns200Ok {
    /**
     * Score for all attacking parties, only present in Defense Events. 
     */
    'attackers_score'?: number;
    /**
     * Unique ID for this campaign.
     */
    'campaign_id': number;
    /**
     * The constellation in which the campaign will take place. 
     */
    'constellation_id': number;
    /**
     * Defending alliance, only present in Defense Events 
     */
    'defender_id'?: number;
    /**
     * Score for the defending alliance, only present in Defense Events. 
     */
    'defender_score'?: number;
    /**
     * Type of event this campaign is for. tcu_defense, ihub_defense and station_defense are referred to as \"Defense Events\", station_freeport as \"Freeport Events\". 
     */
    'event_type': GetSovereigntyCampaigns200OkEventTypeEnum;
    /**
     * Alliance participating and their respective scores, only present in Freeport Events. 
     */
    'participants'?: Array<GetSovereigntyCampaignsParticipant>;
    /**
     * The solar system the structure is located in. 
     */
    'solar_system_id': number;
    /**
     * Time the event is scheduled to start. 
     */
    'start_time': string;
    /**
     * The structure item ID that is related to this campaign. 
     */
    'structure_id': number;
}

export const GetSovereigntyCampaigns200OkEventTypeEnum = {
    TcuDefense: 'tcu_defense',
    IhubDefense: 'ihub_defense',
    StationDefense: 'station_defense',
    StationFreeport: 'station_freeport'
} as const;

export type GetSovereigntyCampaigns200OkEventTypeEnum = typeof GetSovereigntyCampaigns200OkEventTypeEnum[keyof typeof GetSovereigntyCampaigns200OkEventTypeEnum];

/**
 * participant object
 */
export interface GetSovereigntyCampaignsParticipant {
    /**
     * alliance_id integer
     */
    'alliance_id': number;
    /**
     * score number
     */
    'score': number;
}
/**
 * 200 ok object
 */
export interface GetSovereigntyMap200Ok {
    /**
     * alliance_id integer
     */
    'alliance_id'?: number;
    /**
     * corporation_id integer
     */
    'corporation_id'?: number;
    /**
     * faction_id integer
     */
    'faction_id'?: number;
    /**
     * system_id integer
     */
    'system_id': number;
}
/**
 * 200 ok object
 */
export interface GetSovereigntyStructures200Ok {
    /**
     * The alliance that owns the structure. 
     */
    'alliance_id': number;
    /**
     * Solar system in which the structure is located. 
     */
    'solar_system_id': number;
    /**
     * Unique item ID for this structure.
     */
    'structure_id': number;
    /**
     * A reference to the type of structure this is. 
     */
    'structure_type_id': number;
    /**
     * The occupancy level for the next or current vulnerability window. This takes into account all development indexes and capital system bonuses. Also known as Activity Defense Multiplier from in the client. It increases the time that attackers must spend using their entosis links on the structure. 
     */
    'vulnerability_occupancy_level'?: number;
    /**
     * The time at which the next or current vulnerability window ends. At the end of a vulnerability window the next window is recalculated and locked in along with the vulnerabilityOccupancyLevel. If the structure is not in 100% entosis control of the defender, it will go in to \'overtime\' and stay vulnerable for as long as that situation persists. Only once the defenders have 100% entosis control and has the vulnerableEndTime passed does the vulnerability interval expire and a new one is calculated. 
     */
    'vulnerable_end_time'?: string;
    /**
     * The next time at which the structure will become vulnerable. Or the start time of the current window if current time is between this and vulnerableEndTime. 
     */
    'vulnerable_start_time'?: string;
}
/**
 * 200 ok object
 */
export interface GetStatusOk {
    /**
     * Current online player count
     */
    'players': number;
    /**
     * Running version as string
     */
    'server_version': string;
    /**
     * Server start timestamp
     */
    'start_time': string;
    /**
     * If the server is in VIP mode
     */
    'vip'?: boolean;
}
/**
 * 200 ok object
 */
export interface GetUniverseAncestries200Ok {
    /**
     * The bloodline associated with this ancestry
     */
    'bloodline_id': number;
    /**
     * description string
     */
    'description': string;
    /**
     * icon_id integer
     */
    'icon_id'?: number;
    /**
     * id integer
     */
    'id': number;
    /**
     * name string
     */
    'name': string;
    /**
     * short_description string
     */
    'short_description'?: string;
}
/**
 * Not found
 */
export interface GetUniverseAsteroidBeltsAsteroidBeltIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseAsteroidBeltsAsteroidBeltIdOk {
    /**
     * name string
     */
    'name': string;
    'position': GetUniverseAsteroidBeltsAsteroidBeltIdPosition;
    /**
     * The solar system this asteroid belt is in
     */
    'system_id': number;
}
/**
 * position object
 */
export interface GetUniverseAsteroidBeltsAsteroidBeltIdPosition {
    /**
     * x number
     */
    'x': number;
    /**
     * y number
     */
    'y': number;
    /**
     * z number
     */
    'z': number;
}
/**
 * 200 ok object
 */
export interface GetUniverseBloodlines200Ok {
    /**
     * bloodline_id integer
     */
    'bloodline_id': number;
    /**
     * charisma integer
     */
    'charisma': number;
    /**
     * corporation_id integer
     */
    'corporation_id': number;
    /**
     * description string
     */
    'description': string;
    /**
     * intelligence integer
     */
    'intelligence': number;
    /**
     * memory integer
     */
    'memory': number;
    /**
     * name string
     */
    'name': string;
    /**
     * perception integer
     */
    'perception': number;
    /**
     * race_id integer
     */
    'race_id': number;
    /**
     * ship_type_id integer
     */
    'ship_type_id': number | null;
    /**
     * willpower integer
     */
    'willpower': number;
}
/**
 * Not found
 */
export interface GetUniverseCategoriesCategoryIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseCategoriesCategoryIdOk {
    /**
     * category_id integer
     */
    'category_id': number;
    /**
     * groups array
     */
    'groups': Array<number>;
    /**
     * name string
     */
    'name': string;
    /**
     * published boolean
     */
    'published': boolean;
}
/**
 * Not found
 */
export interface GetUniverseConstellationsConstellationIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseConstellationsConstellationIdOk {
    /**
     * constellation_id integer
     */
    'constellation_id': number;
    /**
     * name string
     */
    'name': string;
    'position': GetUniverseConstellationsConstellationIdPosition;
    /**
     * The region this constellation is in
     */
    'region_id': number;
    /**
     * systems array
     */
    'systems': Array<number>;
}
/**
 * position object
 */
export interface GetUniverseConstellationsConstellationIdPosition {
    /**
     * x number
     */
    'x': number;
    /**
     * y number
     */
    'y': number;
    /**
     * z number
     */
    'z': number;
}
/**
 * 200 ok object
 */
export interface GetUniverseFactions200Ok {
    /**
     * corporation_id integer
     */
    'corporation_id'?: number;
    /**
     * description string
     */
    'description': string;
    /**
     * faction_id integer
     */
    'faction_id': number;
    /**
     * is_unique boolean
     */
    'is_unique': boolean;
    /**
     * militia_corporation_id integer
     */
    'militia_corporation_id'?: number;
    /**
     * name string
     */
    'name': string;
    /**
     * size_factor number
     */
    'size_factor': number;
    /**
     * solar_system_id integer
     */
    'solar_system_id'?: number;
    /**
     * station_count integer
     */
    'station_count': number;
    /**
     * station_system_count integer
     */
    'station_system_count': number;
}
/**
 * Not found
 */
export interface GetUniverseGraphicsGraphicIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseGraphicsGraphicIdOk {
    /**
     * collision_file string
     */
    'collision_file'?: string;
    /**
     * graphic_file string
     */
    'graphic_file'?: string;
    /**
     * graphic_id integer
     */
    'graphic_id': number;
    /**
     * icon_folder string
     */
    'icon_folder'?: string;
    /**
     * sof_dna string
     */
    'sof_dna'?: string;
    /**
     * sof_fation_name string
     */
    'sof_fation_name'?: string;
    /**
     * sof_hull_name string
     */
    'sof_hull_name'?: string;
    /**
     * sof_race_name string
     */
    'sof_race_name'?: string;
}
/**
 * Not found
 */
export interface GetUniverseGroupsGroupIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseGroupsGroupIdOk {
    /**
     * category_id integer
     */
    'category_id': number;
    /**
     * group_id integer
     */
    'group_id': number;
    /**
     * name string
     */
    'name': string;
    /**
     * published boolean
     */
    'published': boolean;
    /**
     * types array
     */
    'types': Array<number>;
}
/**
 * Not found
 */
export interface GetUniverseMoonsMoonIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseMoonsMoonIdOk {
    /**
     * moon_id integer
     */
    'moon_id': number;
    /**
     * name string
     */
    'name': string;
    'position': GetUniverseMoonsMoonIdPosition;
    /**
     * The solar system this moon is in
     */
    'system_id': number;
}
/**
 * position object
 */
export interface GetUniverseMoonsMoonIdPosition {
    /**
     * x number
     */
    'x': number;
    /**
     * y number
     */
    'y': number;
    /**
     * z number
     */
    'z': number;
}
/**
 * Not found
 */
export interface GetUniversePlanetsPlanetIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniversePlanetsPlanetIdOk {
    /**
     * name string
     */
    'name': string;
    /**
     * planet_id integer
     */
    'planet_id': number;
    'position': GetUniversePlanetsPlanetIdPosition;
    /**
     * The solar system this planet is in
     */
    'system_id': number;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * position object
 */
export interface GetUniversePlanetsPlanetIdPosition {
    /**
     * x number
     */
    'x': number;
    /**
     * y number
     */
    'y': number;
    /**
     * z number
     */
    'z': number;
}
/**
 * 200 ok object
 */
export interface GetUniverseRaces200Ok {
    /**
     * The alliance generally associated with this race
     */
    'alliance_id': number;
    /**
     * description string
     */
    'description': string;
    /**
     * name string
     */
    'name': string;
    /**
     * race_id integer
     */
    'race_id': number;
}
/**
 * Not found
 */
export interface GetUniverseRegionsRegionIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseRegionsRegionIdOk {
    /**
     * constellations array
     */
    'constellations': Array<number>;
    /**
     * description string
     */
    'description'?: string;
    /**
     * name string
     */
    'name': string;
    /**
     * region_id integer
     */
    'region_id': number;
}
/**
 * Schematic not found
 */
export interface GetUniverseSchematicsSchematicIdNotFound {
    /**
     * error message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseSchematicsSchematicIdOk {
    /**
     * Time in seconds to process a run
     */
    'cycle_time': number;
    /**
     * schematic_name string
     */
    'schematic_name': string;
}
/**
 * destination object
 */
export interface GetUniverseStargatesStargateIdDestination {
    /**
     * The stargate this stargate connects to
     */
    'stargate_id': number;
    /**
     * The solar system this stargate connects to
     */
    'system_id': number;
}
/**
 * Not found
 */
export interface GetUniverseStargatesStargateIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseStargatesStargateIdOk {
    'destination': GetUniverseStargatesStargateIdDestination;
    /**
     * name string
     */
    'name': string;
    'position': GetUniverseStargatesStargateIdPosition;
    /**
     * stargate_id integer
     */
    'stargate_id': number;
    /**
     * The solar system this stargate is in
     */
    'system_id': number;
    /**
     * type_id integer
     */
    'type_id': number;
}
/**
 * position object
 */
export interface GetUniverseStargatesStargateIdPosition {
    /**
     * x number
     */
    'x': number;
    /**
     * y number
     */
    'y': number;
    /**
     * z number
     */
    'z': number;
}
/**
 * 200 ok object
 */
export interface GetUniverseStarsStarIdOk {
    /**
     * Age of star in years
     */
    'age': number;
    /**
     * luminosity number
     */
    'luminosity': number;
    /**
     * name string
     */
    'name': string;
    /**
     * radius integer
     */
    'radius': number;
    /**
     * solar_system_id integer
     */
    'solar_system_id': number;
    /**
     * spectral_class string
     */
    'spectral_class': GetUniverseStarsStarIdOkSpectralClassEnum;
    /**
     * temperature integer
     */
    'temperature': number;
    /**
     * type_id integer
     */
    'type_id': number;
}

export const GetUniverseStarsStarIdOkSpectralClassEnum = {
    K2V: 'K2 V',
    K4V: 'K4 V',
    G2V: 'G2 V',
    G8V: 'G8 V',
    M7V: 'M7 V',
    K7V: 'K7 V',
    M2V: 'M2 V',
    K5V: 'K5 V',
    M3V: 'M3 V',
    G0V: 'G0 V',
    G7V: 'G7 V',
    G3V: 'G3 V',
    F9V: 'F9 V',
    G5V: 'G5 V',
    F6V: 'F6 V',
    K8V: 'K8 V',
    K9V: 'K9 V',
    K6V: 'K6 V',
    G9V: 'G9 V',
    G6V: 'G6 V',
    G4Vi: 'G4 VI',
    G4V: 'G4 V',
    F8V: 'F8 V',
    F2V: 'F2 V',
    F1V: 'F1 V',
    K3V: 'K3 V',
    F0Vi: 'F0 VI',
    G1Vi: 'G1 VI',
    G0Vi: 'G0 VI',
    K1V: 'K1 V',
    M4V: 'M4 V',
    M1V: 'M1 V',
    M6V: 'M6 V',
    M0V: 'M0 V',
    K2Iv: 'K2 IV',
    G2Vi: 'G2 VI',
    K0V: 'K0 V',
    K5Iv: 'K5 IV',
    F5Vi: 'F5 VI',
    G6Vi: 'G6 VI',
    F6Vi: 'F6 VI',
    F2Iv: 'F2 IV',
    G3Vi: 'G3 VI',
    M8V: 'M8 V',
    F1Vi: 'F1 VI',
    K1Iv: 'K1 IV',
    F7V: 'F7 V',
    G5Vi: 'G5 VI',
    M5V: 'M5 V',
    G7Vi: 'G7 VI',
    F5V: 'F5 V',
    F4Vi: 'F4 VI',
    F8Vi: 'F8 VI',
    K3Iv: 'K3 IV',
    F4Iv: 'F4 IV',
    F0V: 'F0 V',
    G7Iv: 'G7 IV',
    G8Vi: 'G8 VI',
    F2Vi: 'F2 VI',
    F4V: 'F4 V',
    F7Vi: 'F7 VI',
    F3V: 'F3 V',
    G1V: 'G1 V',
    G9Vi: 'G9 VI',
    F3Iv: 'F3 IV',
    F9Vi: 'F9 VI',
    M9V: 'M9 V',
    K0Iv: 'K0 IV',
    F1Iv: 'F1 IV',
    G4Iv: 'G4 IV',
    F3Vi: 'F3 VI',
    K4Iv: 'K4 IV',
    G5Iv: 'G5 IV',
    G3Iv: 'G3 IV',
    G1Iv: 'G1 IV',
    K7Iv: 'K7 IV',
    G0Iv: 'G0 IV',
    K6Iv: 'K6 IV',
    K9Iv: 'K9 IV',
    G2Iv: 'G2 IV',
    F9Iv: 'F9 IV',
    F0Iv: 'F0 IV',
    K8Iv: 'K8 IV',
    G8Iv: 'G8 IV',
    F6Iv: 'F6 IV',
    F5Iv: 'F5 IV',
    A0: 'A0',
    A0Iv: 'A0IV',
    A0Iv2: 'A0IV2'
} as const;

export type GetUniverseStarsStarIdOkSpectralClassEnum = typeof GetUniverseStarsStarIdOkSpectralClassEnum[keyof typeof GetUniverseStarsStarIdOkSpectralClassEnum];

/**
 * Not found
 */
export interface GetUniverseStationsStationIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseStationsStationIdOk {
    /**
     * max_dockable_ship_volume number
     */
    'max_dockable_ship_volume': number;
    /**
     * name string
     */
    'name': string;
    /**
     * office_rental_cost number
     */
    'office_rental_cost': number;
    /**
     * ID of the corporation that controls this station
     */
    'owner'?: number;
    'position': GetUniverseStationsStationIdPosition;
    /**
     * race_id integer
     */
    'race_id'?: number;
    /**
     * reprocessing_efficiency number
     */
    'reprocessing_efficiency': number;
    /**
     * reprocessing_stations_take number
     */
    'reprocessing_stations_take': number;
    /**
     * services array
     */
    'services': Array<GetUniverseStationsStationIdOkServicesEnum>;
    /**
     * station_id integer
     */
    'station_id': number;
    /**
     * The solar system this station is in
     */
    'system_id': number;
    /**
     * type_id integer
     */
    'type_id': number;
}

export const GetUniverseStationsStationIdOkServicesEnum = {
    BountyMissions: 'bounty-missions',
    AssasinationMissions: 'assasination-missions',
    CourierMissions: 'courier-missions',
    Interbus: 'interbus',
    ReprocessingPlant: 'reprocessing-plant',
    Refinery: 'refinery',
    Market: 'market',
    BlackMarket: 'black-market',
    StockExchange: 'stock-exchange',
    Cloning: 'cloning',
    Surgery: 'surgery',
    DnaTherapy: 'dna-therapy',
    RepairFacilities: 'repair-facilities',
    Factory: 'factory',
    Labratory: 'labratory',
    Gambling: 'gambling',
    Fitting: 'fitting',
    Paintshop: 'paintshop',
    News: 'news',
    Storage: 'storage',
    Insurance: 'insurance',
    Docking: 'docking',
    OfficeRental: 'office-rental',
    JumpCloneFacility: 'jump-clone-facility',
    LoyaltyPointStore: 'loyalty-point-store',
    NavyOffices: 'navy-offices',
    SecurityOffices: 'security-offices'
} as const;

export type GetUniverseStationsStationIdOkServicesEnum = typeof GetUniverseStationsStationIdOkServicesEnum[keyof typeof GetUniverseStationsStationIdOkServicesEnum];

/**
 * position object
 */
export interface GetUniverseStationsStationIdPosition {
    /**
     * x number
     */
    'x': number;
    /**
     * y number
     */
    'y': number;
    /**
     * z number
     */
    'z': number;
}
/**
 * Not found
 */
export interface GetUniverseStructuresStructureIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseStructuresStructureIdOk {
    /**
     * The full name of the structure
     */
    'name': string;
    /**
     * The ID of the corporation who owns this particular structure
     */
    'owner_id': number;
    'position'?: GetUniverseStructuresStructureIdPosition;
    /**
     * solar_system_id integer
     */
    'solar_system_id': number;
    /**
     * type_id integer
     */
    'type_id'?: number;
}
/**
 * Coordinates of the structure in Cartesian space relative to the Sun, in metres. 
 */
export interface GetUniverseStructuresStructureIdPosition {
    /**
     * x number
     */
    'x': number;
    /**
     * y number
     */
    'y': number;
    /**
     * z number
     */
    'z': number;
}
/**
 * 200 ok object
 */
export interface GetUniverseSystemJumps200Ok {
    /**
     * ship_jumps integer
     */
    'ship_jumps': number;
    /**
     * system_id integer
     */
    'system_id': number;
}
/**
 * 200 ok object
 */
export interface GetUniverseSystemKills200Ok {
    /**
     * Number of NPC ships killed in this system
     */
    'npc_kills': number;
    /**
     * Number of pods killed in this system
     */
    'pod_kills': number;
    /**
     * Number of player ships killed in this system
     */
    'ship_kills': number;
    /**
     * system_id integer
     */
    'system_id': number;
}
/**
 * Not found
 */
export interface GetUniverseSystemsSystemIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseSystemsSystemIdOk {
    /**
     * The constellation this solar system is in
     */
    'constellation_id': number;
    /**
     * name string
     */
    'name': string;
    /**
     * planets array
     */
    'planets'?: Array<GetUniverseSystemsSystemIdPlanet>;
    'position': GetUniverseSystemsSystemIdPosition;
    /**
     * security_class string
     */
    'security_class'?: string;
    /**
     * security_status number
     */
    'security_status': number;
    /**
     * star_id integer
     */
    'star_id'?: number;
    /**
     * stargates array
     */
    'stargates'?: Array<number>;
    /**
     * stations array
     */
    'stations'?: Array<number>;
    /**
     * system_id integer
     */
    'system_id': number;
}
/**
 * planet object
 */
export interface GetUniverseSystemsSystemIdPlanet {
    /**
     * asteroid_belts array
     */
    'asteroid_belts'?: Array<number>;
    /**
     * moons array
     */
    'moons'?: Array<number>;
    /**
     * planet_id integer
     */
    'planet_id': number;
}
/**
 * position object
 */
export interface GetUniverseSystemsSystemIdPosition {
    /**
     * x number
     */
    'x': number;
    /**
     * y number
     */
    'y': number;
    /**
     * z number
     */
    'z': number;
}
/**
 * dogma_attribute object
 */
export interface GetUniverseTypesTypeIdDogmaAttribute {
    /**
     * attribute_id integer
     */
    'attribute_id': number;
    /**
     * value number
     */
    'value': number;
}
/**
 * dogma_effect object
 */
export interface GetUniverseTypesTypeIdDogmaEffect {
    /**
     * effect_id integer
     */
    'effect_id': number;
    /**
     * is_default boolean
     */
    'is_default': boolean;
}
/**
 * Not found
 */
export interface GetUniverseTypesTypeIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetUniverseTypesTypeIdOk {
    /**
     * capacity number
     */
    'capacity'?: number;
    /**
     * description string
     */
    'description': string;
    /**
     * dogma_attributes array
     */
    'dogma_attributes'?: Array<GetUniverseTypesTypeIdDogmaAttribute>;
    /**
     * dogma_effects array
     */
    'dogma_effects'?: Array<GetUniverseTypesTypeIdDogmaEffect>;
    /**
     * graphic_id integer
     */
    'graphic_id'?: number;
    /**
     * group_id integer
     */
    'group_id': number;
    /**
     * icon_id integer
     */
    'icon_id'?: number;
    /**
     * This only exists for types that can be put on the market
     */
    'market_group_id'?: number;
    /**
     * mass number
     */
    'mass'?: number;
    /**
     * name string
     */
    'name': string;
    /**
     * packaged_volume number
     */
    'packaged_volume'?: number;
    /**
     * portion_size integer
     */
    'portion_size'?: number;
    /**
     * published boolean
     */
    'published': boolean;
    /**
     * radius number
     */
    'radius'?: number;
    /**
     * type_id integer
     */
    'type_id': number;
    /**
     * volume number
     */
    'volume'?: number;
}
/**
 * The aggressor corporation or alliance that declared this war, only contains either corporation_id or alliance_id
 */
export interface GetWarsWarIdAggressor {
    /**
     * Alliance ID if and only if the aggressor is an alliance
     */
    'alliance_id'?: number;
    /**
     * Corporation ID if and only if the aggressor is a corporation
     */
    'corporation_id'?: number;
    /**
     * ISK value of ships the aggressor has destroyed
     */
    'isk_destroyed': number;
    /**
     * The number of ships the aggressor has killed
     */
    'ships_killed': number;
}
/**
 * ally object
 */
export interface GetWarsWarIdAlly {
    /**
     * Alliance ID if and only if this ally is an alliance
     */
    'alliance_id'?: number;
    /**
     * Corporation ID if and only if this ally is a corporation
     */
    'corporation_id'?: number;
}
/**
 * The defending corporation or alliance that declared this war, only contains either corporation_id or alliance_id
 */
export interface GetWarsWarIdDefender {
    /**
     * Alliance ID if and only if the defender is an alliance
     */
    'alliance_id'?: number;
    /**
     * Corporation ID if and only if the defender is a corporation
     */
    'corporation_id'?: number;
    /**
     * ISK value of ships the defender has killed
     */
    'isk_destroyed': number;
    /**
     * The number of ships the defender has killed
     */
    'ships_killed': number;
}
/**
 * 200 ok object
 */
export interface GetWarsWarIdKillmails200Ok {
    /**
     * A hash of this killmail
     */
    'killmail_hash': string;
    /**
     * ID of this killmail
     */
    'killmail_id': number;
}
/**
 * Unprocessable entity
 */
export interface GetWarsWarIdKillmailsUnprocessableEntity {
    /**
     * Unprocessable entity message
     */
    'error'?: string;
}
/**
 * 200 ok object
 */
export interface GetWarsWarIdOk {
    'aggressor': GetWarsWarIdAggressor;
    /**
     * allied corporations or alliances, each object contains either corporation_id or alliance_id
     */
    'allies'?: Array<GetWarsWarIdAlly>;
    /**
     * Time that the war was declared
     */
    'declared': string;
    'defender': GetWarsWarIdDefender;
    /**
     * Time the war ended and shooting was no longer allowed
     */
    'finished'?: string;
    /**
     * ID of the specified war
     */
    'id': number;
    /**
     * Was the war declared mutual by both parties
     */
    'mutual': boolean;
    /**
     * Is the war currently open for allies or not
     */
    'open_for_allies': boolean;
    /**
     * Time the war was retracted but both sides could still shoot each other
     */
    'retracted'?: string;
    /**
     * Time when the war started and both sides could shoot each other
     */
    'started'?: string;
}
/**
 * Unprocessable entity
 */
export interface GetWarsWarIdUnprocessableEntity {
    /**
     * Unprocessable entity message
     */
    'error'?: string;
}
/**
 * Internal server error model
 */
export interface InternalServerError {
    /**
     * Internal server error message
     */
    'error': string;
}
/**
 * 200 ok object
 */
export interface PostCharactersAffiliation200Ok {
    /**
     * The character\'s alliance ID, if their corporation is in an alliance
     */
    'alliance_id'?: number;
    /**
     * The character\'s ID
     */
    'character_id': number;
    /**
     * The character\'s corporation ID
     */
    'corporation_id': number;
    /**
     * The character\'s faction ID, if their corporation is in a faction
     */
    'faction_id'?: number;
}
/**
 * 200 ok object
 */
export interface PostCharactersCharacterIdAssetsLocations200Ok {
    /**
     * item_id integer
     */
    'item_id': number;
    'position': PostCharactersCharacterIdAssetsLocationsPosition;
}
/**
 * position object
 */
export interface PostCharactersCharacterIdAssetsLocationsPosition {
    /**
     * x number
     */
    'x': number;
    /**
     * y number
     */
    'y': number;
    /**
     * z number
     */
    'z': number;
}
/**
 * 200 ok object
 */
export interface PostCharactersCharacterIdAssetsNames200Ok {
    /**
     * item_id integer
     */
    'item_id': number;
    /**
     * name string
     */
    'name': string;
}
/**
 * Error 520
 */
export interface PostCharactersCharacterIdContactsError520 {
    /**
     * Error 520 message
     */
    'error'?: string;
}
/**
 * 201 created object
 */
export interface PostCharactersCharacterIdFittingsCreated {
    /**
     * fitting_id integer
     */
    'fitting_id': number;
}
/**
 * fitting object
 */
export interface PostCharactersCharacterIdFittingsFitting {
    /**
     * description string
     */
    'description': string;
    /**
     * items array
     */
    'items': Array<PostCharactersCharacterIdFittingsItem>;
    /**
     * name string
     */
    'name': string;
    /**
     * ship_type_id integer
     */
    'ship_type_id': number;
}
/**
 * item object
 */
export interface PostCharactersCharacterIdFittingsItem {
    /**
     * Fitting location for the item. Entries placed in \'Invalid\' will be discarded. If this leaves the fitting with nothing, it will cause an error.
     */
    'flag': PostCharactersCharacterIdFittingsItemFlagEnum;
    /**
     * quantity integer
     */
    'quantity': number;
    /**
     * type_id integer
     */
    'type_id': number;
}

export const PostCharactersCharacterIdFittingsItemFlagEnum = {
    Cargo: 'Cargo',
    DroneBay: 'DroneBay',
    FighterBay: 'FighterBay',
    HiSlot0: 'HiSlot0',
    HiSlot1: 'HiSlot1',
    HiSlot2: 'HiSlot2',
    HiSlot3: 'HiSlot3',
    HiSlot4: 'HiSlot4',
    HiSlot5: 'HiSlot5',
    HiSlot6: 'HiSlot6',
    HiSlot7: 'HiSlot7',
    Invalid: 'Invalid',
    LoSlot0: 'LoSlot0',
    LoSlot1: 'LoSlot1',
    LoSlot2: 'LoSlot2',
    LoSlot3: 'LoSlot3',
    LoSlot4: 'LoSlot4',
    LoSlot5: 'LoSlot5',
    LoSlot6: 'LoSlot6',
    LoSlot7: 'LoSlot7',
    MedSlot0: 'MedSlot0',
    MedSlot1: 'MedSlot1',
    MedSlot2: 'MedSlot2',
    MedSlot3: 'MedSlot3',
    MedSlot4: 'MedSlot4',
    MedSlot5: 'MedSlot5',
    MedSlot6: 'MedSlot6',
    MedSlot7: 'MedSlot7',
    RigSlot0: 'RigSlot0',
    RigSlot1: 'RigSlot1',
    RigSlot2: 'RigSlot2',
    ServiceSlot0: 'ServiceSlot0',
    ServiceSlot1: 'ServiceSlot1',
    ServiceSlot2: 'ServiceSlot2',
    ServiceSlot3: 'ServiceSlot3',
    ServiceSlot4: 'ServiceSlot4',
    ServiceSlot5: 'ServiceSlot5',
    ServiceSlot6: 'ServiceSlot6',
    ServiceSlot7: 'ServiceSlot7',
    SubSystemSlot0: 'SubSystemSlot0',
    SubSystemSlot1: 'SubSystemSlot1',
    SubSystemSlot2: 'SubSystemSlot2',
    SubSystemSlot3: 'SubSystemSlot3'
} as const;

export type PostCharactersCharacterIdFittingsItemFlagEnum = typeof PostCharactersCharacterIdFittingsItemFlagEnum[keyof typeof PostCharactersCharacterIdFittingsItemFlagEnum];

/**
 * Error 520
 */
export interface PostCharactersCharacterIdMailError520 {
    /**
     * Error 520 message
     */
    'error'?: string;
}
/**
 * label object
 */
export interface PostCharactersCharacterIdMailLabelsLabel {
    /**
     * Hexadecimal string representing label color, in RGB format
     */
    'color'?: PostCharactersCharacterIdMailLabelsLabelColorEnum;
    /**
     * name string
     */
    'name': string;
}

export const PostCharactersCharacterIdMailLabelsLabelColorEnum = {
    _0000fe: '#0000fe',
    _006634: '#006634',
    _0099ff: '#0099ff',
    _00ff33: '#00ff33',
    _01ffff: '#01ffff',
    _349800: '#349800',
    _660066: '#660066',
    _666666: '#666666',
    _999999: '#999999',
    _99ffff: '#99ffff',
    _9a0000: '#9a0000',
    Ccff9a: '#ccff9a',
    E6e6e6: '#e6e6e6',
    Fe0000: '#fe0000',
    Ff6600: '#ff6600',
    Ffff01: '#ffff01',
    Ffffcd: '#ffffcd',
    Ffffff: '#ffffff'
} as const;

export type PostCharactersCharacterIdMailLabelsLabelColorEnum = typeof PostCharactersCharacterIdMailLabelsLabelColorEnum[keyof typeof PostCharactersCharacterIdMailLabelsLabelColorEnum];

/**
 * mail object
 */
export interface PostCharactersCharacterIdMailMail {
    /**
     * approved_cost integer
     */
    'approved_cost'?: number;
    /**
     * body string
     */
    'body': string;
    /**
     * recipients array
     */
    'recipients': Array<PostCharactersCharacterIdMailRecipient>;
    /**
     * subject string
     */
    'subject': string;
}
/**
 * recipient object
 */
export interface PostCharactersCharacterIdMailRecipient {
    /**
     * recipient_id integer
     */
    'recipient_id': number;
    /**
     * recipient_type string
     */
    'recipient_type': PostCharactersCharacterIdMailRecipientRecipientTypeEnum;
}

export const PostCharactersCharacterIdMailRecipientRecipientTypeEnum = {
    Alliance: 'alliance',
    Character: 'character',
    Corporation: 'corporation',
    MailingList: 'mailing_list'
} as const;

export type PostCharactersCharacterIdMailRecipientRecipientTypeEnum = typeof PostCharactersCharacterIdMailRecipientRecipientTypeEnum[keyof typeof PostCharactersCharacterIdMailRecipientRecipientTypeEnum];

/**
 * 200 ok object
 */
export interface PostCorporationsCorporationIdAssetsLocations200Ok {
    /**
     * item_id integer
     */
    'item_id': number;
    'position': PostCorporationsCorporationIdAssetsLocationsPosition;
}
/**
 * Not found
 */
export interface PostCorporationsCorporationIdAssetsLocationsNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * position object
 */
export interface PostCorporationsCorporationIdAssetsLocationsPosition {
    /**
     * x number
     */
    'x': number;
    /**
     * y number
     */
    'y': number;
    /**
     * z number
     */
    'z': number;
}
/**
 * 200 ok object
 */
export interface PostCorporationsCorporationIdAssetsNames200Ok {
    /**
     * item_id integer
     */
    'item_id': number;
    /**
     * name string
     */
    'name': string;
}
/**
 * Not found
 */
export interface PostCorporationsCorporationIdAssetsNamesNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * invitation object
 */
export interface PostFleetsFleetIdMembersInvitation {
    /**
     * The character you want to invite
     */
    'character_id': number;
    /**
     * If a character is invited with the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified. If a character is invited with the `wing_commander` role, only `wing_id` should be specified. If a character is invited with the `squad_commander` role, both `wing_id` and `squad_id` should be specified. If a character is invited with the `squad_member` role, `wing_id` and `squad_id` should either both be specified or not specified at all. If they aren’t specified, the invited character will join any squad with available positions.
     */
    'role': PostFleetsFleetIdMembersInvitationRoleEnum;
    /**
     * squad_id integer
     */
    'squad_id'?: number;
    /**
     * wing_id integer
     */
    'wing_id'?: number;
}

export const PostFleetsFleetIdMembersInvitationRoleEnum = {
    FleetCommander: 'fleet_commander',
    WingCommander: 'wing_commander',
    SquadCommander: 'squad_commander',
    SquadMember: 'squad_member'
} as const;

export type PostFleetsFleetIdMembersInvitationRoleEnum = typeof PostFleetsFleetIdMembersInvitationRoleEnum[keyof typeof PostFleetsFleetIdMembersInvitationRoleEnum];

/**
 * Not found
 */
export interface PostFleetsFleetIdMembersNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 422 unprocessable entity object
 */
export interface PostFleetsFleetIdMembersUnprocessableEntity {
    /**
     * error message
     */
    'error'?: string;
}
/**
 * 201 created object
 */
export interface PostFleetsFleetIdWingsCreated {
    /**
     * The wing_id of the newly created wing
     */
    'wing_id': number;
}
/**
 * Not found
 */
export interface PostFleetsFleetIdWingsNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 201 created object
 */
export interface PostFleetsFleetIdWingsWingIdSquadsCreated {
    /**
     * The squad_id of the newly created squad
     */
    'squad_id': number;
}
/**
 * Not found
 */
export interface PostFleetsFleetIdWingsWingIdSquadsNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * new_mail object
 */
export interface PostUiOpenwindowNewmailNewMail {
    /**
     * body string
     */
    'body': string;
    /**
     * recipients array
     */
    'recipients': Array<number>;
    /**
     * subject string
     */
    'subject': string;
    /**
     * to_corp_or_alliance_id integer
     */
    'to_corp_or_alliance_id'?: number;
    /**
     * Corporations, alliances and mailing lists are all types of mailing groups. You may only send to one mailing group, at a time, so you may fill out either this field or the to_corp_or_alliance_ids field
     */
    'to_mailing_list_id'?: number;
}
/**
 * Unprocessable entity
 */
export interface PostUiOpenwindowNewmailUnprocessableEntity {
    /**
     * Unprocessable entity message
     */
    'error'?: string;
}
/**
 * agent object
 */
export interface PostUniverseIdsAgent {
    /**
     * id integer
     */
    'id'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * alliance object
 */
export interface PostUniverseIdsAlliance {
    /**
     * id integer
     */
    'id'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * character object
 */
export interface PostUniverseIdsCharacter {
    /**
     * id integer
     */
    'id'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * constellation object
 */
export interface PostUniverseIdsConstellation {
    /**
     * id integer
     */
    'id'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * corporation object
 */
export interface PostUniverseIdsCorporation {
    /**
     * id integer
     */
    'id'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * faction object
 */
export interface PostUniverseIdsFaction {
    /**
     * id integer
     */
    'id'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * inventory_type object
 */
export interface PostUniverseIdsInventoryType {
    /**
     * id integer
     */
    'id'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * 200 ok object
 */
export interface PostUniverseIdsOk {
    /**
     * agents array
     */
    'agents'?: Array<PostUniverseIdsAgent>;
    /**
     * alliances array
     */
    'alliances'?: Array<PostUniverseIdsAlliance>;
    /**
     * characters array
     */
    'characters'?: Array<PostUniverseIdsCharacter>;
    /**
     * constellations array
     */
    'constellations'?: Array<PostUniverseIdsConstellation>;
    /**
     * corporations array
     */
    'corporations'?: Array<PostUniverseIdsCorporation>;
    /**
     * factions array
     */
    'factions'?: Array<PostUniverseIdsFaction>;
    /**
     * inventory_types array
     */
    'inventory_types'?: Array<PostUniverseIdsInventoryType>;
    /**
     * regions array
     */
    'regions'?: Array<PostUniverseIdsRegion>;
    /**
     * stations array
     */
    'stations'?: Array<PostUniverseIdsStation>;
    /**
     * systems array
     */
    'systems'?: Array<PostUniverseIdsSystem>;
}
/**
 * region object
 */
export interface PostUniverseIdsRegion {
    /**
     * id integer
     */
    'id'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * station object
 */
export interface PostUniverseIdsStation {
    /**
     * id integer
     */
    'id'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * system object
 */
export interface PostUniverseIdsSystem {
    /**
     * id integer
     */
    'id'?: number;
    /**
     * name string
     */
    'name'?: string;
}
/**
 * 200 ok object
 */
export interface PostUniverseNames200Ok {
    /**
     * category string
     */
    'category': PostUniverseNames200OkCategoryEnum;
    /**
     * id integer
     */
    'id': number;
    /**
     * name string
     */
    'name': string;
}

export const PostUniverseNames200OkCategoryEnum = {
    Alliance: 'alliance',
    Character: 'character',
    Constellation: 'constellation',
    Corporation: 'corporation',
    InventoryType: 'inventory_type',
    Region: 'region',
    SolarSystem: 'solar_system',
    Station: 'station',
    Faction: 'faction'
} as const;

export type PostUniverseNames200OkCategoryEnum = typeof PostUniverseNames200OkCategoryEnum[keyof typeof PostUniverseNames200OkCategoryEnum];

/**
 * Not found
 */
export interface PostUniverseNamesNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * response object
 */
export interface PutCharactersCharacterIdCalendarEventIdResponse {
    /**
     * response string
     */
    'response': PutCharactersCharacterIdCalendarEventIdResponseResponseEnum;
}

export const PutCharactersCharacterIdCalendarEventIdResponseResponseEnum = {
    Accepted: 'accepted',
    Declined: 'declined',
    Tentative: 'tentative'
} as const;

export type PutCharactersCharacterIdCalendarEventIdResponseResponseEnum = typeof PutCharactersCharacterIdCalendarEventIdResponseResponseEnum[keyof typeof PutCharactersCharacterIdCalendarEventIdResponseResponseEnum];

/**
 * contents object
 */
export interface PutCharactersCharacterIdMailMailIdContents {
    /**
     * Labels to assign to the mail. Pre-existing labels are unassigned.
     */
    'labels'?: Array<number>;
    /**
     * Whether the mail is flagged as read
     */
    'read'?: boolean;
}
/**
 * movement object
 */
export interface PutFleetsFleetIdMembersMemberIdMovement {
    /**
     * If a character is moved to the `fleet_commander` role, neither `wing_id` or `squad_id` should be specified. If a character is moved to the `wing_commander` role, only `wing_id` should be specified. If a character is moved to the `squad_commander` role, both `wing_id` and `squad_id` should be specified. If a character is moved to the `squad_member` role, both `wing_id` and `squad_id` should be specified.
     */
    'role': PutFleetsFleetIdMembersMemberIdMovementRoleEnum;
    /**
     * squad_id integer
     */
    'squad_id'?: number;
    /**
     * wing_id integer
     */
    'wing_id'?: number;
}

export const PutFleetsFleetIdMembersMemberIdMovementRoleEnum = {
    FleetCommander: 'fleet_commander',
    WingCommander: 'wing_commander',
    SquadCommander: 'squad_commander',
    SquadMember: 'squad_member'
} as const;

export type PutFleetsFleetIdMembersMemberIdMovementRoleEnum = typeof PutFleetsFleetIdMembersMemberIdMovementRoleEnum[keyof typeof PutFleetsFleetIdMembersMemberIdMovementRoleEnum];

/**
 * Not found
 */
export interface PutFleetsFleetIdMembersMemberIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * 422 unprocessable entity object
 */
export interface PutFleetsFleetIdMembersMemberIdUnprocessableEntity {
    /**
     * error message
     */
    'error'?: string;
}
/**
 * new_settings object
 */
export interface PutFleetsFleetIdNewSettings {
    /**
     * Should free-move be enabled in the fleet
     */
    'is_free_move'?: boolean;
    /**
     * New fleet MOTD in CCP flavoured HTML
     */
    'motd'?: string;
}
/**
 * Not found
 */
export interface PutFleetsFleetIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * naming object
 */
export interface PutFleetsFleetIdSquadsSquadIdNaming {
    /**
     * name string
     */
    'name': string;
}
/**
 * Not found
 */
export interface PutFleetsFleetIdSquadsSquadIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * naming object
 */
export interface PutFleetsFleetIdWingsWingIdNaming {
    /**
     * name string
     */
    'name': string;
}
/**
 * Not found
 */
export interface PutFleetsFleetIdWingsWingIdNotFound {
    /**
     * Not found message
     */
    'error'?: string;
}
/**
 * Service unavailable model
 */
export interface ServiceUnavailable {
    /**
     * Service unavailable message
     */
    'error': string;
}
/**
 * Unauthorized model
 */
export interface Unauthorized {
    /**
     * Unauthorized message
     */
    'error': string;
}

/**
 * AllianceApi - axios parameter creator
 */
export const AllianceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
         * @summary List all alliances
         * @param {GetAlliancesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliances: async (datasource?: GetAlliancesDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alliances/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance information
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceId: async (allianceId: number, datasource?: GetAlliancesAllianceIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'allianceId' is not null or undefined
            assertParamExists('getAlliancesAllianceId', 'allianceId', allianceId)
            const localVarPath = `/alliances/{alliance_id}/`
                .replace(`{${"alliance_id"}}`, encodeURIComponent(String(allianceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
         * @summary List alliance\'s corporations
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdCorporationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdCorporations: async (allianceId: number, datasource?: GetAlliancesAllianceIdCorporationsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'allianceId' is not null or undefined
            assertParamExists('getAlliancesAllianceIdCorporations', 'allianceId', allianceId)
            const localVarPath = `/alliances/{alliance_id}/corporations/`
                .replace(`{${"alliance_id"}}`, encodeURIComponent(String(allianceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the icon urls for a alliance  --- Alternate route: `/dev/alliances/{alliance_id}/icons/`  Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  Alternate route: `/v2/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05
         * @summary Get alliance icon
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdIconsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdIcons: async (allianceId: number, datasource?: GetAlliancesAllianceIdIconsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'allianceId' is not null or undefined
            assertParamExists('getAlliancesAllianceIdIcons', 'allianceId', allianceId)
            const localVarPath = `/alliances/{alliance_id}/icons/`
                .replace(`{${"alliance_id"}}`, encodeURIComponent(String(allianceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllianceApi - functional programming interface
 */
export const AllianceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AllianceApiAxiosParamCreator(configuration)
    return {
        /**
         * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
         * @summary List all alliances
         * @param {GetAlliancesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlliances(datasource?: GetAlliancesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlliances(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllianceApi.getAlliances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance information
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlliancesAllianceId(allianceId: number, datasource?: GetAlliancesAllianceIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAlliancesAllianceIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlliancesAllianceId(allianceId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllianceApi.getAlliancesAllianceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
         * @summary List alliance\'s corporations
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdCorporationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlliancesAllianceIdCorporations(allianceId: number, datasource?: GetAlliancesAllianceIdCorporationsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlliancesAllianceIdCorporations(allianceId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllianceApi.getAlliancesAllianceIdCorporations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the icon urls for a alliance  --- Alternate route: `/dev/alliances/{alliance_id}/icons/`  Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  Alternate route: `/v2/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05
         * @summary Get alliance icon
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdIconsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlliancesAllianceIdIcons(allianceId: number, datasource?: GetAlliancesAllianceIdIconsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAlliancesAllianceIdIconsOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlliancesAllianceIdIcons(allianceId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllianceApi.getAlliancesAllianceIdIcons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AllianceApi - factory interface
 */
export const AllianceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AllianceApiFp(configuration)
    return {
        /**
         * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
         * @summary List all alliances
         * @param {GetAlliancesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliances(datasource?: GetAlliancesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getAlliances(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance information
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceId(allianceId: number, datasource?: GetAlliancesAllianceIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAlliancesAllianceIdOk> {
            return localVarFp.getAlliancesAllianceId(allianceId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
         * @summary List alliance\'s corporations
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdCorporationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdCorporations(allianceId: number, datasource?: GetAlliancesAllianceIdCorporationsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getAlliancesAllianceIdCorporations(allianceId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the icon urls for a alliance  --- Alternate route: `/dev/alliances/{alliance_id}/icons/`  Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  Alternate route: `/v2/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05
         * @summary Get alliance icon
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdIconsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdIcons(allianceId: number, datasource?: GetAlliancesAllianceIdIconsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAlliancesAllianceIdIconsOk> {
            return localVarFp.getAlliancesAllianceIdIcons(allianceId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AllianceApi - object-oriented interface
 */
export class AllianceApi extends BaseAPI {
    /**
     * List all active player alliances  --- Alternate route: `/dev/alliances/`  Alternate route: `/legacy/alliances/`  Alternate route: `/v1/alliances/`  Alternate route: `/v2/alliances/`  --- This route is cached for up to 3600 seconds
     * @summary List all alliances
     * @param {GetAlliancesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAlliances(datasource?: GetAlliancesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return AllianceApiFp(this.configuration).getAlliances(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Public information about an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/`  Alternate route: `/legacy/alliances/{alliance_id}/`  Alternate route: `/v3/alliances/{alliance_id}/`  Alternate route: `/v4/alliances/{alliance_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance information
     * @param {number} allianceId An EVE alliance ID
     * @param {GetAlliancesAllianceIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAlliancesAllianceId(allianceId: number, datasource?: GetAlliancesAllianceIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return AllianceApiFp(this.configuration).getAlliancesAllianceId(allianceId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all current member corporations of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/corporations/`  Alternate route: `/legacy/alliances/{alliance_id}/corporations/`  Alternate route: `/v1/alliances/{alliance_id}/corporations/`  Alternate route: `/v2/alliances/{alliance_id}/corporations/`  --- This route is cached for up to 3600 seconds
     * @summary List alliance\'s corporations
     * @param {number} allianceId An EVE alliance ID
     * @param {GetAlliancesAllianceIdCorporationsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAlliancesAllianceIdCorporations(allianceId: number, datasource?: GetAlliancesAllianceIdCorporationsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return AllianceApiFp(this.configuration).getAlliancesAllianceIdCorporations(allianceId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the icon urls for a alliance  --- Alternate route: `/dev/alliances/{alliance_id}/icons/`  Alternate route: `/legacy/alliances/{alliance_id}/icons/`  Alternate route: `/v1/alliances/{alliance_id}/icons/`  Alternate route: `/v2/alliances/{alliance_id}/icons/`  --- This route expires daily at 11:05
     * @summary Get alliance icon
     * @param {number} allianceId An EVE alliance ID
     * @param {GetAlliancesAllianceIdIconsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAlliancesAllianceIdIcons(allianceId: number, datasource?: GetAlliancesAllianceIdIconsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return AllianceApiFp(this.configuration).getAlliancesAllianceIdIcons(allianceId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetAlliancesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetAlliancesDatasourceEnum = typeof GetAlliancesDatasourceEnum[keyof typeof GetAlliancesDatasourceEnum];
export const GetAlliancesAllianceIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetAlliancesAllianceIdDatasourceEnum = typeof GetAlliancesAllianceIdDatasourceEnum[keyof typeof GetAlliancesAllianceIdDatasourceEnum];
export const GetAlliancesAllianceIdCorporationsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetAlliancesAllianceIdCorporationsDatasourceEnum = typeof GetAlliancesAllianceIdCorporationsDatasourceEnum[keyof typeof GetAlliancesAllianceIdCorporationsDatasourceEnum];
export const GetAlliancesAllianceIdIconsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetAlliancesAllianceIdIconsDatasourceEnum = typeof GetAlliancesAllianceIdIconsDatasourceEnum[keyof typeof GetAlliancesAllianceIdIconsDatasourceEnum];


/**
 * AssetsApi - axios parameter creator
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/legacy/characters/{character_id}/assets/`  Alternate route: `/v4/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
         * @summary Get character assets
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdAssetsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAssets: async (characterId: number, datasource?: GetCharactersCharacterIdAssetsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdAssets', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/assets/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-assets.read_assets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/`  Alternate route: `/v4/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation assets
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdAssetsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdAssets: async (corporationId: number, datasource?: GetCorporationsCorporationIdAssetsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdAssets', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/assets/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-assets.read_corporation_assets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/` 
         * @summary Get character asset locations
         * @param {number} characterId An EVE character ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCharactersCharacterIdAssetsLocationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdAssetsLocations: async (characterId: number, itemIds: Set<number>, datasource?: PostCharactersCharacterIdAssetsLocationsDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('postCharactersCharacterIdAssetsLocations', 'characterId', characterId)
            // verify required parameter 'itemIds' is not null or undefined
            assertParamExists('postCharactersCharacterIdAssetsLocations', 'itemIds', itemIds)
            const localVarPath = `/characters/{character_id}/assets/locations/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-assets.read_assets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/` 
         * @summary Get character asset names
         * @param {number} characterId An EVE character ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCharactersCharacterIdAssetsNamesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdAssetsNames: async (characterId: number, itemIds: Set<number>, datasource?: PostCharactersCharacterIdAssetsNamesDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('postCharactersCharacterIdAssetsNames', 'characterId', characterId)
            // verify required parameter 'itemIds' is not null or undefined
            assertParamExists('postCharactersCharacterIdAssetsNames', 'itemIds', itemIds)
            const localVarPath = `/characters/{character_id}/assets/names/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-assets.read_assets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset locations
         * @param {number} corporationId An EVE corporation ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCorporationsCorporationIdAssetsLocationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCorporationsCorporationIdAssetsLocations: async (corporationId: number, itemIds: Set<number>, datasource?: PostCorporationsCorporationIdAssetsLocationsDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('postCorporationsCorporationIdAssetsLocations', 'corporationId', corporationId)
            // verify required parameter 'itemIds' is not null or undefined
            assertParamExists('postCorporationsCorporationIdAssetsLocations', 'itemIds', itemIds)
            const localVarPath = `/corporations/{corporation_id}/assets/locations/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-assets.read_corporation_assets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset names
         * @param {number} corporationId An EVE corporation ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCorporationsCorporationIdAssetsNamesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCorporationsCorporationIdAssetsNames: async (corporationId: number, itemIds: Set<number>, datasource?: PostCorporationsCorporationIdAssetsNamesDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('postCorporationsCorporationIdAssetsNames', 'corporationId', corporationId)
            // verify required parameter 'itemIds' is not null or undefined
            assertParamExists('postCorporationsCorporationIdAssetsNames', 'itemIds', itemIds)
            const localVarPath = `/corporations/{corporation_id}/assets/names/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-assets.read_corporation_assets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/legacy/characters/{character_id}/assets/`  Alternate route: `/v4/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
         * @summary Get character assets
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdAssetsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdAssets(characterId: number, datasource?: GetCharactersCharacterIdAssetsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdAssets200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdAssets(characterId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.getCharactersCharacterIdAssets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/`  Alternate route: `/v4/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation assets
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdAssetsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdAssets(corporationId: number, datasource?: GetCorporationsCorporationIdAssetsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdAssets200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdAssets(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.getCorporationsCorporationIdAssets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/` 
         * @summary Get character asset locations
         * @param {number} characterId An EVE character ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCharactersCharacterIdAssetsLocationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCharactersCharacterIdAssetsLocations(characterId: number, itemIds: Set<number>, datasource?: PostCharactersCharacterIdAssetsLocationsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostCharactersCharacterIdAssetsLocations200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCharactersCharacterIdAssetsLocations(characterId, itemIds, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.postCharactersCharacterIdAssetsLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/` 
         * @summary Get character asset names
         * @param {number} characterId An EVE character ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCharactersCharacterIdAssetsNamesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCharactersCharacterIdAssetsNames(characterId: number, itemIds: Set<number>, datasource?: PostCharactersCharacterIdAssetsNamesDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostCharactersCharacterIdAssetsNames200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCharactersCharacterIdAssetsNames(characterId, itemIds, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.postCharactersCharacterIdAssetsNames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset locations
         * @param {number} corporationId An EVE corporation ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCorporationsCorporationIdAssetsLocationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCorporationsCorporationIdAssetsLocations(corporationId: number, itemIds: Set<number>, datasource?: PostCorporationsCorporationIdAssetsLocationsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostCorporationsCorporationIdAssetsLocations200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCorporationsCorporationIdAssetsLocations(corporationId, itemIds, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.postCorporationsCorporationIdAssetsLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset names
         * @param {number} corporationId An EVE corporation ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCorporationsCorporationIdAssetsNamesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCorporationsCorporationIdAssetsNames(corporationId: number, itemIds: Set<number>, datasource?: PostCorporationsCorporationIdAssetsNamesDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostCorporationsCorporationIdAssetsNames200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCorporationsCorporationIdAssetsNames(corporationId, itemIds, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.postCorporationsCorporationIdAssetsNames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetsApi - factory interface
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/legacy/characters/{character_id}/assets/`  Alternate route: `/v4/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
         * @summary Get character assets
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdAssetsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAssets(characterId: number, datasource?: GetCharactersCharacterIdAssetsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdAssets200Ok>> {
            return localVarFp.getCharactersCharacterIdAssets(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/`  Alternate route: `/v4/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation assets
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdAssetsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdAssets(corporationId: number, datasource?: GetCorporationsCorporationIdAssetsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdAssets200Ok>> {
            return localVarFp.getCorporationsCorporationIdAssets(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/` 
         * @summary Get character asset locations
         * @param {number} characterId An EVE character ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCharactersCharacterIdAssetsLocationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdAssetsLocations(characterId: number, itemIds: Set<number>, datasource?: PostCharactersCharacterIdAssetsLocationsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PostCharactersCharacterIdAssetsLocations200Ok>> {
            return localVarFp.postCharactersCharacterIdAssetsLocations(characterId, itemIds, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/` 
         * @summary Get character asset names
         * @param {number} characterId An EVE character ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCharactersCharacterIdAssetsNamesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdAssetsNames(characterId: number, itemIds: Set<number>, datasource?: PostCharactersCharacterIdAssetsNamesDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PostCharactersCharacterIdAssetsNames200Ok>> {
            return localVarFp.postCharactersCharacterIdAssetsNames(characterId, itemIds, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset locations
         * @param {number} corporationId An EVE corporation ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCorporationsCorporationIdAssetsLocationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCorporationsCorporationIdAssetsLocations(corporationId: number, itemIds: Set<number>, datasource?: PostCorporationsCorporationIdAssetsLocationsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PostCorporationsCorporationIdAssetsLocations200Ok>> {
            return localVarFp.postCorporationsCorporationIdAssetsLocations(corporationId, itemIds, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation asset names
         * @param {number} corporationId An EVE corporation ID
         * @param {Set<number>} itemIds A list of item ids
         * @param {PostCorporationsCorporationIdAssetsNamesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCorporationsCorporationIdAssetsNames(corporationId: number, itemIds: Set<number>, datasource?: PostCorporationsCorporationIdAssetsNamesDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PostCorporationsCorporationIdAssetsNames200Ok>> {
            return localVarFp.postCorporationsCorporationIdAssetsNames(corporationId, itemIds, datasource, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 */
export class AssetsApi extends BaseAPI {
    /**
     * Return a list of the characters assets  --- Alternate route: `/dev/characters/{character_id}/assets/`  Alternate route: `/legacy/characters/{character_id}/assets/`  Alternate route: `/v4/characters/{character_id}/assets/`  Alternate route: `/v5/characters/{character_id}/assets/`  --- This route is cached for up to 3600 seconds
     * @summary Get character assets
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdAssetsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdAssets(characterId: number, datasource?: GetCharactersCharacterIdAssetsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).getCharactersCharacterIdAssets(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of the corporation assets  --- Alternate route: `/dev/corporations/{corporation_id}/assets/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/`  Alternate route: `/v4/corporations/{corporation_id}/assets/`  Alternate route: `/v5/corporations/{corporation_id}/assets/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation assets
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdAssetsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdAssets(corporationId: number, datasource?: GetCorporationsCorporationIdAssetsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).getCorporationsCorporationIdAssets(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/characters/{character_id}/assets/locations/`  Alternate route: `/v2/characters/{character_id}/assets/locations/` 
     * @summary Get character asset locations
     * @param {number} characterId An EVE character ID
     * @param {Set<number>} itemIds A list of item ids
     * @param {PostCharactersCharacterIdAssetsLocationsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCharactersCharacterIdAssetsLocations(characterId: number, itemIds: Set<number>, datasource?: PostCharactersCharacterIdAssetsLocationsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).postCharactersCharacterIdAssetsLocations(characterId, itemIds, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.  --- Alternate route: `/dev/characters/{character_id}/assets/names/`  Alternate route: `/legacy/characters/{character_id}/assets/names/`  Alternate route: `/v1/characters/{character_id}/assets/names/` 
     * @summary Get character asset names
     * @param {number} characterId An EVE character ID
     * @param {Set<number>} itemIds A list of item ids
     * @param {PostCharactersCharacterIdAssetsNamesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCharactersCharacterIdAssetsNames(characterId: number, itemIds: Set<number>, datasource?: PostCharactersCharacterIdAssetsNamesDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).postCharactersCharacterIdAssetsNames(characterId, itemIds, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)  --- Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`  Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`   --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation asset locations
     * @param {number} corporationId An EVE corporation ID
     * @param {Set<number>} itemIds A list of item ids
     * @param {PostCorporationsCorporationIdAssetsLocationsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCorporationsCorporationIdAssetsLocations(corporationId: number, itemIds: Set<number>, datasource?: PostCorporationsCorporationIdAssetsLocationsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).postCorporationsCorporationIdAssetsLocations(corporationId, itemIds, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships  --- Alternate route: `/dev/corporations/{corporation_id}/assets/names/`  Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`  Alternate route: `/v1/corporations/{corporation_id}/assets/names/`   --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation asset names
     * @param {number} corporationId An EVE corporation ID
     * @param {Set<number>} itemIds A list of item ids
     * @param {PostCorporationsCorporationIdAssetsNamesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCorporationsCorporationIdAssetsNames(corporationId: number, itemIds: Set<number>, datasource?: PostCorporationsCorporationIdAssetsNamesDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).postCorporationsCorporationIdAssetsNames(corporationId, itemIds, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdAssetsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdAssetsDatasourceEnum = typeof GetCharactersCharacterIdAssetsDatasourceEnum[keyof typeof GetCharactersCharacterIdAssetsDatasourceEnum];
export const GetCorporationsCorporationIdAssetsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdAssetsDatasourceEnum = typeof GetCorporationsCorporationIdAssetsDatasourceEnum[keyof typeof GetCorporationsCorporationIdAssetsDatasourceEnum];
export const PostCharactersCharacterIdAssetsLocationsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostCharactersCharacterIdAssetsLocationsDatasourceEnum = typeof PostCharactersCharacterIdAssetsLocationsDatasourceEnum[keyof typeof PostCharactersCharacterIdAssetsLocationsDatasourceEnum];
export const PostCharactersCharacterIdAssetsNamesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostCharactersCharacterIdAssetsNamesDatasourceEnum = typeof PostCharactersCharacterIdAssetsNamesDatasourceEnum[keyof typeof PostCharactersCharacterIdAssetsNamesDatasourceEnum];
export const PostCorporationsCorporationIdAssetsLocationsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostCorporationsCorporationIdAssetsLocationsDatasourceEnum = typeof PostCorporationsCorporationIdAssetsLocationsDatasourceEnum[keyof typeof PostCorporationsCorporationIdAssetsLocationsDatasourceEnum];
export const PostCorporationsCorporationIdAssetsNamesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostCorporationsCorporationIdAssetsNamesDatasourceEnum = typeof PostCorporationsCorporationIdAssetsNamesDatasourceEnum[keyof typeof PostCorporationsCorporationIdAssetsNamesDatasourceEnum];


/**
 * CalendarApi - axios parameter creator
 */
export const CalendarApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
         * @summary List calendar event summaries
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdCalendarDatasourceEnum} [datasource] The server name you would like data from
         * @param {number} [fromEvent] The event ID to retrieve events from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendar: async (characterId: number, datasource?: GetCharactersCharacterIdCalendarDatasourceEnum, fromEvent?: number, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdCalendar', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/calendar/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-calendar.read_calendar_events.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (fromEvent !== undefined) {
                localVarQueryParameter['from_event'] = fromEvent;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {GetCharactersCharacterIdCalendarEventIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendarEventId: async (characterId: number, eventId: number, datasource?: GetCharactersCharacterIdCalendarEventIdDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdCalendarEventId', 'characterId', characterId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getCharactersCharacterIdCalendarEventId', 'eventId', eventId)
            const localVarPath = `/characters/{character_id}/calendar/{event_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-calendar.read_calendar_events.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
         * @summary Get attendees
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendarEventIdAttendees: async (characterId: number, eventId: number, datasource?: GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdCalendarEventIdAttendees', 'characterId', characterId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getCharactersCharacterIdCalendarEventIdAttendees', 'eventId', eventId)
            const localVarPath = `/characters/{character_id}/calendar/{event_id}/attendees/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-calendar.read_calendar_events.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Respond to an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The ID of the event requested
         * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
         * @param {PutCharactersCharacterIdCalendarEventIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdCalendarEventId: async (characterId: number, eventId: number, response: PutCharactersCharacterIdCalendarEventIdResponse, datasource?: PutCharactersCharacterIdCalendarEventIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('putCharactersCharacterIdCalendarEventId', 'characterId', characterId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('putCharactersCharacterIdCalendarEventId', 'eventId', eventId)
            // verify required parameter 'response' is not null or undefined
            assertParamExists('putCharactersCharacterIdCalendarEventId', 'response', response)
            const localVarPath = `/characters/{character_id}/calendar/{event_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-calendar.respond_calendar_events.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(response, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalendarApi - functional programming interface
 */
export const CalendarApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CalendarApiAxiosParamCreator(configuration)
    return {
        /**
         * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
         * @summary List calendar event summaries
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdCalendarDatasourceEnum} [datasource] The server name you would like data from
         * @param {number} [fromEvent] The event ID to retrieve events from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdCalendar(characterId: number, datasource?: GetCharactersCharacterIdCalendarDatasourceEnum, fromEvent?: number, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdCalendar200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdCalendar(characterId, datasource, fromEvent, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.getCharactersCharacterIdCalendar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {GetCharactersCharacterIdCalendarEventIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, datasource?: GetCharactersCharacterIdCalendarEventIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdCalendarEventIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdCalendarEventId(characterId, eventId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.getCharactersCharacterIdCalendarEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
         * @summary Get attendees
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdCalendarEventIdAttendees(characterId: number, eventId: number, datasource?: GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdCalendarEventIdAttendees200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdCalendarEventIdAttendees(characterId, eventId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.getCharactersCharacterIdCalendarEventIdAttendees']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Respond to an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The ID of the event requested
         * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
         * @param {PutCharactersCharacterIdCalendarEventIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, response: PutCharactersCharacterIdCalendarEventIdResponse, datasource?: PutCharactersCharacterIdCalendarEventIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCharactersCharacterIdCalendarEventId(characterId, eventId, response, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.putCharactersCharacterIdCalendarEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CalendarApi - factory interface
 */
export const CalendarApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CalendarApiFp(configuration)
    return {
        /**
         * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
         * @summary List calendar event summaries
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdCalendarDatasourceEnum} [datasource] The server name you would like data from
         * @param {number} [fromEvent] The event ID to retrieve events from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendar(characterId: number, datasource?: GetCharactersCharacterIdCalendarDatasourceEnum, fromEvent?: number, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdCalendar200Ok>> {
            return localVarFp.getCharactersCharacterIdCalendar(characterId, datasource, fromEvent, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {GetCharactersCharacterIdCalendarEventIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, datasource?: GetCharactersCharacterIdCalendarEventIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdCalendarEventIdOk> {
            return localVarFp.getCharactersCharacterIdCalendarEventId(characterId, eventId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
         * @summary Get attendees
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The id of the event requested
         * @param {GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCalendarEventIdAttendees(characterId: number, eventId: number, datasource?: GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdCalendarEventIdAttendees200Ok>> {
            return localVarFp.getCharactersCharacterIdCalendarEventIdAttendees(characterId, eventId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
         * @summary Respond to an event
         * @param {number} characterId An EVE character ID
         * @param {number} eventId The ID of the event requested
         * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
         * @param {PutCharactersCharacterIdCalendarEventIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, response: PutCharactersCharacterIdCalendarEventIdResponse, datasource?: PutCharactersCharacterIdCalendarEventIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putCharactersCharacterIdCalendarEventId(characterId, eventId, response, datasource, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CalendarApi - object-oriented interface
 */
export class CalendarApi extends BaseAPI {
    /**
     * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event  --- Alternate route: `/dev/characters/{character_id}/calendar/`  Alternate route: `/legacy/characters/{character_id}/calendar/`  Alternate route: `/v1/characters/{character_id}/calendar/`  Alternate route: `/v2/characters/{character_id}/calendar/`  --- This route is cached for up to 5 seconds
     * @summary List calendar event summaries
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdCalendarDatasourceEnum} [datasource] The server name you would like data from
     * @param {number} [fromEvent] The event ID to retrieve events from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdCalendar(characterId: number, datasource?: GetCharactersCharacterIdCalendarDatasourceEnum, fromEvent?: number, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).getCharactersCharacterIdCalendar(characterId, datasource, fromEvent, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the information for a specific event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get an event
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The id of the event requested
     * @param {GetCharactersCharacterIdCalendarEventIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, datasource?: GetCharactersCharacterIdCalendarEventIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).getCharactersCharacterIdCalendarEventId(characterId, eventId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all invited attendees for a given event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`  Alternate route: `/v2/characters/{character_id}/calendar/{event_id}/attendees/`  --- This route is cached for up to 600 seconds
     * @summary Get attendees
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The id of the event requested
     * @param {GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdCalendarEventIdAttendees(characterId: number, eventId: number, datasource?: GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).getCharactersCharacterIdCalendarEventIdAttendees(characterId, eventId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set your response status to an event  --- Alternate route: `/dev/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`  Alternate route: `/v4/characters/{character_id}/calendar/{event_id}/`  --- This route is cached for up to 5 seconds
     * @summary Respond to an event
     * @param {number} characterId An EVE character ID
     * @param {number} eventId The ID of the event requested
     * @param {PutCharactersCharacterIdCalendarEventIdResponse} response The response value to set, overriding current value
     * @param {PutCharactersCharacterIdCalendarEventIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putCharactersCharacterIdCalendarEventId(characterId: number, eventId: number, response: PutCharactersCharacterIdCalendarEventIdResponse, datasource?: PutCharactersCharacterIdCalendarEventIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).putCharactersCharacterIdCalendarEventId(characterId, eventId, response, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdCalendarDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdCalendarDatasourceEnum = typeof GetCharactersCharacterIdCalendarDatasourceEnum[keyof typeof GetCharactersCharacterIdCalendarDatasourceEnum];
export const GetCharactersCharacterIdCalendarEventIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdCalendarEventIdDatasourceEnum = typeof GetCharactersCharacterIdCalendarEventIdDatasourceEnum[keyof typeof GetCharactersCharacterIdCalendarEventIdDatasourceEnum];
export const GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum = typeof GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum[keyof typeof GetCharactersCharacterIdCalendarEventIdAttendeesDatasourceEnum];
export const PutCharactersCharacterIdCalendarEventIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PutCharactersCharacterIdCalendarEventIdDatasourceEnum = typeof PutCharactersCharacterIdCalendarEventIdDatasourceEnum[keyof typeof PutCharactersCharacterIdCalendarEventIdDatasourceEnum];


/**
 * CharacterApi - axios parameter creator
 */
export const CharacterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 604800 seconds
         * @summary Get character\'s public information
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterId: async (characterId: number, datasource?: GetCharactersCharacterIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterId', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/legacy/characters/{character_id}/agents_research/`  Alternate route: `/v1/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
         * @summary Get agents research
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdAgentsResearchDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAgentsResearch: async (characterId: number, datasource?: GetCharactersCharacterIdAgentsResearchDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdAgentsResearch', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/agents_research/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_agents_research.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/legacy/characters/{character_id}/blueprints/`  Alternate route: `/v2/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
         * @summary Get blueprints
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdBlueprintsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdBlueprints: async (characterId: number, datasource?: GetCharactersCharacterIdBlueprintsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdBlueprints', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/blueprints/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_blueprints.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/legacy/characters/{character_id}/corporationhistory/`  Alternate route: `/v1/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
         * @summary Get corporation history
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdCorporationhistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCorporationhistory: async (characterId: number, datasource?: GetCharactersCharacterIdCorporationhistoryDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdCorporationhistory', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/corporationhistory/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a character\'s jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/legacy/characters/{character_id}/fatigue/`  Alternate route: `/v1/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
         * @summary Get jump fatigue
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFatigueDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFatigue: async (characterId: number, datasource?: GetCharactersCharacterIdFatigueDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdFatigue', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/fatigue/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_fatigue.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/legacy/characters/{character_id}/medals/`  Alternate route: `/v1/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get medals
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMedalsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMedals: async (characterId: number, datasource?: GetCharactersCharacterIdMedalsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdMedals', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/medals/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_medals.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/legacy/characters/{character_id}/notifications/`  Alternate route: `/v4/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
         * @summary Get character notifications
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdNotificationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdNotifications: async (characterId: number, datasource?: GetCharactersCharacterIdNotificationsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdNotifications', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/notifications/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_notifications.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return notifications about having been added to someone\'s contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/legacy/characters/{character_id}/notifications/contacts/`  Alternate route: `/v1/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
         * @summary Get new contact notifications
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdNotificationsContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdNotificationsContacts: async (characterId: number, datasource?: GetCharactersCharacterIdNotificationsContactsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdNotificationsContacts', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/notifications/contacts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_notifications.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
         * @summary Get character portraits
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdPortraitDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPortrait: async (characterId: number, datasource?: GetCharactersCharacterIdPortraitDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdPortrait', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/portrait/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a character\'s corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/legacy/characters/{character_id}/roles/`  Alternate route: `/v2/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation roles
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdRolesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdRoles: async (characterId: number, datasource?: GetCharactersCharacterIdRolesDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdRoles', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/roles/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_corporation_roles.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/legacy/characters/{character_id}/standings/`  Alternate route: `/v1/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get standings
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdStandingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdStandings: async (characterId: number, datasource?: GetCharactersCharacterIdStandingsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdStandings', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/standings/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_standings.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a character\'s titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/legacy/characters/{character_id}/titles/`  Alternate route: `/v1/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation titles
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdTitlesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdTitles: async (characterId: number, datasource?: GetCharactersCharacterIdTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdTitles', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/titles/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_titles.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/legacy/characters/affiliation/`  Alternate route: `/v1/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
         * @summary Character affiliation
         * @param {Set<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
         * @param {PostCharactersAffiliationDatasourceEnum} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersAffiliation: async (characters: Set<number>, datasource?: PostCharactersAffiliationDatasourceEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characters' is not null or undefined
            assertParamExists('postCharactersAffiliation', 'characters', characters)
            const localVarPath = `/characters/affiliation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a source character ID in the url and a set of target character ID\'s in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/legacy/characters/{character_id}/cspa/`  Alternate route: `/v4/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/` 
         * @summary Calculate a CSPA charge cost
         * @param {number} characterId An EVE character ID
         * @param {Set<number>} characters The target characters to calculate the charge for
         * @param {PostCharactersCharacterIdCspaDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdCspa: async (characterId: number, characters: Set<number>, datasource?: PostCharactersCharacterIdCspaDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('postCharactersCharacterIdCspa', 'characterId', characterId)
            // verify required parameter 'characters' is not null or undefined
            assertParamExists('postCharactersCharacterIdCspa', 'characters', characters)
            const localVarPath = `/characters/{character_id}/cspa/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_contacts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(characters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharacterApi - functional programming interface
 */
export const CharacterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CharacterApiAxiosParamCreator(configuration)
    return {
        /**
         * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 604800 seconds
         * @summary Get character\'s public information
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterId(characterId: number, datasource?: GetCharactersCharacterIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterId(characterId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/legacy/characters/{character_id}/agents_research/`  Alternate route: `/v1/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
         * @summary Get agents research
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdAgentsResearchDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdAgentsResearch(characterId: number, datasource?: GetCharactersCharacterIdAgentsResearchDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdAgentsResearch200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdAgentsResearch(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterIdAgentsResearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/legacy/characters/{character_id}/blueprints/`  Alternate route: `/v2/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
         * @summary Get blueprints
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdBlueprintsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdBlueprints(characterId: number, datasource?: GetCharactersCharacterIdBlueprintsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdBlueprints200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdBlueprints(characterId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterIdBlueprints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/legacy/characters/{character_id}/corporationhistory/`  Alternate route: `/v1/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
         * @summary Get corporation history
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdCorporationhistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdCorporationhistory(characterId: number, datasource?: GetCharactersCharacterIdCorporationhistoryDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdCorporationhistory200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdCorporationhistory(characterId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterIdCorporationhistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a character\'s jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/legacy/characters/{character_id}/fatigue/`  Alternate route: `/v1/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
         * @summary Get jump fatigue
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFatigueDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdFatigue(characterId: number, datasource?: GetCharactersCharacterIdFatigueDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdFatigueOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdFatigue(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterIdFatigue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/legacy/characters/{character_id}/medals/`  Alternate route: `/v1/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get medals
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMedalsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdMedals(characterId: number, datasource?: GetCharactersCharacterIdMedalsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdMedals200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdMedals(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterIdMedals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/legacy/characters/{character_id}/notifications/`  Alternate route: `/v4/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
         * @summary Get character notifications
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdNotificationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdNotifications(characterId: number, datasource?: GetCharactersCharacterIdNotificationsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdNotifications200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdNotifications(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterIdNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return notifications about having been added to someone\'s contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/legacy/characters/{character_id}/notifications/contacts/`  Alternate route: `/v1/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
         * @summary Get new contact notifications
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdNotificationsContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdNotificationsContacts(characterId: number, datasource?: GetCharactersCharacterIdNotificationsContactsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdNotificationsContacts200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdNotificationsContacts(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterIdNotificationsContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
         * @summary Get character portraits
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdPortraitDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdPortrait(characterId: number, datasource?: GetCharactersCharacterIdPortraitDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdPortraitOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdPortrait(characterId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterIdPortrait']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a character\'s corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/legacy/characters/{character_id}/roles/`  Alternate route: `/v2/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation roles
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdRolesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdRoles(characterId: number, datasource?: GetCharactersCharacterIdRolesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdRolesOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdRoles(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterIdRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/legacy/characters/{character_id}/standings/`  Alternate route: `/v1/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get standings
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdStandingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdStandings(characterId: number, datasource?: GetCharactersCharacterIdStandingsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdStandings200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdStandings(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterIdStandings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a character\'s titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/legacy/characters/{character_id}/titles/`  Alternate route: `/v1/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation titles
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdTitlesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdTitles(characterId: number, datasource?: GetCharactersCharacterIdTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdTitles200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdTitles(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.getCharactersCharacterIdTitles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/legacy/characters/affiliation/`  Alternate route: `/v1/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
         * @summary Character affiliation
         * @param {Set<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
         * @param {PostCharactersAffiliationDatasourceEnum} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCharactersAffiliation(characters: Set<number>, datasource?: PostCharactersAffiliationDatasourceEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostCharactersAffiliation200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCharactersAffiliation(characters, datasource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.postCharactersAffiliation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a source character ID in the url and a set of target character ID\'s in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/legacy/characters/{character_id}/cspa/`  Alternate route: `/v4/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/` 
         * @summary Calculate a CSPA charge cost
         * @param {number} characterId An EVE character ID
         * @param {Set<number>} characters The target characters to calculate the charge for
         * @param {PostCharactersCharacterIdCspaDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCharactersCharacterIdCspa(characterId: number, characters: Set<number>, datasource?: PostCharactersCharacterIdCspaDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCharactersCharacterIdCspa(characterId, characters, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharacterApi.postCharactersCharacterIdCspa']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CharacterApi - factory interface
 */
export const CharacterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CharacterApiFp(configuration)
    return {
        /**
         * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 604800 seconds
         * @summary Get character\'s public information
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterId(characterId: number, datasource?: GetCharactersCharacterIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdOk> {
            return localVarFp.getCharactersCharacterId(characterId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/legacy/characters/{character_id}/agents_research/`  Alternate route: `/v1/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
         * @summary Get agents research
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdAgentsResearchDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAgentsResearch(characterId: number, datasource?: GetCharactersCharacterIdAgentsResearchDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdAgentsResearch200Ok>> {
            return localVarFp.getCharactersCharacterIdAgentsResearch(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/legacy/characters/{character_id}/blueprints/`  Alternate route: `/v2/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
         * @summary Get blueprints
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdBlueprintsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdBlueprints(characterId: number, datasource?: GetCharactersCharacterIdBlueprintsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdBlueprints200Ok>> {
            return localVarFp.getCharactersCharacterIdBlueprints(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/legacy/characters/{character_id}/corporationhistory/`  Alternate route: `/v1/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
         * @summary Get corporation history
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdCorporationhistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdCorporationhistory(characterId: number, datasource?: GetCharactersCharacterIdCorporationhistoryDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdCorporationhistory200Ok>> {
            return localVarFp.getCharactersCharacterIdCorporationhistory(characterId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a character\'s jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/legacy/characters/{character_id}/fatigue/`  Alternate route: `/v1/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
         * @summary Get jump fatigue
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFatigueDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFatigue(characterId: number, datasource?: GetCharactersCharacterIdFatigueDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdFatigueOk> {
            return localVarFp.getCharactersCharacterIdFatigue(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/legacy/characters/{character_id}/medals/`  Alternate route: `/v1/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get medals
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMedalsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMedals(characterId: number, datasource?: GetCharactersCharacterIdMedalsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdMedals200Ok>> {
            return localVarFp.getCharactersCharacterIdMedals(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/legacy/characters/{character_id}/notifications/`  Alternate route: `/v4/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
         * @summary Get character notifications
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdNotificationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdNotifications(characterId: number, datasource?: GetCharactersCharacterIdNotificationsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdNotifications200Ok>> {
            return localVarFp.getCharactersCharacterIdNotifications(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return notifications about having been added to someone\'s contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/legacy/characters/{character_id}/notifications/contacts/`  Alternate route: `/v1/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
         * @summary Get new contact notifications
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdNotificationsContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdNotificationsContacts(characterId: number, datasource?: GetCharactersCharacterIdNotificationsContactsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdNotificationsContacts200Ok>> {
            return localVarFp.getCharactersCharacterIdNotificationsContacts(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
         * @summary Get character portraits
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdPortraitDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPortrait(characterId: number, datasource?: GetCharactersCharacterIdPortraitDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdPortraitOk> {
            return localVarFp.getCharactersCharacterIdPortrait(characterId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a character\'s corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/legacy/characters/{character_id}/roles/`  Alternate route: `/v2/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation roles
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdRolesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdRoles(characterId: number, datasource?: GetCharactersCharacterIdRolesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdRolesOk> {
            return localVarFp.getCharactersCharacterIdRoles(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/legacy/characters/{character_id}/standings/`  Alternate route: `/v1/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get standings
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdStandingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdStandings(characterId: number, datasource?: GetCharactersCharacterIdStandingsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdStandings200Ok>> {
            return localVarFp.getCharactersCharacterIdStandings(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a character\'s titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/legacy/characters/{character_id}/titles/`  Alternate route: `/v1/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
         * @summary Get character corporation titles
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdTitlesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdTitles(characterId: number, datasource?: GetCharactersCharacterIdTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdTitles200Ok>> {
            return localVarFp.getCharactersCharacterIdTitles(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/legacy/characters/affiliation/`  Alternate route: `/v1/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
         * @summary Character affiliation
         * @param {Set<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
         * @param {PostCharactersAffiliationDatasourceEnum} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersAffiliation(characters: Set<number>, datasource?: PostCharactersAffiliationDatasourceEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<PostCharactersAffiliation200Ok>> {
            return localVarFp.postCharactersAffiliation(characters, datasource, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a source character ID in the url and a set of target character ID\'s in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/legacy/characters/{character_id}/cspa/`  Alternate route: `/v4/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/` 
         * @summary Calculate a CSPA charge cost
         * @param {number} characterId An EVE character ID
         * @param {Set<number>} characters The target characters to calculate the charge for
         * @param {PostCharactersCharacterIdCspaDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdCspa(characterId: number, characters: Set<number>, datasource?: PostCharactersCharacterIdCspaDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.postCharactersCharacterIdCspa(characterId, characters, datasource, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CharacterApi - object-oriented interface
 */
export class CharacterApi extends BaseAPI {
    /**
     * Public information about a character  --- Alternate route: `/dev/characters/{character_id}/`  Alternate route: `/legacy/characters/{character_id}/`  Alternate route: `/v5/characters/{character_id}/`  --- This route is cached for up to 604800 seconds
     * @summary Get character\'s public information
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterId(characterId: number, datasource?: GetCharactersCharacterIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterId(characterId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)  --- Alternate route: `/dev/characters/{character_id}/agents_research/`  Alternate route: `/legacy/characters/{character_id}/agents_research/`  Alternate route: `/v1/characters/{character_id}/agents_research/`  Alternate route: `/v2/characters/{character_id}/agents_research/`  --- This route is cached for up to 3600 seconds
     * @summary Get agents research
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdAgentsResearchDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdAgentsResearch(characterId: number, datasource?: GetCharactersCharacterIdAgentsResearchDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdAgentsResearch(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of blueprints the character owns  --- Alternate route: `/dev/characters/{character_id}/blueprints/`  Alternate route: `/legacy/characters/{character_id}/blueprints/`  Alternate route: `/v2/characters/{character_id}/blueprints/`  Alternate route: `/v3/characters/{character_id}/blueprints/`  --- This route is cached for up to 3600 seconds
     * @summary Get blueprints
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdBlueprintsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdBlueprints(characterId: number, datasource?: GetCharactersCharacterIdBlueprintsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdBlueprints(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all the corporations a character has been a member of  --- Alternate route: `/dev/characters/{character_id}/corporationhistory/`  Alternate route: `/legacy/characters/{character_id}/corporationhistory/`  Alternate route: `/v1/characters/{character_id}/corporationhistory/`  Alternate route: `/v2/characters/{character_id}/corporationhistory/`  --- This route is cached for up to 86400 seconds
     * @summary Get corporation history
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdCorporationhistoryDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdCorporationhistory(characterId: number, datasource?: GetCharactersCharacterIdCorporationhistoryDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdCorporationhistory(characterId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a character\'s jump activation and fatigue information  --- Alternate route: `/dev/characters/{character_id}/fatigue/`  Alternate route: `/legacy/characters/{character_id}/fatigue/`  Alternate route: `/v1/characters/{character_id}/fatigue/`  Alternate route: `/v2/characters/{character_id}/fatigue/`  --- This route is cached for up to 300 seconds
     * @summary Get jump fatigue
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdFatigueDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdFatigue(characterId: number, datasource?: GetCharactersCharacterIdFatigueDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdFatigue(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of medals the character has  --- Alternate route: `/dev/characters/{character_id}/medals/`  Alternate route: `/legacy/characters/{character_id}/medals/`  Alternate route: `/v1/characters/{character_id}/medals/`  Alternate route: `/v2/characters/{character_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get medals
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdMedalsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdMedals(characterId: number, datasource?: GetCharactersCharacterIdMedalsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdMedals(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return character notifications  --- Alternate route: `/dev/characters/{character_id}/notifications/`  Alternate route: `/legacy/characters/{character_id}/notifications/`  Alternate route: `/v4/characters/{character_id}/notifications/`  Alternate route: `/v5/characters/{character_id}/notifications/`  Alternate route: `/v6/characters/{character_id}/notifications/`  --- This route is cached for up to 600 seconds
     * @summary Get character notifications
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdNotificationsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdNotifications(characterId: number, datasource?: GetCharactersCharacterIdNotificationsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdNotifications(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return notifications about having been added to someone\'s contact list  --- Alternate route: `/dev/characters/{character_id}/notifications/contacts/`  Alternate route: `/legacy/characters/{character_id}/notifications/contacts/`  Alternate route: `/v1/characters/{character_id}/notifications/contacts/`  Alternate route: `/v2/characters/{character_id}/notifications/contacts/`  --- This route is cached for up to 600 seconds
     * @summary Get new contact notifications
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdNotificationsContactsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdNotificationsContacts(characterId: number, datasource?: GetCharactersCharacterIdNotificationsContactsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdNotificationsContacts(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get portrait urls for a character  --- Alternate route: `/dev/characters/{character_id}/portrait/`  Alternate route: `/v2/characters/{character_id}/portrait/`  Alternate route: `/v3/characters/{character_id}/portrait/`  --- This route expires daily at 11:05
     * @summary Get character portraits
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdPortraitDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdPortrait(characterId: number, datasource?: GetCharactersCharacterIdPortraitDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdPortrait(characterId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a character\'s corporation roles  --- Alternate route: `/dev/characters/{character_id}/roles/`  Alternate route: `/legacy/characters/{character_id}/roles/`  Alternate route: `/v2/characters/{character_id}/roles/`  Alternate route: `/v3/characters/{character_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation roles
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdRolesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdRoles(characterId: number, datasource?: GetCharactersCharacterIdRolesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdRoles(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return character standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/characters/{character_id}/standings/`  Alternate route: `/legacy/characters/{character_id}/standings/`  Alternate route: `/v1/characters/{character_id}/standings/`  Alternate route: `/v2/characters/{character_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get standings
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdStandingsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdStandings(characterId: number, datasource?: GetCharactersCharacterIdStandingsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdStandings(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a character\'s titles  --- Alternate route: `/dev/characters/{character_id}/titles/`  Alternate route: `/legacy/characters/{character_id}/titles/`  Alternate route: `/v1/characters/{character_id}/titles/`  Alternate route: `/v2/characters/{character_id}/titles/`  --- This route is cached for up to 3600 seconds
     * @summary Get character corporation titles
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdTitlesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdTitles(characterId: number, datasource?: GetCharactersCharacterIdTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).getCharactersCharacterIdTitles(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk lookup of character IDs to corporation, alliance and faction  --- Alternate route: `/dev/characters/affiliation/`  Alternate route: `/legacy/characters/affiliation/`  Alternate route: `/v1/characters/affiliation/`  Alternate route: `/v2/characters/affiliation/`  --- This route is cached for up to 3600 seconds
     * @summary Character affiliation
     * @param {Set<number>} characters The character IDs to fetch affiliations for. All characters must exist, or none will be returned
     * @param {PostCharactersAffiliationDatasourceEnum} [datasource] The server name you would like data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCharactersAffiliation(characters: Set<number>, datasource?: PostCharactersAffiliationDatasourceEnum, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).postCharactersAffiliation(characters, datasource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a source character ID in the url and a set of target character ID\'s in the body, returns a CSPA charge cost  --- Alternate route: `/dev/characters/{character_id}/cspa/`  Alternate route: `/legacy/characters/{character_id}/cspa/`  Alternate route: `/v4/characters/{character_id}/cspa/`  Alternate route: `/v5/characters/{character_id}/cspa/` 
     * @summary Calculate a CSPA charge cost
     * @param {number} characterId An EVE character ID
     * @param {Set<number>} characters The target characters to calculate the charge for
     * @param {PostCharactersCharacterIdCspaDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCharactersCharacterIdCspa(characterId: number, characters: Set<number>, datasource?: PostCharactersCharacterIdCspaDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return CharacterApiFp(this.configuration).postCharactersCharacterIdCspa(characterId, characters, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdDatasourceEnum = typeof GetCharactersCharacterIdDatasourceEnum[keyof typeof GetCharactersCharacterIdDatasourceEnum];
export const GetCharactersCharacterIdAgentsResearchDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdAgentsResearchDatasourceEnum = typeof GetCharactersCharacterIdAgentsResearchDatasourceEnum[keyof typeof GetCharactersCharacterIdAgentsResearchDatasourceEnum];
export const GetCharactersCharacterIdBlueprintsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdBlueprintsDatasourceEnum = typeof GetCharactersCharacterIdBlueprintsDatasourceEnum[keyof typeof GetCharactersCharacterIdBlueprintsDatasourceEnum];
export const GetCharactersCharacterIdCorporationhistoryDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdCorporationhistoryDatasourceEnum = typeof GetCharactersCharacterIdCorporationhistoryDatasourceEnum[keyof typeof GetCharactersCharacterIdCorporationhistoryDatasourceEnum];
export const GetCharactersCharacterIdFatigueDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdFatigueDatasourceEnum = typeof GetCharactersCharacterIdFatigueDatasourceEnum[keyof typeof GetCharactersCharacterIdFatigueDatasourceEnum];
export const GetCharactersCharacterIdMedalsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdMedalsDatasourceEnum = typeof GetCharactersCharacterIdMedalsDatasourceEnum[keyof typeof GetCharactersCharacterIdMedalsDatasourceEnum];
export const GetCharactersCharacterIdNotificationsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdNotificationsDatasourceEnum = typeof GetCharactersCharacterIdNotificationsDatasourceEnum[keyof typeof GetCharactersCharacterIdNotificationsDatasourceEnum];
export const GetCharactersCharacterIdNotificationsContactsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdNotificationsContactsDatasourceEnum = typeof GetCharactersCharacterIdNotificationsContactsDatasourceEnum[keyof typeof GetCharactersCharacterIdNotificationsContactsDatasourceEnum];
export const GetCharactersCharacterIdPortraitDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdPortraitDatasourceEnum = typeof GetCharactersCharacterIdPortraitDatasourceEnum[keyof typeof GetCharactersCharacterIdPortraitDatasourceEnum];
export const GetCharactersCharacterIdRolesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdRolesDatasourceEnum = typeof GetCharactersCharacterIdRolesDatasourceEnum[keyof typeof GetCharactersCharacterIdRolesDatasourceEnum];
export const GetCharactersCharacterIdStandingsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdStandingsDatasourceEnum = typeof GetCharactersCharacterIdStandingsDatasourceEnum[keyof typeof GetCharactersCharacterIdStandingsDatasourceEnum];
export const GetCharactersCharacterIdTitlesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdTitlesDatasourceEnum = typeof GetCharactersCharacterIdTitlesDatasourceEnum[keyof typeof GetCharactersCharacterIdTitlesDatasourceEnum];
export const PostCharactersAffiliationDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostCharactersAffiliationDatasourceEnum = typeof PostCharactersAffiliationDatasourceEnum[keyof typeof PostCharactersAffiliationDatasourceEnum];
export const PostCharactersCharacterIdCspaDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostCharactersCharacterIdCspaDatasourceEnum = typeof PostCharactersCharacterIdCspaDatasourceEnum[keyof typeof PostCharactersCharacterIdCspaDatasourceEnum];


/**
 * ClonesApi - axios parameter creator
 */
export const ClonesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A list of the character\'s clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/legacy/characters/{character_id}/clones/`  Alternate route: `/v2/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
         * @summary Get clones
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdClonesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdClones: async (characterId: number, datasource?: GetCharactersCharacterIdClonesDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdClones', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/clones/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-clones.read_clones.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
         * @summary Get active implants
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdImplantsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdImplants: async (characterId: number, datasource?: GetCharactersCharacterIdImplantsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdImplants', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/implants/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-clones.read_implants.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClonesApi - functional programming interface
 */
export const ClonesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClonesApiAxiosParamCreator(configuration)
    return {
        /**
         * A list of the character\'s clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/legacy/characters/{character_id}/clones/`  Alternate route: `/v2/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
         * @summary Get clones
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdClonesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdClones(characterId: number, datasource?: GetCharactersCharacterIdClonesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdClonesOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdClones(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClonesApi.getCharactersCharacterIdClones']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
         * @summary Get active implants
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdImplantsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdImplants(characterId: number, datasource?: GetCharactersCharacterIdImplantsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdImplants(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClonesApi.getCharactersCharacterIdImplants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClonesApi - factory interface
 */
export const ClonesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClonesApiFp(configuration)
    return {
        /**
         * A list of the character\'s clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/legacy/characters/{character_id}/clones/`  Alternate route: `/v2/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
         * @summary Get clones
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdClonesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdClones(characterId: number, datasource?: GetCharactersCharacterIdClonesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdClonesOk> {
            return localVarFp.getCharactersCharacterIdClones(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
         * @summary Get active implants
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdImplantsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdImplants(characterId: number, datasource?: GetCharactersCharacterIdImplantsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getCharactersCharacterIdImplants(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClonesApi - object-oriented interface
 */
export class ClonesApi extends BaseAPI {
    /**
     * A list of the character\'s clones  --- Alternate route: `/dev/characters/{character_id}/clones/`  Alternate route: `/legacy/characters/{character_id}/clones/`  Alternate route: `/v2/characters/{character_id}/clones/`  Alternate route: `/v3/characters/{character_id}/clones/`  Alternate route: `/v4/characters/{character_id}/clones/`  --- This route is cached for up to 120 seconds
     * @summary Get clones
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdClonesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdClones(characterId: number, datasource?: GetCharactersCharacterIdClonesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return ClonesApiFp(this.configuration).getCharactersCharacterIdClones(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return implants on the active clone of a character  --- Alternate route: `/dev/characters/{character_id}/implants/`  Alternate route: `/legacy/characters/{character_id}/implants/`  Alternate route: `/v1/characters/{character_id}/implants/`  Alternate route: `/v2/characters/{character_id}/implants/`  --- This route is cached for up to 120 seconds
     * @summary Get active implants
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdImplantsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdImplants(characterId: number, datasource?: GetCharactersCharacterIdImplantsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return ClonesApiFp(this.configuration).getCharactersCharacterIdImplants(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdClonesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdClonesDatasourceEnum = typeof GetCharactersCharacterIdClonesDatasourceEnum[keyof typeof GetCharactersCharacterIdClonesDatasourceEnum];
export const GetCharactersCharacterIdImplantsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdImplantsDatasourceEnum = typeof GetCharactersCharacterIdImplantsDatasourceEnum[keyof typeof GetCharactersCharacterIdImplantsDatasourceEnum];


/**
 * ContactsApi - axios parameter creator
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/legacy/characters/{character_id}/contacts/`  Alternate route: `/v1/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Delete contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts to delete
         * @param {DeleteCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdContacts: async (characterId: number, contactIds: Array<number>, datasource?: DeleteCharactersCharacterIdContactsDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('deleteCharactersCharacterIdContacts', 'characterId', characterId)
            // verify required parameter 'contactIds' is not null or undefined
            assertParamExists('deleteCharactersCharacterIdContacts', 'contactIds', contactIds)
            const localVarPath = `/characters/{character_id}/contacts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.write_contacts.v1"], configuration)

            if (contactIds) {
                localVarQueryParameter['contact_ids'] = contactIds.join(COLLECTION_FORMATS.csv);
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contacts
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdContacts: async (allianceId: number, datasource?: GetAlliancesAllianceIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'allianceId' is not null or undefined
            assertParamExists('getAlliancesAllianceIdContacts', 'allianceId', allianceId)
            const localVarPath = `/alliances/{alliance_id}/contacts/`
                .replace(`{${"alliance_id"}}`, encodeURIComponent(String(allianceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-alliances.read_contacts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return custom labels for an alliance\'s contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contact labels
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdContactsLabels: async (allianceId: number, datasource?: GetAlliancesAllianceIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'allianceId' is not null or undefined
            assertParamExists('getAlliancesAllianceIdContactsLabels', 'allianceId', allianceId)
            const localVarPath = `/alliances/{alliance_id}/contacts/labels/`
                .replace(`{${"alliance_id"}}`, encodeURIComponent(String(allianceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-alliances.read_contacts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get contacts
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContacts: async (characterId: number, datasource?: GetCharactersCharacterIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdContacts', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/contacts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_contacts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return custom labels for a character\'s contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get contact labels
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContactsLabels: async (characterId: number, datasource?: GetCharactersCharacterIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdContactsLabels', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/contacts/labels/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_contacts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contacts
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContacts: async (corporationId: number, datasource?: GetCorporationsCorporationIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdContacts', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/contacts/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_contacts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return custom labels for a corporation\'s contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contact labels
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContactsLabels: async (corporationId: number, datasource?: GetCorporationsCorporationIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdContactsLabels', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/contacts/labels/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_contacts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Add contacts
         * @param {number} characterId An EVE character ID
         * @param {number} standing Standing for the contact
         * @param {Array<number>} contactIds A list of contacts
         * @param {PostCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the new contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdContacts: async (characterId: number, standing: number, contactIds: Array<number>, datasource?: PostCharactersCharacterIdContactsDatasourceEnum, labelIds?: Array<number>, token?: string, watched?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('postCharactersCharacterIdContacts', 'characterId', characterId)
            // verify required parameter 'standing' is not null or undefined
            assertParamExists('postCharactersCharacterIdContacts', 'standing', standing)
            // verify required parameter 'contactIds' is not null or undefined
            assertParamExists('postCharactersCharacterIdContacts', 'contactIds', contactIds)
            const localVarPath = `/characters/{character_id}/contacts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.write_contacts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (labelIds) {
                localVarQueryParameter['label_ids'] = labelIds.join(COLLECTION_FORMATS.csv);
            }

            if (standing !== undefined) {
                localVarQueryParameter['standing'] = standing;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (watched !== undefined) {
                localVarQueryParameter['watched'] = watched;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Edit contacts
         * @param {number} characterId An EVE character ID
         * @param {number} standing Standing for the contact
         * @param {Array<number>} contactIds A list of contacts
         * @param {PutCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdContacts: async (characterId: number, standing: number, contactIds: Array<number>, datasource?: PutCharactersCharacterIdContactsDatasourceEnum, labelIds?: Array<number>, token?: string, watched?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('putCharactersCharacterIdContacts', 'characterId', characterId)
            // verify required parameter 'standing' is not null or undefined
            assertParamExists('putCharactersCharacterIdContacts', 'standing', standing)
            // verify required parameter 'contactIds' is not null or undefined
            assertParamExists('putCharactersCharacterIdContacts', 'contactIds', contactIds)
            const localVarPath = `/characters/{character_id}/contacts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.write_contacts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (labelIds) {
                localVarQueryParameter['label_ids'] = labelIds.join(COLLECTION_FORMATS.csv);
            }

            if (standing !== undefined) {
                localVarQueryParameter['standing'] = standing;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (watched !== undefined) {
                localVarQueryParameter['watched'] = watched;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/legacy/characters/{character_id}/contacts/`  Alternate route: `/v1/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Delete contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts to delete
         * @param {DeleteCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, datasource?: DeleteCharactersCharacterIdContactsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCharactersCharacterIdContacts(characterId, contactIds, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.deleteCharactersCharacterIdContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contacts
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlliancesAllianceIdContacts(allianceId: number, datasource?: GetAlliancesAllianceIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAlliancesAllianceIdContacts200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlliancesAllianceIdContacts(allianceId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.getAlliancesAllianceIdContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return custom labels for an alliance\'s contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contact labels
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlliancesAllianceIdContactsLabels(allianceId: number, datasource?: GetAlliancesAllianceIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAlliancesAllianceIdContactsLabels200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlliancesAllianceIdContactsLabels(allianceId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.getAlliancesAllianceIdContactsLabels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get contacts
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdContacts(characterId: number, datasource?: GetCharactersCharacterIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdContacts200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdContacts(characterId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.getCharactersCharacterIdContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return custom labels for a character\'s contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get contact labels
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdContactsLabels(characterId: number, datasource?: GetCharactersCharacterIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdContactsLabels200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdContactsLabels(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.getCharactersCharacterIdContactsLabels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contacts
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdContacts(corporationId: number, datasource?: GetCorporationsCorporationIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdContacts200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdContacts(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.getCorporationsCorporationIdContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return custom labels for a corporation\'s contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contact labels
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdContactsLabels(corporationId: number, datasource?: GetCorporationsCorporationIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdContactsLabels200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdContactsLabels(corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.getCorporationsCorporationIdContactsLabels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Add contacts
         * @param {number} characterId An EVE character ID
         * @param {number} standing Standing for the contact
         * @param {Array<number>} contactIds A list of contacts
         * @param {PostCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the new contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCharactersCharacterIdContacts(characterId: number, standing: number, contactIds: Array<number>, datasource?: PostCharactersCharacterIdContactsDatasourceEnum, labelIds?: Array<number>, token?: string, watched?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCharactersCharacterIdContacts(characterId, standing, contactIds, datasource, labelIds, token, watched, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.postCharactersCharacterIdContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Edit contacts
         * @param {number} characterId An EVE character ID
         * @param {number} standing Standing for the contact
         * @param {Array<number>} contactIds A list of contacts
         * @param {PutCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCharactersCharacterIdContacts(characterId: number, standing: number, contactIds: Array<number>, datasource?: PutCharactersCharacterIdContactsDatasourceEnum, labelIds?: Array<number>, token?: string, watched?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCharactersCharacterIdContacts(characterId, standing, contactIds, datasource, labelIds, token, watched, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.putCharactersCharacterIdContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactsApi - factory interface
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/legacy/characters/{character_id}/contacts/`  Alternate route: `/v1/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Delete contacts
         * @param {number} characterId An EVE character ID
         * @param {Array<number>} contactIds A list of contacts to delete
         * @param {DeleteCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, datasource?: DeleteCharactersCharacterIdContactsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCharactersCharacterIdContacts(characterId, contactIds, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contacts
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdContacts(allianceId: number, datasource?: GetAlliancesAllianceIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAlliancesAllianceIdContacts200Ok>> {
            return localVarFp.getAlliancesAllianceIdContacts(allianceId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return custom labels for an alliance\'s contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get alliance contact labels
         * @param {number} allianceId An EVE alliance ID
         * @param {GetAlliancesAllianceIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlliancesAllianceIdContactsLabels(allianceId: number, datasource?: GetAlliancesAllianceIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAlliancesAllianceIdContactsLabels200Ok>> {
            return localVarFp.getAlliancesAllianceIdContactsLabels(allianceId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get contacts
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContacts(characterId: number, datasource?: GetCharactersCharacterIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdContacts200Ok>> {
            return localVarFp.getCharactersCharacterIdContacts(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return custom labels for a character\'s contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get contact labels
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContactsLabels(characterId: number, datasource?: GetCharactersCharacterIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdContactsLabels200Ok>> {
            return localVarFp.getCharactersCharacterIdContactsLabels(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contacts
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContacts(corporationId: number, datasource?: GetCorporationsCorporationIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdContacts200Ok>> {
            return localVarFp.getCorporationsCorporationIdContacts(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return custom labels for a corporation\'s contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contact labels
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContactsLabels(corporationId: number, datasource?: GetCorporationsCorporationIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdContactsLabels200Ok>> {
            return localVarFp.getCorporationsCorporationIdContactsLabels(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Add contacts
         * @param {number} characterId An EVE character ID
         * @param {number} standing Standing for the contact
         * @param {Array<number>} contactIds A list of contacts
         * @param {PostCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the new contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdContacts(characterId: number, standing: number, contactIds: Array<number>, datasource?: PostCharactersCharacterIdContactsDatasourceEnum, labelIds?: Array<number>, token?: string, watched?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.postCharactersCharacterIdContacts(characterId, standing, contactIds, datasource, labelIds, token, watched, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
         * @summary Edit contacts
         * @param {number} characterId An EVE character ID
         * @param {number} standing Standing for the contact
         * @param {Array<number>} contactIds A list of contacts
         * @param {PutCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
         * @param {Array<number>} [labelIds] Add custom labels to the contact
         * @param {string} [token] Access token to use if unable to set a header
         * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdContacts(characterId: number, standing: number, contactIds: Array<number>, datasource?: PutCharactersCharacterIdContactsDatasourceEnum, labelIds?: Array<number>, token?: string, watched?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putCharactersCharacterIdContacts(characterId, standing, contactIds, datasource, labelIds, token, watched, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactsApi - object-oriented interface
 */
export class ContactsApi extends BaseAPI {
    /**
     * Bulk delete contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/legacy/characters/{character_id}/contacts/`  Alternate route: `/v1/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
     * @summary Delete contacts
     * @param {number} characterId An EVE character ID
     * @param {Array<number>} contactIds A list of contacts to delete
     * @param {DeleteCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCharactersCharacterIdContacts(characterId: number, contactIds: Array<number>, datasource?: DeleteCharactersCharacterIdContactsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).deleteCharactersCharacterIdContacts(characterId, contactIds, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return contacts of an alliance  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/`  Alternate route: `/v2/alliances/{alliance_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contacts
     * @param {number} allianceId An EVE alliance ID
     * @param {GetAlliancesAllianceIdContactsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAlliancesAllianceIdContacts(allianceId: number, datasource?: GetAlliancesAllianceIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getAlliancesAllianceIdContacts(allianceId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return custom labels for an alliance\'s contacts  --- Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`  Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get alliance contact labels
     * @param {number} allianceId An EVE alliance ID
     * @param {GetAlliancesAllianceIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAlliancesAllianceIdContactsLabels(allianceId: number, datasource?: GetAlliancesAllianceIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getAlliancesAllianceIdContactsLabels(allianceId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return contacts of a character  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get contacts
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdContacts(characterId: number, datasource?: GetCharactersCharacterIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getCharactersCharacterIdContacts(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return custom labels for a character\'s contacts  --- Alternate route: `/dev/characters/{character_id}/contacts/labels/`  Alternate route: `/legacy/characters/{character_id}/contacts/labels/`  Alternate route: `/v1/characters/{character_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get contact labels
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdContactsLabels(characterId: number, datasource?: GetCharactersCharacterIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getCharactersCharacterIdContactsLabels(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return contacts of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/`  Alternate route: `/v2/corporations/{corporation_id}/contacts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contacts
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdContactsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdContacts(corporationId: number, datasource?: GetCorporationsCorporationIdContactsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getCorporationsCorporationIdContacts(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return custom labels for a corporation\'s contacts  --- Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`  Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contact labels
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdContactsLabelsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdContactsLabels(corporationId: number, datasource?: GetCorporationsCorporationIdContactsLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getCorporationsCorporationIdContactsLabels(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk add contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
     * @summary Add contacts
     * @param {number} characterId An EVE character ID
     * @param {number} standing Standing for the contact
     * @param {Array<number>} contactIds A list of contacts
     * @param {PostCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
     * @param {Array<number>} [labelIds] Add custom labels to the new contact
     * @param {string} [token] Access token to use if unable to set a header
     * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCharactersCharacterIdContacts(characterId: number, standing: number, contactIds: Array<number>, datasource?: PostCharactersCharacterIdContactsDatasourceEnum, labelIds?: Array<number>, token?: string, watched?: boolean, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).postCharactersCharacterIdContacts(characterId, standing, contactIds, datasource, labelIds, token, watched, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk edit contacts with same settings  --- Alternate route: `/dev/characters/{character_id}/contacts/`  Alternate route: `/v2/characters/{character_id}/contacts/` 
     * @summary Edit contacts
     * @param {number} characterId An EVE character ID
     * @param {number} standing Standing for the contact
     * @param {Array<number>} contactIds A list of contacts
     * @param {PutCharactersCharacterIdContactsDatasourceEnum} [datasource] The server name you would like data from
     * @param {Array<number>} [labelIds] Add custom labels to the contact
     * @param {string} [token] Access token to use if unable to set a header
     * @param {boolean} [watched] Whether the contact should be watched, note this is only effective on characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putCharactersCharacterIdContacts(characterId: number, standing: number, contactIds: Array<number>, datasource?: PutCharactersCharacterIdContactsDatasourceEnum, labelIds?: Array<number>, token?: string, watched?: boolean, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).putCharactersCharacterIdContacts(characterId, standing, contactIds, datasource, labelIds, token, watched, options).then((request) => request(this.axios, this.basePath));
    }
}

export const DeleteCharactersCharacterIdContactsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type DeleteCharactersCharacterIdContactsDatasourceEnum = typeof DeleteCharactersCharacterIdContactsDatasourceEnum[keyof typeof DeleteCharactersCharacterIdContactsDatasourceEnum];
export const GetAlliancesAllianceIdContactsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetAlliancesAllianceIdContactsDatasourceEnum = typeof GetAlliancesAllianceIdContactsDatasourceEnum[keyof typeof GetAlliancesAllianceIdContactsDatasourceEnum];
export const GetAlliancesAllianceIdContactsLabelsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetAlliancesAllianceIdContactsLabelsDatasourceEnum = typeof GetAlliancesAllianceIdContactsLabelsDatasourceEnum[keyof typeof GetAlliancesAllianceIdContactsLabelsDatasourceEnum];
export const GetCharactersCharacterIdContactsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdContactsDatasourceEnum = typeof GetCharactersCharacterIdContactsDatasourceEnum[keyof typeof GetCharactersCharacterIdContactsDatasourceEnum];
export const GetCharactersCharacterIdContactsLabelsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdContactsLabelsDatasourceEnum = typeof GetCharactersCharacterIdContactsLabelsDatasourceEnum[keyof typeof GetCharactersCharacterIdContactsLabelsDatasourceEnum];
export const GetCorporationsCorporationIdContactsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdContactsDatasourceEnum = typeof GetCorporationsCorporationIdContactsDatasourceEnum[keyof typeof GetCorporationsCorporationIdContactsDatasourceEnum];
export const GetCorporationsCorporationIdContactsLabelsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdContactsLabelsDatasourceEnum = typeof GetCorporationsCorporationIdContactsLabelsDatasourceEnum[keyof typeof GetCorporationsCorporationIdContactsLabelsDatasourceEnum];
export const PostCharactersCharacterIdContactsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostCharactersCharacterIdContactsDatasourceEnum = typeof PostCharactersCharacterIdContactsDatasourceEnum[keyof typeof PostCharactersCharacterIdContactsDatasourceEnum];
export const PutCharactersCharacterIdContactsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PutCharactersCharacterIdContactsDatasourceEnum = typeof PutCharactersCharacterIdContactsDatasourceEnum[keyof typeof PutCharactersCharacterIdContactsDatasourceEnum];


/**
 * ContractsApi - axios parameter creator
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get contracts
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdContractsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContracts: async (characterId: number, datasource?: GetCharactersCharacterIdContractsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdContracts', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/contracts/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-contracts.read_character_contracts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
         * @summary Get contract bids
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContractsContractIdBids: async (characterId: number, contractId: number, datasource?: GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdContractsContractIdBids', 'characterId', characterId)
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getCharactersCharacterIdContractsContractIdBids', 'contractId', contractId)
            const localVarPath = `/characters/{character_id}/contracts/{contract_id}/bids/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-contracts.read_character_contracts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get contract items
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContractsContractIdItems: async (characterId: number, contractId: number, datasource?: GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdContractsContractIdItems', 'characterId', characterId)
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getCharactersCharacterIdContractsContractIdItems', 'contractId', contractId)
            const localVarPath = `/characters/{character_id}/contracts/{contract_id}/items/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-contracts.read_character_contracts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
         * @summary Get public contract bids
         * @param {number} contractId ID of a contract
         * @param {GetContractsPublicBidsContractIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicBidsContractId: async (contractId: number, datasource?: GetContractsPublicBidsContractIdDatasourceEnum, ifNoneMatch?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getContractsPublicBidsContractId', 'contractId', contractId)
            const localVarPath = `/contracts/public/bids/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get public contract items
         * @param {number} contractId ID of a contract
         * @param {GetContractsPublicItemsContractIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicItemsContractId: async (contractId: number, datasource?: GetContractsPublicItemsContractIdDatasourceEnum, ifNoneMatch?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getContractsPublicItemsContractId', 'contractId', contractId)
            const localVarPath = `/contracts/public/items/{contract_id}/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
         * @summary Get public contracts
         * @param {number} regionId An EVE region id
         * @param {GetContractsPublicRegionIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicRegionId: async (regionId: number, datasource?: GetContractsPublicRegionIdDatasourceEnum, ifNoneMatch?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('getContractsPublicRegionId', 'regionId', regionId)
            const localVarPath = `/contracts/public/{region_id}/`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contracts
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContractsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContracts: async (corporationId: number, datasource?: GetCorporationsCorporationIdContractsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdContracts', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/contracts/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-contracts.read_corporation_contracts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract bids
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContractsContractIdBids: async (contractId: number, corporationId: number, datasource?: GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdContractsContractIdBids', 'contractId', contractId)
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdContractsContractIdBids', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/contracts/{contract_id}/bids/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-contracts.read_corporation_contracts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract items
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContractsContractIdItems: async (contractId: number, corporationId: number, datasource?: GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdContractsContractIdItems', 'contractId', contractId)
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdContractsContractIdItems', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/contracts/{contract_id}/items/`
                .replace(`{${"contract_id"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-contracts.read_corporation_contracts.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsApi - functional programming interface
 */
export const ContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get contracts
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdContractsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdContracts(characterId: number, datasource?: GetCharactersCharacterIdContractsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdContracts200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdContracts(characterId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.getCharactersCharacterIdContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
         * @summary Get contract bids
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdContractsContractIdBids(characterId: number, contractId: number, datasource?: GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdContractsContractIdBids200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdContractsContractIdBids(characterId, contractId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.getCharactersCharacterIdContractsContractIdBids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get contract items
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdContractsContractIdItems(characterId: number, contractId: number, datasource?: GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdContractsContractIdItems200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdContractsContractIdItems(characterId, contractId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.getCharactersCharacterIdContractsContractIdItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
         * @summary Get public contract bids
         * @param {number} contractId ID of a contract
         * @param {GetContractsPublicBidsContractIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractsPublicBidsContractId(contractId: number, datasource?: GetContractsPublicBidsContractIdDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetContractsPublicBidsContractId200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractsPublicBidsContractId(contractId, datasource, ifNoneMatch, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.getContractsPublicBidsContractId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get public contract items
         * @param {number} contractId ID of a contract
         * @param {GetContractsPublicItemsContractIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractsPublicItemsContractId(contractId: number, datasource?: GetContractsPublicItemsContractIdDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetContractsPublicItemsContractId200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractsPublicItemsContractId(contractId, datasource, ifNoneMatch, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.getContractsPublicItemsContractId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
         * @summary Get public contracts
         * @param {number} regionId An EVE region id
         * @param {GetContractsPublicRegionIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractsPublicRegionId(regionId: number, datasource?: GetContractsPublicRegionIdDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetContractsPublicRegionId200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractsPublicRegionId(regionId, datasource, ifNoneMatch, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.getContractsPublicRegionId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contracts
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContractsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdContracts(corporationId: number, datasource?: GetCorporationsCorporationIdContractsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdContracts200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdContracts(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.getCorporationsCorporationIdContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract bids
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdContractsContractIdBids(contractId: number, corporationId: number, datasource?: GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdContractsContractIdBids200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdContractsContractIdBids(contractId, corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.getCorporationsCorporationIdContractsContractIdBids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract items
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdContractsContractIdItems(contractId: number, corporationId: number, datasource?: GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdContractsContractIdItems200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdContractsContractIdItems(contractId, corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContractsApi.getCorporationsCorporationIdContractsContractIdItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContractsApi - factory interface
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsApiFp(configuration)
    return {
        /**
         * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get contracts
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdContractsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContracts(characterId: number, datasource?: GetCharactersCharacterIdContractsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdContracts200Ok>> {
            return localVarFp.getCharactersCharacterIdContracts(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
         * @summary Get contract bids
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContractsContractIdBids(characterId: number, contractId: number, datasource?: GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdContractsContractIdBids200Ok>> {
            return localVarFp.getCharactersCharacterIdContractsContractIdBids(characterId, contractId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get contract items
         * @param {number} characterId An EVE character ID
         * @param {number} contractId ID of a contract
         * @param {GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdContractsContractIdItems(characterId: number, contractId: number, datasource?: GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdContractsContractIdItems200Ok>> {
            return localVarFp.getCharactersCharacterIdContractsContractIdItems(characterId, contractId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
         * @summary Get public contract bids
         * @param {number} contractId ID of a contract
         * @param {GetContractsPublicBidsContractIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicBidsContractId(contractId: number, datasource?: GetContractsPublicBidsContractIdDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetContractsPublicBidsContractId200Ok>> {
            return localVarFp.getContractsPublicBidsContractId(contractId, datasource, ifNoneMatch, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get public contract items
         * @param {number} contractId ID of a contract
         * @param {GetContractsPublicItemsContractIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicItemsContractId(contractId: number, datasource?: GetContractsPublicItemsContractIdDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetContractsPublicItemsContractId200Ok>> {
            return localVarFp.getContractsPublicItemsContractId(contractId, datasource, ifNoneMatch, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
         * @summary Get public contracts
         * @param {number} regionId An EVE region id
         * @param {GetContractsPublicRegionIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractsPublicRegionId(regionId: number, datasource?: GetContractsPublicRegionIdDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetContractsPublicRegionId200Ok>> {
            return localVarFp.getContractsPublicRegionId(regionId, datasource, ifNoneMatch, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
         * @summary Get corporation contracts
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContractsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContracts(corporationId: number, datasource?: GetCorporationsCorporationIdContractsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdContracts200Ok>> {
            return localVarFp.getCorporationsCorporationIdContracts(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract bids
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContractsContractIdBids(contractId: number, corporationId: number, datasource?: GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdContractsContractIdBids200Ok>> {
            return localVarFp.getCorporationsCorporationIdContractsContractIdBids(contractId, corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation contract items
         * @param {number} contractId ID of a contract
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContractsContractIdItems(contractId: number, corporationId: number, datasource?: GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdContractsContractIdItems200Ok>> {
            return localVarFp.getCorporationsCorporationIdContractsContractIdItems(contractId, corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractsApi - object-oriented interface
 */
export class ContractsApi extends BaseAPI {
    /**
     * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/characters/{character_id}/contracts/`  Alternate route: `/legacy/characters/{character_id}/contracts/`  Alternate route: `/v1/characters/{character_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get contracts
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdContractsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdContracts(characterId: number, datasource?: GetCharactersCharacterIdContractsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getCharactersCharacterIdContracts(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 300 seconds
     * @summary Get contract bids
     * @param {number} characterId An EVE character ID
     * @param {number} contractId ID of a contract
     * @param {GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdContractsContractIdBids(characterId: number, contractId: number, datasource?: GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getCharactersCharacterIdContractsContractIdBids(characterId, contractId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get contract items
     * @param {number} characterId An EVE character ID
     * @param {number} contractId ID of a contract
     * @param {GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdContractsContractIdItems(characterId: number, contractId: number, datasource?: GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getCharactersCharacterIdContractsContractIdItems(characterId, contractId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists bids on a public auction contract  --- Alternate route: `/dev/contracts/public/bids/{contract_id}/`  Alternate route: `/legacy/contracts/public/bids/{contract_id}/`  Alternate route: `/v1/contracts/public/bids/{contract_id}/`  --- This route is cached for up to 300 seconds
     * @summary Get public contract bids
     * @param {number} contractId ID of a contract
     * @param {GetContractsPublicBidsContractIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getContractsPublicBidsContractId(contractId: number, datasource?: GetContractsPublicBidsContractIdDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getContractsPublicBidsContractId(contractId, datasource, ifNoneMatch, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists items of a public contract  --- Alternate route: `/dev/contracts/public/items/{contract_id}/`  Alternate route: `/legacy/contracts/public/items/{contract_id}/`  Alternate route: `/v1/contracts/public/items/{contract_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get public contract items
     * @param {number} contractId ID of a contract
     * @param {GetContractsPublicItemsContractIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getContractsPublicItemsContractId(contractId: number, datasource?: GetContractsPublicItemsContractIdDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getContractsPublicItemsContractId(contractId, datasource, ifNoneMatch, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all public contracts in the given region  --- Alternate route: `/dev/contracts/public/{region_id}/`  Alternate route: `/legacy/contracts/public/{region_id}/`  Alternate route: `/v1/contracts/public/{region_id}/`  --- This route is cached for up to 1800 seconds
     * @summary Get public contracts
     * @param {number} regionId An EVE region id
     * @param {GetContractsPublicRegionIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getContractsPublicRegionId(regionId: number, datasource?: GetContractsPublicRegionIdDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getContractsPublicRegionId(regionId, datasource, ifNoneMatch, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is \"in_progress\".  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/`  --- This route is cached for up to 300 seconds
     * @summary Get corporation contracts
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdContractsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdContracts(corporationId: number, datasource?: GetCorporationsCorporationIdContractsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getCorporationsCorporationIdContracts(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists bids on a particular auction contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract bids
     * @param {number} contractId ID of a contract
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdContractsContractIdBids(contractId: number, corporationId: number, datasource?: GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getCorporationsCorporationIdContractsContractIdBids(contractId, corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists items of a particular contract  --- Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`  Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation contract items
     * @param {number} contractId ID of a contract
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdContractsContractIdItems(contractId: number, corporationId: number, datasource?: GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getCorporationsCorporationIdContractsContractIdItems(contractId, corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdContractsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdContractsDatasourceEnum = typeof GetCharactersCharacterIdContractsDatasourceEnum[keyof typeof GetCharactersCharacterIdContractsDatasourceEnum];
export const GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum = typeof GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum[keyof typeof GetCharactersCharacterIdContractsContractIdBidsDatasourceEnum];
export const GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum = typeof GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum[keyof typeof GetCharactersCharacterIdContractsContractIdItemsDatasourceEnum];
export const GetContractsPublicBidsContractIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetContractsPublicBidsContractIdDatasourceEnum = typeof GetContractsPublicBidsContractIdDatasourceEnum[keyof typeof GetContractsPublicBidsContractIdDatasourceEnum];
export const GetContractsPublicItemsContractIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetContractsPublicItemsContractIdDatasourceEnum = typeof GetContractsPublicItemsContractIdDatasourceEnum[keyof typeof GetContractsPublicItemsContractIdDatasourceEnum];
export const GetContractsPublicRegionIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetContractsPublicRegionIdDatasourceEnum = typeof GetContractsPublicRegionIdDatasourceEnum[keyof typeof GetContractsPublicRegionIdDatasourceEnum];
export const GetCorporationsCorporationIdContractsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdContractsDatasourceEnum = typeof GetCorporationsCorporationIdContractsDatasourceEnum[keyof typeof GetCorporationsCorporationIdContractsDatasourceEnum];
export const GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum = typeof GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum[keyof typeof GetCorporationsCorporationIdContractsContractIdBidsDatasourceEnum];
export const GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum = typeof GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum[keyof typeof GetCorporationsCorporationIdContractsContractIdItemsDatasourceEnum];


/**
 * CorporationApi - axios parameter creator
 */
export const CorporationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/legacy/corporations/{corporation_id}/`  Alternate route: `/v4/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation information
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationId: async (corporationId: number, datasource?: GetCorporationsCorporationIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationId', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/legacy/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v2/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance history
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdAlliancehistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdAlliancehistory: async (corporationId: number, datasource?: GetCorporationsCorporationIdAlliancehistoryDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdAlliancehistory', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/alliancehistory/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/legacy/corporations/{corporation_id}/blueprints/`  Alternate route: `/v2/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation blueprints
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdBlueprintsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdBlueprints: async (corporationId: number, datasource?: GetCorporationsCorporationIdBlueprintsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdBlueprints', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/blueprints/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_blueprints.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/legacy/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v2/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get all corporation ALSC logs
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContainersLogsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContainersLogs: async (corporationId: number, datasource?: GetCorporationsCorporationIdContainersLogsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdContainersLogs', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/containers/logs/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_container_logs.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/legacy/corporations/{corporation_id}/divisions/`  Alternate route: `/v1/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation divisions
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdDivisionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdDivisions: async (corporationId: number, datasource?: GetCorporationsCorporationIdDivisionsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdDivisions', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/divisions/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_divisions.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a corporation\'s facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/legacy/corporations/{corporation_id}/facilities/`  Alternate route: `/v1/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary Get corporation facilities
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdFacilitiesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdFacilities: async (corporationId: number, datasource?: GetCorporationsCorporationIdFacilitiesDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdFacilities', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/facilities/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_facilities.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/legacy/corporations/{corporation_id}/icons/`  Alternate route: `/v1/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation icon
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdIconsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdIcons: async (corporationId: number, datasource?: GetCorporationsCorporationIdIconsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdIcons', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/icons/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a corporation\'s medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/legacy/corporations/{corporation_id}/medals/`  Alternate route: `/v1/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation medals
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMedalsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMedals: async (corporationId: number, datasource?: GetCorporationsCorporationIdMedalsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdMedals', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/medals/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_medals.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/legacy/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v1/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation issued medals
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMedalsIssuedDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMedalsIssued: async (corporationId: number, datasource?: GetCorporationsCorporationIdMedalsIssuedDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdMedalsIssued', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/medals/issued/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_medals.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the current member list of a corporation, the token\'s character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/legacy/corporations/{corporation_id}/members/`  Alternate route: `/v3/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembers: async (corporationId: number, datasource?: GetCorporationsCorporationIdMembersDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdMembers', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/members/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_corporation_membership.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a corporation\'s member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/legacy/corporations/{corporation_id}/members/limit/`  Alternate route: `/v1/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member limit
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembersLimitDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembersLimit: async (corporationId: number, datasource?: GetCorporationsCorporationIdMembersLimitDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdMembersLimit', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/members/limit/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.track_members.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a corporation\'s members\' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/legacy/corporations/{corporation_id}/members/titles/`  Alternate route: `/v1/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation\'s members\' titles
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembersTitlesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembersTitles: async (corporationId: number, datasource?: GetCorporationsCorporationIdMembersTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdMembersTitles', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/members/titles/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_titles.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns additional information about a corporation\'s members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/legacy/corporations/{corporation_id}/membertracking/`  Alternate route: `/v1/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Track corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembertrackingDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembertracking: async (corporationId: number, datasource?: GetCorporationsCorporationIdMembertrackingDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdMembertracking', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/membertracking/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.track_members.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/legacy/corporations/{corporation_id}/roles/`  Alternate route: `/v1/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation member roles
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdRolesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdRoles: async (corporationId: number, datasource?: GetCorporationsCorporationIdRolesDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdRoles', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/roles/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_corporation_membership.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return how roles have changed for a coporation\'s members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/legacy/corporations/{corporation_id}/roles/history/`  Alternate route: `/v1/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member roles history
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdRolesHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdRolesHistory: async (corporationId: number, datasource?: GetCorporationsCorporationIdRolesHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdRolesHistory', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/roles/history/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_corporation_membership.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation shareholders
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdShareholdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdShareholders: async (corporationId: number, datasource?: GetCorporationsCorporationIdShareholdersDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdShareholders', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/shareholders/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-wallet.read_corporation_wallets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/legacy/corporations/{corporation_id}/standings/`  Alternate route: `/v1/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation standings
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdStandingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStandings: async (corporationId: number, datasource?: GetCorporationsCorporationIdStandingsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdStandings', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/standings/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_standings.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/legacy/corporations/{corporation_id}/starbases/`  Alternate route: `/v1/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation starbases (POSes)
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdStarbasesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStarbases: async (corporationId: number, datasource?: GetCorporationsCorporationIdStarbasesDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdStarbases', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/starbases/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_starbases.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/legacy/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v1/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get starbase (POS) detail
         * @param {number} corporationId An EVE corporation ID
         * @param {number} starbaseId An EVE starbase (POS) ID
         * @param {number} systemId The solar system this starbase (POS) is located in,
         * @param {GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStarbasesStarbaseId: async (corporationId: number, starbaseId: number, systemId: number, datasource?: GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdStarbasesStarbaseId', 'corporationId', corporationId)
            // verify required parameter 'starbaseId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdStarbasesStarbaseId', 'starbaseId', starbaseId)
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdStarbasesStarbaseId', 'systemId', systemId)
            const localVarPath = `/corporations/{corporation_id}/starbases/{starbase_id}/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)))
                .replace(`{${"starbase_id"}}`, encodeURIComponent(String(starbaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_starbases.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (systemId !== undefined) {
                localVarQueryParameter['system_id'] = systemId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of corporation structures. This route\'s version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Get corporation structures
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdStructuresAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetCorporationsCorporationIdStructuresDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetCorporationsCorporationIdStructuresLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStructures: async (corporationId: number, acceptLanguage?: GetCorporationsCorporationIdStructuresAcceptLanguageEnum, datasource?: GetCorporationsCorporationIdStructuresDatasourceEnum, ifNoneMatch?: string, language?: GetCorporationsCorporationIdStructuresLanguageEnum, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdStructures', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/structures/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_structures.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a corporation\'s titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/legacy/corporations/{corporation_id}/titles/`  Alternate route: `/v1/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation titles
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdTitlesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdTitles: async (corporationId: number, datasource?: GetCorporationsCorporationIdTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdTitles', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/titles/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_titles.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/legacy/corporations/npccorps/`  Alternate route: `/v1/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
         * @summary Get npc corporations
         * @param {GetCorporationsNpccorpsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsNpccorps: async (datasource?: GetCorporationsNpccorpsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/corporations/npccorps/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CorporationApi - functional programming interface
 */
export const CorporationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CorporationApiAxiosParamCreator(configuration)
    return {
        /**
         * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/legacy/corporations/{corporation_id}/`  Alternate route: `/v4/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation information
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationId(corporationId: number, datasource?: GetCorporationsCorporationIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCorporationsCorporationIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationId(corporationId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/legacy/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v2/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance history
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdAlliancehistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdAlliancehistory(corporationId: number, datasource?: GetCorporationsCorporationIdAlliancehistoryDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdAlliancehistory200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdAlliancehistory(corporationId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdAlliancehistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/legacy/corporations/{corporation_id}/blueprints/`  Alternate route: `/v2/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation blueprints
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdBlueprintsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdBlueprints(corporationId: number, datasource?: GetCorporationsCorporationIdBlueprintsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdBlueprints200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdBlueprints(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdBlueprints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/legacy/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v2/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get all corporation ALSC logs
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContainersLogsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdContainersLogs(corporationId: number, datasource?: GetCorporationsCorporationIdContainersLogsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdContainersLogs200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdContainersLogs(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdContainersLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/legacy/corporations/{corporation_id}/divisions/`  Alternate route: `/v1/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation divisions
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdDivisionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdDivisions(corporationId: number, datasource?: GetCorporationsCorporationIdDivisionsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCorporationsCorporationIdDivisionsOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdDivisions(corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdDivisions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a corporation\'s facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/legacy/corporations/{corporation_id}/facilities/`  Alternate route: `/v1/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary Get corporation facilities
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdFacilitiesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdFacilities(corporationId: number, datasource?: GetCorporationsCorporationIdFacilitiesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdFacilities200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdFacilities(corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdFacilities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/legacy/corporations/{corporation_id}/icons/`  Alternate route: `/v1/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation icon
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdIconsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdIcons(corporationId: number, datasource?: GetCorporationsCorporationIdIconsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCorporationsCorporationIdIconsOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdIcons(corporationId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdIcons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a corporation\'s medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/legacy/corporations/{corporation_id}/medals/`  Alternate route: `/v1/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation medals
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMedalsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdMedals(corporationId: number, datasource?: GetCorporationsCorporationIdMedalsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdMedals200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdMedals(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdMedals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/legacy/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v1/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation issued medals
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMedalsIssuedDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdMedalsIssued(corporationId: number, datasource?: GetCorporationsCorporationIdMedalsIssuedDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdMedalsIssued200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdMedalsIssued(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdMedalsIssued']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the current member list of a corporation, the token\'s character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/legacy/corporations/{corporation_id}/members/`  Alternate route: `/v3/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdMembers(corporationId: number, datasource?: GetCorporationsCorporationIdMembersDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdMembers(corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a corporation\'s member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/legacy/corporations/{corporation_id}/members/limit/`  Alternate route: `/v1/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member limit
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembersLimitDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdMembersLimit(corporationId: number, datasource?: GetCorporationsCorporationIdMembersLimitDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdMembersLimit(corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdMembersLimit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a corporation\'s members\' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/legacy/corporations/{corporation_id}/members/titles/`  Alternate route: `/v1/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation\'s members\' titles
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembersTitlesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdMembersTitles(corporationId: number, datasource?: GetCorporationsCorporationIdMembersTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdMembersTitles200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdMembersTitles(corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdMembersTitles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns additional information about a corporation\'s members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/legacy/corporations/{corporation_id}/membertracking/`  Alternate route: `/v1/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Track corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembertrackingDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdMembertracking(corporationId: number, datasource?: GetCorporationsCorporationIdMembertrackingDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdMembertracking200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdMembertracking(corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdMembertracking']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/legacy/corporations/{corporation_id}/roles/`  Alternate route: `/v1/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation member roles
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdRolesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdRoles(corporationId: number, datasource?: GetCorporationsCorporationIdRolesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdRoles200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdRoles(corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return how roles have changed for a coporation\'s members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/legacy/corporations/{corporation_id}/roles/history/`  Alternate route: `/v1/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member roles history
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdRolesHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdRolesHistory(corporationId: number, datasource?: GetCorporationsCorporationIdRolesHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdRolesHistory200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdRolesHistory(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdRolesHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation shareholders
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdShareholdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdShareholders(corporationId: number, datasource?: GetCorporationsCorporationIdShareholdersDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdShareholders200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdShareholders(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdShareholders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/legacy/corporations/{corporation_id}/standings/`  Alternate route: `/v1/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation standings
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdStandingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdStandings(corporationId: number, datasource?: GetCorporationsCorporationIdStandingsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdStandings200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdStandings(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdStandings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/legacy/corporations/{corporation_id}/starbases/`  Alternate route: `/v1/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation starbases (POSes)
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdStarbasesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdStarbases(corporationId: number, datasource?: GetCorporationsCorporationIdStarbasesDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdStarbases200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdStarbases(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdStarbases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/legacy/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v1/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get starbase (POS) detail
         * @param {number} corporationId An EVE corporation ID
         * @param {number} starbaseId An EVE starbase (POS) ID
         * @param {number} systemId The solar system this starbase (POS) is located in,
         * @param {GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdStarbasesStarbaseId(corporationId: number, starbaseId: number, systemId: number, datasource?: GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCorporationsCorporationIdStarbasesStarbaseIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdStarbasesStarbaseId(corporationId, starbaseId, systemId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdStarbasesStarbaseId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of corporation structures. This route\'s version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Get corporation structures
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdStructuresAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetCorporationsCorporationIdStructuresDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetCorporationsCorporationIdStructuresLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdStructures(corporationId: number, acceptLanguage?: GetCorporationsCorporationIdStructuresAcceptLanguageEnum, datasource?: GetCorporationsCorporationIdStructuresDatasourceEnum, ifNoneMatch?: string, language?: GetCorporationsCorporationIdStructuresLanguageEnum, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdStructures200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdStructures(corporationId, acceptLanguage, datasource, ifNoneMatch, language, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdStructures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a corporation\'s titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/legacy/corporations/{corporation_id}/titles/`  Alternate route: `/v1/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation titles
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdTitlesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdTitles(corporationId: number, datasource?: GetCorporationsCorporationIdTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdTitles200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdTitles(corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsCorporationIdTitles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/legacy/corporations/npccorps/`  Alternate route: `/v1/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
         * @summary Get npc corporations
         * @param {GetCorporationsNpccorpsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsNpccorps(datasource?: GetCorporationsNpccorpsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsNpccorps(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorporationApi.getCorporationsNpccorps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CorporationApi - factory interface
 */
export const CorporationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CorporationApiFp(configuration)
    return {
        /**
         * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/legacy/corporations/{corporation_id}/`  Alternate route: `/v4/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation information
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationId(corporationId: number, datasource?: GetCorporationsCorporationIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCorporationsCorporationIdOk> {
            return localVarFp.getCorporationsCorporationId(corporationId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/legacy/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v2/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
         * @summary Get alliance history
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdAlliancehistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdAlliancehistory(corporationId: number, datasource?: GetCorporationsCorporationIdAlliancehistoryDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdAlliancehistory200Ok>> {
            return localVarFp.getCorporationsCorporationIdAlliancehistory(corporationId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/legacy/corporations/{corporation_id}/blueprints/`  Alternate route: `/v2/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation blueprints
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdBlueprintsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdBlueprints(corporationId: number, datasource?: GetCorporationsCorporationIdBlueprintsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdBlueprints200Ok>> {
            return localVarFp.getCorporationsCorporationIdBlueprints(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/legacy/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v2/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get all corporation ALSC logs
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdContainersLogsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdContainersLogs(corporationId: number, datasource?: GetCorporationsCorporationIdContainersLogsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdContainersLogs200Ok>> {
            return localVarFp.getCorporationsCorporationIdContainersLogs(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/legacy/corporations/{corporation_id}/divisions/`  Alternate route: `/v1/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation divisions
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdDivisionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdDivisions(corporationId: number, datasource?: GetCorporationsCorporationIdDivisionsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCorporationsCorporationIdDivisionsOk> {
            return localVarFp.getCorporationsCorporationIdDivisions(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a corporation\'s facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/legacy/corporations/{corporation_id}/facilities/`  Alternate route: `/v1/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary Get corporation facilities
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdFacilitiesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdFacilities(corporationId: number, datasource?: GetCorporationsCorporationIdFacilitiesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdFacilities200Ok>> {
            return localVarFp.getCorporationsCorporationIdFacilities(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/legacy/corporations/{corporation_id}/icons/`  Alternate route: `/v1/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation icon
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdIconsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdIcons(corporationId: number, datasource?: GetCorporationsCorporationIdIconsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCorporationsCorporationIdIconsOk> {
            return localVarFp.getCorporationsCorporationIdIcons(corporationId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a corporation\'s medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/legacy/corporations/{corporation_id}/medals/`  Alternate route: `/v1/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation medals
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMedalsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMedals(corporationId: number, datasource?: GetCorporationsCorporationIdMedalsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdMedals200Ok>> {
            return localVarFp.getCorporationsCorporationIdMedals(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/legacy/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v1/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation issued medals
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMedalsIssuedDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMedalsIssued(corporationId: number, datasource?: GetCorporationsCorporationIdMedalsIssuedDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdMedalsIssued200Ok>> {
            return localVarFp.getCorporationsCorporationIdMedalsIssued(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the current member list of a corporation, the token\'s character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/legacy/corporations/{corporation_id}/members/`  Alternate route: `/v3/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembers(corporationId: number, datasource?: GetCorporationsCorporationIdMembersDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getCorporationsCorporationIdMembers(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a corporation\'s member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/legacy/corporations/{corporation_id}/members/limit/`  Alternate route: `/v1/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member limit
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembersLimitDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembersLimit(corporationId: number, datasource?: GetCorporationsCorporationIdMembersLimitDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getCorporationsCorporationIdMembersLimit(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a corporation\'s members\' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/legacy/corporations/{corporation_id}/members/titles/`  Alternate route: `/v1/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation\'s members\' titles
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembersTitlesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembersTitles(corporationId: number, datasource?: GetCorporationsCorporationIdMembersTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdMembersTitles200Ok>> {
            return localVarFp.getCorporationsCorporationIdMembersTitles(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns additional information about a corporation\'s members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/legacy/corporations/{corporation_id}/membertracking/`  Alternate route: `/v1/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Track corporation members
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdMembertrackingDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdMembertracking(corporationId: number, datasource?: GetCorporationsCorporationIdMembertrackingDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdMembertracking200Ok>> {
            return localVarFp.getCorporationsCorporationIdMembertracking(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/legacy/corporations/{corporation_id}/roles/`  Alternate route: `/v1/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation member roles
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdRolesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdRoles(corporationId: number, datasource?: GetCorporationsCorporationIdRolesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdRoles200Ok>> {
            return localVarFp.getCorporationsCorporationIdRoles(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return how roles have changed for a coporation\'s members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/legacy/corporations/{corporation_id}/roles/history/`  Alternate route: `/v1/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation member roles history
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdRolesHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdRolesHistory(corporationId: number, datasource?: GetCorporationsCorporationIdRolesHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdRolesHistory200Ok>> {
            return localVarFp.getCorporationsCorporationIdRolesHistory(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation shareholders
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdShareholdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdShareholders(corporationId: number, datasource?: GetCorporationsCorporationIdShareholdersDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdShareholders200Ok>> {
            return localVarFp.getCorporationsCorporationIdShareholders(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/legacy/corporations/{corporation_id}/standings/`  Alternate route: `/v1/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
         * @summary Get corporation standings
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdStandingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStandings(corporationId: number, datasource?: GetCorporationsCorporationIdStandingsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdStandings200Ok>> {
            return localVarFp.getCorporationsCorporationIdStandings(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/legacy/corporations/{corporation_id}/starbases/`  Alternate route: `/v1/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation starbases (POSes)
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdStarbasesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStarbases(corporationId: number, datasource?: GetCorporationsCorporationIdStarbasesDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdStarbases200Ok>> {
            return localVarFp.getCorporationsCorporationIdStarbases(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/legacy/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v1/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get starbase (POS) detail
         * @param {number} corporationId An EVE corporation ID
         * @param {number} starbaseId An EVE starbase (POS) ID
         * @param {number} systemId The solar system this starbase (POS) is located in,
         * @param {GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStarbasesStarbaseId(corporationId: number, starbaseId: number, systemId: number, datasource?: GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCorporationsCorporationIdStarbasesStarbaseIdOk> {
            return localVarFp.getCorporationsCorporationIdStarbasesStarbaseId(corporationId, starbaseId, systemId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of corporation structures. This route\'s version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Get corporation structures
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdStructuresAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetCorporationsCorporationIdStructuresDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetCorporationsCorporationIdStructuresLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdStructures(corporationId: number, acceptLanguage?: GetCorporationsCorporationIdStructuresAcceptLanguageEnum, datasource?: GetCorporationsCorporationIdStructuresDatasourceEnum, ifNoneMatch?: string, language?: GetCorporationsCorporationIdStructuresLanguageEnum, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdStructures200Ok>> {
            return localVarFp.getCorporationsCorporationIdStructures(corporationId, acceptLanguage, datasource, ifNoneMatch, language, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a corporation\'s titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/legacy/corporations/{corporation_id}/titles/`  Alternate route: `/v1/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get corporation titles
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdTitlesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdTitles(corporationId: number, datasource?: GetCorporationsCorporationIdTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdTitles200Ok>> {
            return localVarFp.getCorporationsCorporationIdTitles(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/legacy/corporations/npccorps/`  Alternate route: `/v1/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
         * @summary Get npc corporations
         * @param {GetCorporationsNpccorpsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsNpccorps(datasource?: GetCorporationsNpccorpsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getCorporationsNpccorps(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CorporationApi - object-oriented interface
 */
export class CorporationApi extends BaseAPI {
    /**
     * Public information about a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/`  Alternate route: `/legacy/corporations/{corporation_id}/`  Alternate route: `/v4/corporations/{corporation_id}/`  Alternate route: `/v5/corporations/{corporation_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation information
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationId(corporationId: number, datasource?: GetCorporationsCorporationIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationId(corporationId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all the alliances a corporation has been a member of  --- Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/legacy/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v2/corporations/{corporation_id}/alliancehistory/`  Alternate route: `/v3/corporations/{corporation_id}/alliancehistory/`  --- This route is cached for up to 3600 seconds
     * @summary Get alliance history
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdAlliancehistoryDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdAlliancehistory(corporationId: number, datasource?: GetCorporationsCorporationIdAlliancehistoryDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdAlliancehistory(corporationId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of blueprints the corporation owns  --- Alternate route: `/dev/corporations/{corporation_id}/blueprints/`  Alternate route: `/legacy/corporations/{corporation_id}/blueprints/`  Alternate route: `/v2/corporations/{corporation_id}/blueprints/`  Alternate route: `/v3/corporations/{corporation_id}/blueprints/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation blueprints
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdBlueprintsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdBlueprints(corporationId: number, datasource?: GetCorporationsCorporationIdBlueprintsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdBlueprints(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation  --- Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`  Alternate route: `/legacy/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v2/corporations/{corporation_id}/containers/logs/`  Alternate route: `/v3/corporations/{corporation_id}/containers/logs/`  --- This route is cached for up to 600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get all corporation ALSC logs
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdContainersLogsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdContainersLogs(corporationId: number, datasource?: GetCorporationsCorporationIdContainersLogsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdContainersLogs(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return corporation hangar and wallet division names, only show if a division is not using the default name  --- Alternate route: `/dev/corporations/{corporation_id}/divisions/`  Alternate route: `/legacy/corporations/{corporation_id}/divisions/`  Alternate route: `/v1/corporations/{corporation_id}/divisions/`  Alternate route: `/v2/corporations/{corporation_id}/divisions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation divisions
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdDivisionsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdDivisions(corporationId: number, datasource?: GetCorporationsCorporationIdDivisionsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdDivisions(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a corporation\'s facilities  --- Alternate route: `/dev/corporations/{corporation_id}/facilities/`  Alternate route: `/legacy/corporations/{corporation_id}/facilities/`  Alternate route: `/v1/corporations/{corporation_id}/facilities/`  Alternate route: `/v2/corporations/{corporation_id}/facilities/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
     * @summary Get corporation facilities
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdFacilitiesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdFacilities(corporationId: number, datasource?: GetCorporationsCorporationIdFacilitiesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdFacilities(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the icon urls for a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/icons/`  Alternate route: `/legacy/corporations/{corporation_id}/icons/`  Alternate route: `/v1/corporations/{corporation_id}/icons/`  Alternate route: `/v2/corporations/{corporation_id}/icons/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation icon
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdIconsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdIcons(corporationId: number, datasource?: GetCorporationsCorporationIdIconsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdIcons(corporationId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a corporation\'s medals  --- Alternate route: `/dev/corporations/{corporation_id}/medals/`  Alternate route: `/legacy/corporations/{corporation_id}/medals/`  Alternate route: `/v1/corporations/{corporation_id}/medals/`  Alternate route: `/v2/corporations/{corporation_id}/medals/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation medals
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdMedalsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdMedals(corporationId: number, datasource?: GetCorporationsCorporationIdMedalsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMedals(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns medals issued by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`  Alternate route: `/legacy/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v1/corporations/{corporation_id}/medals/issued/`  Alternate route: `/v2/corporations/{corporation_id}/medals/issued/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation issued medals
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdMedalsIssuedDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdMedalsIssued(corporationId: number, datasource?: GetCorporationsCorporationIdMedalsIssuedDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMedalsIssued(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the current member list of a corporation, the token\'s character need to be a member of the corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/members/`  Alternate route: `/legacy/corporations/{corporation_id}/members/`  Alternate route: `/v3/corporations/{corporation_id}/members/`  Alternate route: `/v4/corporations/{corporation_id}/members/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation members
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdMembersDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdMembers(corporationId: number, datasource?: GetCorporationsCorporationIdMembersDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMembers(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a corporation\'s member limit, not including CEO himself  --- Alternate route: `/dev/corporations/{corporation_id}/members/limit/`  Alternate route: `/legacy/corporations/{corporation_id}/members/limit/`  Alternate route: `/v1/corporations/{corporation_id}/members/limit/`  Alternate route: `/v2/corporations/{corporation_id}/members/limit/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation member limit
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdMembersLimitDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdMembersLimit(corporationId: number, datasource?: GetCorporationsCorporationIdMembersLimitDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMembersLimit(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a corporation\'s members\' titles  --- Alternate route: `/dev/corporations/{corporation_id}/members/titles/`  Alternate route: `/legacy/corporations/{corporation_id}/members/titles/`  Alternate route: `/v1/corporations/{corporation_id}/members/titles/`  Alternate route: `/v2/corporations/{corporation_id}/members/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation\'s members\' titles
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdMembersTitlesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdMembersTitles(corporationId: number, datasource?: GetCorporationsCorporationIdMembersTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMembersTitles(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns additional information about a corporation\'s members which helps tracking their activities  --- Alternate route: `/dev/corporations/{corporation_id}/membertracking/`  Alternate route: `/legacy/corporations/{corporation_id}/membertracking/`  Alternate route: `/v1/corporations/{corporation_id}/membertracking/`  Alternate route: `/v2/corporations/{corporation_id}/membertracking/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Track corporation members
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdMembertrackingDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdMembertracking(corporationId: number, datasource?: GetCorporationsCorporationIdMembertrackingDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdMembertracking(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the roles of all members if the character has the personnel manager role or any grantable role.  --- Alternate route: `/dev/corporations/{corporation_id}/roles/`  Alternate route: `/legacy/corporations/{corporation_id}/roles/`  Alternate route: `/v1/corporations/{corporation_id}/roles/`  Alternate route: `/v2/corporations/{corporation_id}/roles/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation member roles
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdRolesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdRoles(corporationId: number, datasource?: GetCorporationsCorporationIdRolesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdRoles(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return how roles have changed for a coporation\'s members, up to a month  --- Alternate route: `/dev/corporations/{corporation_id}/roles/history/`  Alternate route: `/legacy/corporations/{corporation_id}/roles/history/`  Alternate route: `/v1/corporations/{corporation_id}/roles/history/`  Alternate route: `/v2/corporations/{corporation_id}/roles/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation member roles history
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdRolesHistoryDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdRolesHistory(corporationId: number, datasource?: GetCorporationsCorporationIdRolesHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdRolesHistory(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the current shareholders of a corporation.  --- Alternate route: `/dev/corporations/{corporation_id}/shareholders/`  Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`  Alternate route: `/v1/corporations/{corporation_id}/shareholders/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation shareholders
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdShareholdersDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdShareholders(corporationId: number, datasource?: GetCorporationsCorporationIdShareholdersDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdShareholders(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return corporation standings from agents, NPC corporations, and factions  --- Alternate route: `/dev/corporations/{corporation_id}/standings/`  Alternate route: `/legacy/corporations/{corporation_id}/standings/`  Alternate route: `/v1/corporations/{corporation_id}/standings/`  Alternate route: `/v2/corporations/{corporation_id}/standings/`  --- This route is cached for up to 3600 seconds
     * @summary Get corporation standings
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdStandingsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdStandings(corporationId: number, datasource?: GetCorporationsCorporationIdStandingsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdStandings(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of corporation starbases (POSes)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/`  Alternate route: `/legacy/corporations/{corporation_id}/starbases/`  Alternate route: `/v1/corporations/{corporation_id}/starbases/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation starbases (POSes)
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdStarbasesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdStarbases(corporationId: number, datasource?: GetCorporationsCorporationIdStarbasesDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdStarbases(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns various settings and fuels of a starbase (POS)  --- Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/legacy/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v1/corporations/{corporation_id}/starbases/{starbase_id}/`  Alternate route: `/v2/corporations/{corporation_id}/starbases/{starbase_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get starbase (POS) detail
     * @param {number} corporationId An EVE corporation ID
     * @param {number} starbaseId An EVE starbase (POS) ID
     * @param {number} systemId The solar system this starbase (POS) is located in,
     * @param {GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdStarbasesStarbaseId(corporationId: number, starbaseId: number, systemId: number, datasource?: GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdStarbasesStarbaseId(corporationId, starbaseId, systemId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of corporation structures. This route\'s version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th  --- Alternate route: `/dev/corporations/{corporation_id}/structures/`  Alternate route: `/v4/corporations/{corporation_id}/structures/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
     * @summary Get corporation structures
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdStructuresAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetCorporationsCorporationIdStructuresDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetCorporationsCorporationIdStructuresLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdStructures(corporationId: number, acceptLanguage?: GetCorporationsCorporationIdStructuresAcceptLanguageEnum, datasource?: GetCorporationsCorporationIdStructuresDatasourceEnum, ifNoneMatch?: string, language?: GetCorporationsCorporationIdStructuresLanguageEnum, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdStructures(corporationId, acceptLanguage, datasource, ifNoneMatch, language, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a corporation\'s titles  --- Alternate route: `/dev/corporations/{corporation_id}/titles/`  Alternate route: `/legacy/corporations/{corporation_id}/titles/`  Alternate route: `/v1/corporations/{corporation_id}/titles/`  Alternate route: `/v2/corporations/{corporation_id}/titles/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get corporation titles
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdTitlesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdTitles(corporationId: number, datasource?: GetCorporationsCorporationIdTitlesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsCorporationIdTitles(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of npc corporations  --- Alternate route: `/dev/corporations/npccorps/`  Alternate route: `/legacy/corporations/npccorps/`  Alternate route: `/v1/corporations/npccorps/`  Alternate route: `/v2/corporations/npccorps/`  --- This route expires daily at 11:05
     * @summary Get npc corporations
     * @param {GetCorporationsNpccorpsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsNpccorps(datasource?: GetCorporationsNpccorpsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return CorporationApiFp(this.configuration).getCorporationsNpccorps(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCorporationsCorporationIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdDatasourceEnum = typeof GetCorporationsCorporationIdDatasourceEnum[keyof typeof GetCorporationsCorporationIdDatasourceEnum];
export const GetCorporationsCorporationIdAlliancehistoryDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdAlliancehistoryDatasourceEnum = typeof GetCorporationsCorporationIdAlliancehistoryDatasourceEnum[keyof typeof GetCorporationsCorporationIdAlliancehistoryDatasourceEnum];
export const GetCorporationsCorporationIdBlueprintsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdBlueprintsDatasourceEnum = typeof GetCorporationsCorporationIdBlueprintsDatasourceEnum[keyof typeof GetCorporationsCorporationIdBlueprintsDatasourceEnum];
export const GetCorporationsCorporationIdContainersLogsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdContainersLogsDatasourceEnum = typeof GetCorporationsCorporationIdContainersLogsDatasourceEnum[keyof typeof GetCorporationsCorporationIdContainersLogsDatasourceEnum];
export const GetCorporationsCorporationIdDivisionsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdDivisionsDatasourceEnum = typeof GetCorporationsCorporationIdDivisionsDatasourceEnum[keyof typeof GetCorporationsCorporationIdDivisionsDatasourceEnum];
export const GetCorporationsCorporationIdFacilitiesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdFacilitiesDatasourceEnum = typeof GetCorporationsCorporationIdFacilitiesDatasourceEnum[keyof typeof GetCorporationsCorporationIdFacilitiesDatasourceEnum];
export const GetCorporationsCorporationIdIconsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdIconsDatasourceEnum = typeof GetCorporationsCorporationIdIconsDatasourceEnum[keyof typeof GetCorporationsCorporationIdIconsDatasourceEnum];
export const GetCorporationsCorporationIdMedalsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdMedalsDatasourceEnum = typeof GetCorporationsCorporationIdMedalsDatasourceEnum[keyof typeof GetCorporationsCorporationIdMedalsDatasourceEnum];
export const GetCorporationsCorporationIdMedalsIssuedDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdMedalsIssuedDatasourceEnum = typeof GetCorporationsCorporationIdMedalsIssuedDatasourceEnum[keyof typeof GetCorporationsCorporationIdMedalsIssuedDatasourceEnum];
export const GetCorporationsCorporationIdMembersDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdMembersDatasourceEnum = typeof GetCorporationsCorporationIdMembersDatasourceEnum[keyof typeof GetCorporationsCorporationIdMembersDatasourceEnum];
export const GetCorporationsCorporationIdMembersLimitDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdMembersLimitDatasourceEnum = typeof GetCorporationsCorporationIdMembersLimitDatasourceEnum[keyof typeof GetCorporationsCorporationIdMembersLimitDatasourceEnum];
export const GetCorporationsCorporationIdMembersTitlesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdMembersTitlesDatasourceEnum = typeof GetCorporationsCorporationIdMembersTitlesDatasourceEnum[keyof typeof GetCorporationsCorporationIdMembersTitlesDatasourceEnum];
export const GetCorporationsCorporationIdMembertrackingDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdMembertrackingDatasourceEnum = typeof GetCorporationsCorporationIdMembertrackingDatasourceEnum[keyof typeof GetCorporationsCorporationIdMembertrackingDatasourceEnum];
export const GetCorporationsCorporationIdRolesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdRolesDatasourceEnum = typeof GetCorporationsCorporationIdRolesDatasourceEnum[keyof typeof GetCorporationsCorporationIdRolesDatasourceEnum];
export const GetCorporationsCorporationIdRolesHistoryDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdRolesHistoryDatasourceEnum = typeof GetCorporationsCorporationIdRolesHistoryDatasourceEnum[keyof typeof GetCorporationsCorporationIdRolesHistoryDatasourceEnum];
export const GetCorporationsCorporationIdShareholdersDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdShareholdersDatasourceEnum = typeof GetCorporationsCorporationIdShareholdersDatasourceEnum[keyof typeof GetCorporationsCorporationIdShareholdersDatasourceEnum];
export const GetCorporationsCorporationIdStandingsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdStandingsDatasourceEnum = typeof GetCorporationsCorporationIdStandingsDatasourceEnum[keyof typeof GetCorporationsCorporationIdStandingsDatasourceEnum];
export const GetCorporationsCorporationIdStarbasesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdStarbasesDatasourceEnum = typeof GetCorporationsCorporationIdStarbasesDatasourceEnum[keyof typeof GetCorporationsCorporationIdStarbasesDatasourceEnum];
export const GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum = typeof GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum[keyof typeof GetCorporationsCorporationIdStarbasesStarbaseIdDatasourceEnum];
export const GetCorporationsCorporationIdStructuresAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCorporationsCorporationIdStructuresAcceptLanguageEnum = typeof GetCorporationsCorporationIdStructuresAcceptLanguageEnum[keyof typeof GetCorporationsCorporationIdStructuresAcceptLanguageEnum];
export const GetCorporationsCorporationIdStructuresDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdStructuresDatasourceEnum = typeof GetCorporationsCorporationIdStructuresDatasourceEnum[keyof typeof GetCorporationsCorporationIdStructuresDatasourceEnum];
export const GetCorporationsCorporationIdStructuresLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCorporationsCorporationIdStructuresLanguageEnum = typeof GetCorporationsCorporationIdStructuresLanguageEnum[keyof typeof GetCorporationsCorporationIdStructuresLanguageEnum];
export const GetCorporationsCorporationIdTitlesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdTitlesDatasourceEnum = typeof GetCorporationsCorporationIdTitlesDatasourceEnum[keyof typeof GetCorporationsCorporationIdTitlesDatasourceEnum];
export const GetCorporationsNpccorpsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsNpccorpsDatasourceEnum = typeof GetCorporationsNpccorpsDatasourceEnum[keyof typeof GetCorporationsNpccorpsDatasourceEnum];


/**
 * DogmaApi - axios parameter creator
 */
export const DogmaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
         * @summary Get attributes
         * @param {GetDogmaAttributesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaAttributes: async (datasource?: GetDogmaAttributesDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dogma/attributes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
         * @summary Get attribute information
         * @param {number} attributeId A dogma attribute ID
         * @param {GetDogmaAttributesAttributeIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaAttributesAttributeId: async (attributeId: number, datasource?: GetDogmaAttributesAttributeIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('getDogmaAttributesAttributeId', 'attributeId', attributeId)
            const localVarPath = `/dogma/attributes/{attribute_id}/`
                .replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
         * @summary Get dynamic item information
         * @param {number} itemId item_id integer
         * @param {number} typeId type_id integer
         * @param {GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaDynamicItemsTypeIdItemId: async (itemId: number, typeId: number, datasource?: GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getDogmaDynamicItemsTypeIdItemId', 'itemId', itemId)
            // verify required parameter 'typeId' is not null or undefined
            assertParamExists('getDogmaDynamicItemsTypeIdItemId', 'typeId', typeId)
            const localVarPath = `/dogma/dynamic/items/{type_id}/{item_id}/`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"type_id"}}`, encodeURIComponent(String(typeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
         * @summary Get effects
         * @param {GetDogmaEffectsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaEffects: async (datasource?: GetDogmaEffectsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dogma/effects/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
         * @summary Get effect information
         * @param {number} effectId A dogma effect ID
         * @param {GetDogmaEffectsEffectIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaEffectsEffectId: async (effectId: number, datasource?: GetDogmaEffectsEffectIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'effectId' is not null or undefined
            assertParamExists('getDogmaEffectsEffectId', 'effectId', effectId)
            const localVarPath = `/dogma/effects/{effect_id}/`
                .replace(`{${"effect_id"}}`, encodeURIComponent(String(effectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DogmaApi - functional programming interface
 */
export const DogmaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DogmaApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
         * @summary Get attributes
         * @param {GetDogmaAttributesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDogmaAttributes(datasource?: GetDogmaAttributesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDogmaAttributes(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DogmaApi.getDogmaAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
         * @summary Get attribute information
         * @param {number} attributeId A dogma attribute ID
         * @param {GetDogmaAttributesAttributeIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDogmaAttributesAttributeId(attributeId: number, datasource?: GetDogmaAttributesAttributeIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDogmaAttributesAttributeIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDogmaAttributesAttributeId(attributeId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DogmaApi.getDogmaAttributesAttributeId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
         * @summary Get dynamic item information
         * @param {number} itemId item_id integer
         * @param {number} typeId type_id integer
         * @param {GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDogmaDynamicItemsTypeIdItemId(itemId: number, typeId: number, datasource?: GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDogmaDynamicItemsTypeIdItemIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDogmaDynamicItemsTypeIdItemId(itemId, typeId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DogmaApi.getDogmaDynamicItemsTypeIdItemId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
         * @summary Get effects
         * @param {GetDogmaEffectsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDogmaEffects(datasource?: GetDogmaEffectsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDogmaEffects(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DogmaApi.getDogmaEffects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
         * @summary Get effect information
         * @param {number} effectId A dogma effect ID
         * @param {GetDogmaEffectsEffectIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDogmaEffectsEffectId(effectId: number, datasource?: GetDogmaEffectsEffectIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDogmaEffectsEffectIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDogmaEffectsEffectId(effectId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DogmaApi.getDogmaEffectsEffectId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DogmaApi - factory interface
 */
export const DogmaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DogmaApiFp(configuration)
    return {
        /**
         * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
         * @summary Get attributes
         * @param {GetDogmaAttributesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaAttributes(datasource?: GetDogmaAttributesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getDogmaAttributes(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
         * @summary Get attribute information
         * @param {number} attributeId A dogma attribute ID
         * @param {GetDogmaAttributesAttributeIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaAttributesAttributeId(attributeId: number, datasource?: GetDogmaAttributesAttributeIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetDogmaAttributesAttributeIdOk> {
            return localVarFp.getDogmaAttributesAttributeId(attributeId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
         * @summary Get dynamic item information
         * @param {number} itemId item_id integer
         * @param {number} typeId type_id integer
         * @param {GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaDynamicItemsTypeIdItemId(itemId: number, typeId: number, datasource?: GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetDogmaDynamicItemsTypeIdItemIdOk> {
            return localVarFp.getDogmaDynamicItemsTypeIdItemId(itemId, typeId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
         * @summary Get effects
         * @param {GetDogmaEffectsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaEffects(datasource?: GetDogmaEffectsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getDogmaEffects(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
         * @summary Get effect information
         * @param {number} effectId A dogma effect ID
         * @param {GetDogmaEffectsEffectIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDogmaEffectsEffectId(effectId: number, datasource?: GetDogmaEffectsEffectIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetDogmaEffectsEffectIdOk> {
            return localVarFp.getDogmaEffectsEffectId(effectId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DogmaApi - object-oriented interface
 */
export class DogmaApi extends BaseAPI {
    /**
     * Get a list of dogma attribute ids  --- Alternate route: `/dev/dogma/attributes/`  Alternate route: `/legacy/dogma/attributes/`  Alternate route: `/v1/dogma/attributes/`  --- This route expires daily at 11:05
     * @summary Get attributes
     * @param {GetDogmaAttributesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDogmaAttributes(datasource?: GetDogmaAttributesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return DogmaApiFp(this.configuration).getDogmaAttributes(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a dogma attribute  --- Alternate route: `/dev/dogma/attributes/{attribute_id}/`  Alternate route: `/legacy/dogma/attributes/{attribute_id}/`  Alternate route: `/v1/dogma/attributes/{attribute_id}/`  --- This route expires daily at 11:05
     * @summary Get attribute information
     * @param {number} attributeId A dogma attribute ID
     * @param {GetDogmaAttributesAttributeIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDogmaAttributesAttributeId(attributeId: number, datasource?: GetDogmaAttributesAttributeIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return DogmaApiFp(this.configuration).getDogmaAttributesAttributeId(attributeId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns info about a dynamic item resulting from mutation with a mutaplasmid.  --- Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`  Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`  --- This route expires daily at 11:05
     * @summary Get dynamic item information
     * @param {number} itemId item_id integer
     * @param {number} typeId type_id integer
     * @param {GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDogmaDynamicItemsTypeIdItemId(itemId: number, typeId: number, datasource?: GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return DogmaApiFp(this.configuration).getDogmaDynamicItemsTypeIdItemId(itemId, typeId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of dogma effect ids  --- Alternate route: `/dev/dogma/effects/`  Alternate route: `/legacy/dogma/effects/`  Alternate route: `/v1/dogma/effects/`  --- This route expires daily at 11:05
     * @summary Get effects
     * @param {GetDogmaEffectsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDogmaEffects(datasource?: GetDogmaEffectsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return DogmaApiFp(this.configuration).getDogmaEffects(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a dogma effect  --- Alternate route: `/dev/dogma/effects/{effect_id}/`  Alternate route: `/v2/dogma/effects/{effect_id}/`  --- This route expires daily at 11:05
     * @summary Get effect information
     * @param {number} effectId A dogma effect ID
     * @param {GetDogmaEffectsEffectIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDogmaEffectsEffectId(effectId: number, datasource?: GetDogmaEffectsEffectIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return DogmaApiFp(this.configuration).getDogmaEffectsEffectId(effectId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetDogmaAttributesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetDogmaAttributesDatasourceEnum = typeof GetDogmaAttributesDatasourceEnum[keyof typeof GetDogmaAttributesDatasourceEnum];
export const GetDogmaAttributesAttributeIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetDogmaAttributesAttributeIdDatasourceEnum = typeof GetDogmaAttributesAttributeIdDatasourceEnum[keyof typeof GetDogmaAttributesAttributeIdDatasourceEnum];
export const GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum = typeof GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum[keyof typeof GetDogmaDynamicItemsTypeIdItemIdDatasourceEnum];
export const GetDogmaEffectsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetDogmaEffectsDatasourceEnum = typeof GetDogmaEffectsDatasourceEnum[keyof typeof GetDogmaEffectsDatasourceEnum];
export const GetDogmaEffectsEffectIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetDogmaEffectsEffectIdDatasourceEnum = typeof GetDogmaEffectsEffectIdDatasourceEnum[keyof typeof GetDogmaEffectsEffectIdDatasourceEnum];


/**
 * FactionWarfareApi - axios parameter creator
 */
export const FactionWarfareApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a character involved in faction warfare
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFwStatsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFwStats: async (characterId: number, datasource?: GetCharactersCharacterIdFwStatsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdFwStats', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/fw/stats/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_fw_stats.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a corporation involved in faction warfare
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdFwStatsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdFwStats: async (corporationId: number, datasource?: GetCorporationsCorporationIdFwStatsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdFwStats', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/fw/stats/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-corporations.read_fw_stats.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
         * @summary List of the top factions in faction warfare
         * @param {GetFwLeaderboardsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboards: async (datasource?: GetFwLeaderboardsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fw/leaderboards/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
         * @summary List of the top pilots in faction warfare
         * @param {GetFwLeaderboardsCharactersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboardsCharacters: async (datasource?: GetFwLeaderboardsCharactersDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fw/leaderboards/characters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
         * @summary List of the top corporations in faction warfare
         * @param {GetFwLeaderboardsCorporationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboardsCorporations: async (datasource?: GetFwLeaderboardsCorporationsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fw/leaderboards/corporations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
         * @summary An overview of statistics about factions involved in faction warfare
         * @param {GetFwStatsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwStats: async (datasource?: GetFwStatsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fw/stats/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
         * @summary Ownership of faction warfare systems
         * @param {GetFwSystemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwSystems: async (datasource?: GetFwSystemsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fw/systems/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
         * @summary Data about which NPC factions are at war
         * @param {GetFwWarsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwWars: async (datasource?: GetFwWarsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fw/wars/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactionWarfareApi - functional programming interface
 */
export const FactionWarfareApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FactionWarfareApiAxiosParamCreator(configuration)
    return {
        /**
         * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a character involved in faction warfare
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFwStatsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdFwStats(characterId: number, datasource?: GetCharactersCharacterIdFwStatsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdFwStatsOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdFwStats(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FactionWarfareApi.getCharactersCharacterIdFwStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a corporation involved in faction warfare
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdFwStatsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdFwStats(corporationId: number, datasource?: GetCorporationsCorporationIdFwStatsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCorporationsCorporationIdFwStatsOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdFwStats(corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FactionWarfareApi.getCorporationsCorporationIdFwStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
         * @summary List of the top factions in faction warfare
         * @param {GetFwLeaderboardsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFwLeaderboards(datasource?: GetFwLeaderboardsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFwLeaderboardsOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFwLeaderboards(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FactionWarfareApi.getFwLeaderboards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
         * @summary List of the top pilots in faction warfare
         * @param {GetFwLeaderboardsCharactersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFwLeaderboardsCharacters(datasource?: GetFwLeaderboardsCharactersDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFwLeaderboardsCharactersOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFwLeaderboardsCharacters(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FactionWarfareApi.getFwLeaderboardsCharacters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
         * @summary List of the top corporations in faction warfare
         * @param {GetFwLeaderboardsCorporationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFwLeaderboardsCorporations(datasource?: GetFwLeaderboardsCorporationsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFwLeaderboardsCorporationsOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFwLeaderboardsCorporations(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FactionWarfareApi.getFwLeaderboardsCorporations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
         * @summary An overview of statistics about factions involved in faction warfare
         * @param {GetFwStatsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFwStats(datasource?: GetFwStatsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFwStats200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFwStats(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FactionWarfareApi.getFwStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
         * @summary Ownership of faction warfare systems
         * @param {GetFwSystemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFwSystems(datasource?: GetFwSystemsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFwSystems200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFwSystems(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FactionWarfareApi.getFwSystems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
         * @summary Data about which NPC factions are at war
         * @param {GetFwWarsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFwWars(datasource?: GetFwWarsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFwWars200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFwWars(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FactionWarfareApi.getFwWars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FactionWarfareApi - factory interface
 */
export const FactionWarfareApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FactionWarfareApiFp(configuration)
    return {
        /**
         * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a character involved in faction warfare
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFwStatsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFwStats(characterId: number, datasource?: GetCharactersCharacterIdFwStatsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdFwStatsOk> {
            return localVarFp.getCharactersCharacterIdFwStats(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
         * @summary Overview of a corporation involved in faction warfare
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdFwStatsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdFwStats(corporationId: number, datasource?: GetCorporationsCorporationIdFwStatsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCorporationsCorporationIdFwStatsOk> {
            return localVarFp.getCorporationsCorporationIdFwStats(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
         * @summary List of the top factions in faction warfare
         * @param {GetFwLeaderboardsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboards(datasource?: GetFwLeaderboardsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetFwLeaderboardsOk> {
            return localVarFp.getFwLeaderboards(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
         * @summary List of the top pilots in faction warfare
         * @param {GetFwLeaderboardsCharactersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboardsCharacters(datasource?: GetFwLeaderboardsCharactersDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetFwLeaderboardsCharactersOk> {
            return localVarFp.getFwLeaderboardsCharacters(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
         * @summary List of the top corporations in faction warfare
         * @param {GetFwLeaderboardsCorporationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwLeaderboardsCorporations(datasource?: GetFwLeaderboardsCorporationsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetFwLeaderboardsCorporationsOk> {
            return localVarFp.getFwLeaderboardsCorporations(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
         * @summary An overview of statistics about factions involved in faction warfare
         * @param {GetFwStatsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwStats(datasource?: GetFwStatsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFwStats200Ok>> {
            return localVarFp.getFwStats(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
         * @summary Ownership of faction warfare systems
         * @param {GetFwSystemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwSystems(datasource?: GetFwSystemsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFwSystems200Ok>> {
            return localVarFp.getFwSystems(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
         * @summary Data about which NPC factions are at war
         * @param {GetFwWarsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFwWars(datasource?: GetFwWarsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFwWars200Ok>> {
            return localVarFp.getFwWars(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FactionWarfareApi - object-oriented interface
 */
export class FactionWarfareApi extends BaseAPI {
    /**
     * Statistical overview of a character involved in faction warfare  --- Alternate route: `/dev/characters/{character_id}/fw/stats/`  Alternate route: `/legacy/characters/{character_id}/fw/stats/`  Alternate route: `/v1/characters/{character_id}/fw/stats/`  Alternate route: `/v2/characters/{character_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a character involved in faction warfare
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdFwStatsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdFwStats(characterId: number, datasource?: GetCharactersCharacterIdFwStatsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return FactionWarfareApiFp(this.configuration).getCharactersCharacterIdFwStats(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Statistics about a corporation involved in faction warfare  --- Alternate route: `/dev/corporations/{corporation_id}/fw/stats/`  Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`  Alternate route: `/v2/corporations/{corporation_id}/fw/stats/`  --- This route expires daily at 11:05
     * @summary Overview of a corporation involved in faction warfare
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdFwStatsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdFwStats(corporationId: number, datasource?: GetCorporationsCorporationIdFwStatsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return FactionWarfareApiFp(this.configuration).getCorporationsCorporationIdFwStats(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/`  Alternate route: `/legacy/fw/leaderboards/`  Alternate route: `/v1/fw/leaderboards/`  Alternate route: `/v2/fw/leaderboards/`  --- This route expires daily at 11:05
     * @summary List of the top factions in faction warfare
     * @param {GetFwLeaderboardsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFwLeaderboards(datasource?: GetFwLeaderboardsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return FactionWarfareApiFp(this.configuration).getFwLeaderboards(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/characters/`  Alternate route: `/legacy/fw/leaderboards/characters/`  Alternate route: `/v1/fw/leaderboards/characters/`  Alternate route: `/v2/fw/leaderboards/characters/`  --- This route expires daily at 11:05
     * @summary List of the top pilots in faction warfare
     * @param {GetFwLeaderboardsCharactersDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFwLeaderboardsCharacters(datasource?: GetFwLeaderboardsCharactersDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return FactionWarfareApiFp(this.configuration).getFwLeaderboardsCharacters(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday  --- Alternate route: `/dev/fw/leaderboards/corporations/`  Alternate route: `/legacy/fw/leaderboards/corporations/`  Alternate route: `/v1/fw/leaderboards/corporations/`  Alternate route: `/v2/fw/leaderboards/corporations/`  --- This route expires daily at 11:05
     * @summary List of the top corporations in faction warfare
     * @param {GetFwLeaderboardsCorporationsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFwLeaderboardsCorporations(datasource?: GetFwLeaderboardsCorporationsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return FactionWarfareApiFp(this.configuration).getFwLeaderboardsCorporations(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Statistical overviews of factions involved in faction warfare  --- Alternate route: `/dev/fw/stats/`  Alternate route: `/legacy/fw/stats/`  Alternate route: `/v1/fw/stats/`  Alternate route: `/v2/fw/stats/`  --- This route expires daily at 11:05
     * @summary An overview of statistics about factions involved in faction warfare
     * @param {GetFwStatsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFwStats(datasource?: GetFwStatsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return FactionWarfareApiFp(this.configuration).getFwStats(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * An overview of the current ownership of faction warfare solar systems  --- Alternate route: `/dev/fw/systems/`  Alternate route: `/legacy/fw/systems/`  Alternate route: `/v2/fw/systems/`  Alternate route: `/v3/fw/systems/`  --- This route is cached for up to 1800 seconds
     * @summary Ownership of faction warfare systems
     * @param {GetFwSystemsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFwSystems(datasource?: GetFwSystemsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return FactionWarfareApiFp(this.configuration).getFwSystems(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Data about which NPC factions are at war  --- Alternate route: `/dev/fw/wars/`  Alternate route: `/legacy/fw/wars/`  Alternate route: `/v1/fw/wars/`  Alternate route: `/v2/fw/wars/`  --- This route expires daily at 11:05
     * @summary Data about which NPC factions are at war
     * @param {GetFwWarsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFwWars(datasource?: GetFwWarsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return FactionWarfareApiFp(this.configuration).getFwWars(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdFwStatsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdFwStatsDatasourceEnum = typeof GetCharactersCharacterIdFwStatsDatasourceEnum[keyof typeof GetCharactersCharacterIdFwStatsDatasourceEnum];
export const GetCorporationsCorporationIdFwStatsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdFwStatsDatasourceEnum = typeof GetCorporationsCorporationIdFwStatsDatasourceEnum[keyof typeof GetCorporationsCorporationIdFwStatsDatasourceEnum];
export const GetFwLeaderboardsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetFwLeaderboardsDatasourceEnum = typeof GetFwLeaderboardsDatasourceEnum[keyof typeof GetFwLeaderboardsDatasourceEnum];
export const GetFwLeaderboardsCharactersDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetFwLeaderboardsCharactersDatasourceEnum = typeof GetFwLeaderboardsCharactersDatasourceEnum[keyof typeof GetFwLeaderboardsCharactersDatasourceEnum];
export const GetFwLeaderboardsCorporationsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetFwLeaderboardsCorporationsDatasourceEnum = typeof GetFwLeaderboardsCorporationsDatasourceEnum[keyof typeof GetFwLeaderboardsCorporationsDatasourceEnum];
export const GetFwStatsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetFwStatsDatasourceEnum = typeof GetFwStatsDatasourceEnum[keyof typeof GetFwStatsDatasourceEnum];
export const GetFwSystemsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetFwSystemsDatasourceEnum = typeof GetFwSystemsDatasourceEnum[keyof typeof GetFwSystemsDatasourceEnum];
export const GetFwWarsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetFwWarsDatasourceEnum = typeof GetFwWarsDatasourceEnum[keyof typeof GetFwWarsDatasourceEnum];


/**
 * FittingsApi - axios parameter creator
 */
export const FittingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/` 
         * @summary Delete fitting
         * @param {number} characterId An EVE character ID
         * @param {number} fittingId ID for a fitting of this character
         * @param {DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdFittingsFittingId: async (characterId: number, fittingId: number, datasource?: DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('deleteCharactersCharacterIdFittingsFittingId', 'characterId', characterId)
            // verify required parameter 'fittingId' is not null or undefined
            assertParamExists('deleteCharactersCharacterIdFittingsFittingId', 'fittingId', fittingId)
            const localVarPath = `/characters/{character_id}/fittings/{fitting_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"fitting_id"}}`, encodeURIComponent(String(fittingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fittings.write_fittings.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
         * @summary Get fittings
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFittingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFittings: async (characterId: number, datasource?: GetCharactersCharacterIdFittingsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdFittings', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/fittings/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fittings.read_fittings.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/legacy/characters/{character_id}/fittings/`  Alternate route: `/v1/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/` 
         * @summary Create fitting
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
         * @param {PostCharactersCharacterIdFittingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdFittings: async (characterId: number, fitting: PostCharactersCharacterIdFittingsFitting, datasource?: PostCharactersCharacterIdFittingsDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('postCharactersCharacterIdFittings', 'characterId', characterId)
            // verify required parameter 'fitting' is not null or undefined
            assertParamExists('postCharactersCharacterIdFittings', 'fitting', fitting)
            const localVarPath = `/characters/{character_id}/fittings/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fittings.write_fittings.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fitting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FittingsApi - functional programming interface
 */
export const FittingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FittingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/` 
         * @summary Delete fitting
         * @param {number} characterId An EVE character ID
         * @param {number} fittingId ID for a fitting of this character
         * @param {DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharactersCharacterIdFittingsFittingId(characterId: number, fittingId: number, datasource?: DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCharactersCharacterIdFittingsFittingId(characterId, fittingId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FittingsApi.deleteCharactersCharacterIdFittingsFittingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
         * @summary Get fittings
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFittingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdFittings(characterId: number, datasource?: GetCharactersCharacterIdFittingsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdFittings200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdFittings(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FittingsApi.getCharactersCharacterIdFittings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/legacy/characters/{character_id}/fittings/`  Alternate route: `/v1/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/` 
         * @summary Create fitting
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
         * @param {PostCharactersCharacterIdFittingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCharactersCharacterIdFittings(characterId: number, fitting: PostCharactersCharacterIdFittingsFitting, datasource?: PostCharactersCharacterIdFittingsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCharactersCharacterIdFittingsCreated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCharactersCharacterIdFittings(characterId, fitting, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FittingsApi.postCharactersCharacterIdFittings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FittingsApi - factory interface
 */
export const FittingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FittingsApiFp(configuration)
    return {
        /**
         * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/` 
         * @summary Delete fitting
         * @param {number} characterId An EVE character ID
         * @param {number} fittingId ID for a fitting of this character
         * @param {DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdFittingsFittingId(characterId: number, fittingId: number, datasource?: DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCharactersCharacterIdFittingsFittingId(characterId, fittingId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
         * @summary Get fittings
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFittingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFittings(characterId: number, datasource?: GetCharactersCharacterIdFittingsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdFittings200Ok>> {
            return localVarFp.getCharactersCharacterIdFittings(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/legacy/characters/{character_id}/fittings/`  Alternate route: `/v1/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/` 
         * @summary Create fitting
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
         * @param {PostCharactersCharacterIdFittingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdFittings(characterId: number, fitting: PostCharactersCharacterIdFittingsFitting, datasource?: PostCharactersCharacterIdFittingsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<PostCharactersCharacterIdFittingsCreated> {
            return localVarFp.postCharactersCharacterIdFittings(characterId, fitting, datasource, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FittingsApi - object-oriented interface
 */
export class FittingsApi extends BaseAPI {
    /**
     * Delete a fitting from a character  --- Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`  Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/` 
     * @summary Delete fitting
     * @param {number} characterId An EVE character ID
     * @param {number} fittingId ID for a fitting of this character
     * @param {DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCharactersCharacterIdFittingsFittingId(characterId: number, fittingId: number, datasource?: DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FittingsApiFp(this.configuration).deleteCharactersCharacterIdFittingsFittingId(characterId, fittingId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return fittings of a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/`  --- This route is cached for up to 300 seconds
     * @summary Get fittings
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdFittingsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdFittings(characterId: number, datasource?: GetCharactersCharacterIdFittingsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return FittingsApiFp(this.configuration).getCharactersCharacterIdFittings(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Save a new fitting for a character  --- Alternate route: `/dev/characters/{character_id}/fittings/`  Alternate route: `/legacy/characters/{character_id}/fittings/`  Alternate route: `/v1/characters/{character_id}/fittings/`  Alternate route: `/v2/characters/{character_id}/fittings/` 
     * @summary Create fitting
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdFittingsFitting} fitting Details about the new fitting
     * @param {PostCharactersCharacterIdFittingsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCharactersCharacterIdFittings(characterId: number, fitting: PostCharactersCharacterIdFittingsFitting, datasource?: PostCharactersCharacterIdFittingsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FittingsApiFp(this.configuration).postCharactersCharacterIdFittings(characterId, fitting, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum = typeof DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum[keyof typeof DeleteCharactersCharacterIdFittingsFittingIdDatasourceEnum];
export const GetCharactersCharacterIdFittingsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdFittingsDatasourceEnum = typeof GetCharactersCharacterIdFittingsDatasourceEnum[keyof typeof GetCharactersCharacterIdFittingsDatasourceEnum];
export const PostCharactersCharacterIdFittingsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostCharactersCharacterIdFittingsDatasourceEnum = typeof PostCharactersCharacterIdFittingsDatasourceEnum[keyof typeof PostCharactersCharacterIdFittingsDatasourceEnum];


/**
 * FleetsApi - axios parameter creator
 */
export const FleetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Kick fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {DeleteFleetsFleetIdMembersMemberIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdMembersMemberId: async (fleetId: number, memberId: number, datasource?: DeleteFleetsFleetIdMembersMemberIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('deleteFleetsFleetIdMembersMemberId', 'fleetId', fleetId)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteFleetsFleetIdMembersMemberId', 'memberId', memberId)
            const localVarPath = `/fleets/{fleet_id}/members/{member_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.write_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Delete fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} squadId The squad to delete
         * @param {DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdSquadsSquadId: async (fleetId: number, squadId: number, datasource?: DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('deleteFleetsFleetIdSquadsSquadId', 'fleetId', fleetId)
            // verify required parameter 'squadId' is not null or undefined
            assertParamExists('deleteFleetsFleetIdSquadsSquadId', 'squadId', squadId)
            const localVarPath = `/fleets/{fleet_id}/squads/{squad_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"squad_id"}}`, encodeURIComponent(String(squadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.write_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Delete fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing to delete
         * @param {DeleteFleetsFleetIdWingsWingIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdWingsWingId: async (fleetId: number, wingId: number, datasource?: DeleteFleetsFleetIdWingsWingIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('deleteFleetsFleetIdWingsWingId', 'fleetId', fleetId)
            // verify required parameter 'wingId' is not null or undefined
            assertParamExists('deleteFleetsFleetIdWingsWingId', 'wingId', wingId)
            const localVarPath = `/fleets/{fleet_id}/wings/{wing_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"wing_id"}}`, encodeURIComponent(String(wingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.write_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the fleet ID the character is in, if any.  --- Alternate route: `/dev/characters/{character_id}/fleet/`  Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  Alternate route: `/v2/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds
         * @summary Get character fleet info
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFleetDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFleet: async (characterId: number, datasource?: GetCharactersCharacterIdFleetDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdFleet', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/fleet/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.read_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet information
         * @param {number} fleetId ID for a fleet
         * @param {GetFleetsFleetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetId: async (fleetId: number, datasource?: GetFleetsFleetIdDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('getFleetsFleetId', 'fleetId', fleetId)
            const localVarPath = `/fleets/{fleet_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.read_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet members
         * @param {number} fleetId ID for a fleet
         * @param {GetFleetsFleetIdMembersAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetFleetsFleetIdMembersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetFleetsFleetIdMembersLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetIdMembers: async (fleetId: number, acceptLanguage?: GetFleetsFleetIdMembersAcceptLanguageEnum, datasource?: GetFleetsFleetIdMembersDatasourceEnum, ifNoneMatch?: string, language?: GetFleetsFleetIdMembersLanguageEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('getFleetsFleetIdMembers', 'fleetId', fleetId)
            const localVarPath = `/fleets/{fleet_id}/members/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.read_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet wings
         * @param {number} fleetId ID for a fleet
         * @param {GetFleetsFleetIdWingsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetFleetsFleetIdWingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetFleetsFleetIdWingsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetIdWings: async (fleetId: number, acceptLanguage?: GetFleetsFleetIdWingsAcceptLanguageEnum, datasource?: GetFleetsFleetIdWingsDatasourceEnum, ifNoneMatch?: string, language?: GetFleetsFleetIdWingsLanguageEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('getFleetsFleetIdWings', 'fleetId', fleetId)
            const localVarPath = `/fleets/{fleet_id}/wings/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.read_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/` 
         * @summary Create fleet invitation
         * @param {number} fleetId ID for a fleet
         * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
         * @param {PostFleetsFleetIdMembersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdMembers: async (fleetId: number, invitation: PostFleetsFleetIdMembersInvitation, datasource?: PostFleetsFleetIdMembersDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('postFleetsFleetIdMembers', 'fleetId', fleetId)
            // verify required parameter 'invitation' is not null or undefined
            assertParamExists('postFleetsFleetIdMembers', 'invitation', invitation)
            const localVarPath = `/fleets/{fleet_id}/members/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.write_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invitation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/` 
         * @summary Create fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {PostFleetsFleetIdWingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdWings: async (fleetId: number, datasource?: PostFleetsFleetIdWingsDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('postFleetsFleetIdWings', 'fleetId', fleetId)
            const localVarPath = `/fleets/{fleet_id}/wings/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.write_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/` 
         * @summary Create fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing_id to create squad in
         * @param {PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdWingsWingIdSquads: async (fleetId: number, wingId: number, datasource?: PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('postFleetsFleetIdWingsWingIdSquads', 'fleetId', fleetId)
            // verify required parameter 'wingId' is not null or undefined
            assertParamExists('postFleetsFleetIdWingsWingIdSquads', 'wingId', wingId)
            const localVarPath = `/fleets/{fleet_id}/wings/{wing_id}/squads/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"wing_id"}}`, encodeURIComponent(String(wingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.write_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/` 
         * @summary Update fleet
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
         * @param {PutFleetsFleetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetId: async (fleetId: number, newSettings: PutFleetsFleetIdNewSettings, datasource?: PutFleetsFleetIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('putFleetsFleetId', 'fleetId', fleetId)
            // verify required parameter 'newSettings' is not null or undefined
            assertParamExists('putFleetsFleetId', 'newSettings', newSettings)
            const localVarPath = `/fleets/{fleet_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.write_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Move fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
         * @param {PutFleetsFleetIdMembersMemberIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdMembersMemberId: async (fleetId: number, memberId: number, movement: PutFleetsFleetIdMembersMemberIdMovement, datasource?: PutFleetsFleetIdMembersMemberIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('putFleetsFleetIdMembersMemberId', 'fleetId', fleetId)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('putFleetsFleetIdMembersMemberId', 'memberId', memberId)
            // verify required parameter 'movement' is not null or undefined
            assertParamExists('putFleetsFleetIdMembersMemberId', 'movement', movement)
            const localVarPath = `/fleets/{fleet_id}/members/{member_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.write_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(movement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Rename fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} squadId The squad to rename
         * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
         * @param {PutFleetsFleetIdSquadsSquadIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdSquadsSquadId: async (fleetId: number, squadId: number, naming: PutFleetsFleetIdSquadsSquadIdNaming, datasource?: PutFleetsFleetIdSquadsSquadIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('putFleetsFleetIdSquadsSquadId', 'fleetId', fleetId)
            // verify required parameter 'squadId' is not null or undefined
            assertParamExists('putFleetsFleetIdSquadsSquadId', 'squadId', squadId)
            // verify required parameter 'naming' is not null or undefined
            assertParamExists('putFleetsFleetIdSquadsSquadId', 'naming', naming)
            const localVarPath = `/fleets/{fleet_id}/squads/{squad_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"squad_id"}}`, encodeURIComponent(String(squadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.write_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(naming, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Rename fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing to rename
         * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
         * @param {PutFleetsFleetIdWingsWingIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdWingsWingId: async (fleetId: number, wingId: number, naming: PutFleetsFleetIdWingsWingIdNaming, datasource?: PutFleetsFleetIdWingsWingIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fleetId' is not null or undefined
            assertParamExists('putFleetsFleetIdWingsWingId', 'fleetId', fleetId)
            // verify required parameter 'wingId' is not null or undefined
            assertParamExists('putFleetsFleetIdWingsWingId', 'wingId', wingId)
            // verify required parameter 'naming' is not null or undefined
            assertParamExists('putFleetsFleetIdWingsWingId', 'naming', naming)
            const localVarPath = `/fleets/{fleet_id}/wings/{wing_id}/`
                .replace(`{${"fleet_id"}}`, encodeURIComponent(String(fleetId)))
                .replace(`{${"wing_id"}}`, encodeURIComponent(String(wingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-fleets.write_fleet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(naming, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FleetsApi - functional programming interface
 */
export const FleetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FleetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Kick fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {DeleteFleetsFleetIdMembersMemberIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, datasource?: DeleteFleetsFleetIdMembersMemberIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFleetsFleetIdMembersMemberId(fleetId, memberId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.deleteFleetsFleetIdMembersMemberId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Delete fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} squadId The squad to delete
         * @param {DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFleetsFleetIdSquadsSquadId(fleetId: number, squadId: number, datasource?: DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFleetsFleetIdSquadsSquadId(fleetId, squadId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.deleteFleetsFleetIdSquadsSquadId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Delete fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing to delete
         * @param {DeleteFleetsFleetIdWingsWingIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFleetsFleetIdWingsWingId(fleetId: number, wingId: number, datasource?: DeleteFleetsFleetIdWingsWingIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFleetsFleetIdWingsWingId(fleetId, wingId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.deleteFleetsFleetIdWingsWingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the fleet ID the character is in, if any.  --- Alternate route: `/dev/characters/{character_id}/fleet/`  Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  Alternate route: `/v2/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds
         * @summary Get character fleet info
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFleetDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdFleet(characterId: number, datasource?: GetCharactersCharacterIdFleetDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdFleetOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdFleet(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.getCharactersCharacterIdFleet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet information
         * @param {number} fleetId ID for a fleet
         * @param {GetFleetsFleetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFleetsFleetId(fleetId: number, datasource?: GetFleetsFleetIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFleetsFleetIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetsFleetId(fleetId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.getFleetsFleetId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet members
         * @param {number} fleetId ID for a fleet
         * @param {GetFleetsFleetIdMembersAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetFleetsFleetIdMembersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetFleetsFleetIdMembersLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFleetsFleetIdMembers(fleetId: number, acceptLanguage?: GetFleetsFleetIdMembersAcceptLanguageEnum, datasource?: GetFleetsFleetIdMembersDatasourceEnum, ifNoneMatch?: string, language?: GetFleetsFleetIdMembersLanguageEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFleetsFleetIdMembers200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetsFleetIdMembers(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.getFleetsFleetIdMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet wings
         * @param {number} fleetId ID for a fleet
         * @param {GetFleetsFleetIdWingsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetFleetsFleetIdWingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetFleetsFleetIdWingsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFleetsFleetIdWings(fleetId: number, acceptLanguage?: GetFleetsFleetIdWingsAcceptLanguageEnum, datasource?: GetFleetsFleetIdWingsDatasourceEnum, ifNoneMatch?: string, language?: GetFleetsFleetIdWingsLanguageEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFleetsFleetIdWings200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFleetsFleetIdWings(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.getFleetsFleetIdWings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/` 
         * @summary Create fleet invitation
         * @param {number} fleetId ID for a fleet
         * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
         * @param {PostFleetsFleetIdMembersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFleetsFleetIdMembers(fleetId: number, invitation: PostFleetsFleetIdMembersInvitation, datasource?: PostFleetsFleetIdMembersDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFleetsFleetIdMembers(fleetId, invitation, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.postFleetsFleetIdMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/` 
         * @summary Create fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {PostFleetsFleetIdWingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFleetsFleetIdWings(fleetId: number, datasource?: PostFleetsFleetIdWingsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostFleetsFleetIdWingsCreated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFleetsFleetIdWings(fleetId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.postFleetsFleetIdWings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/` 
         * @summary Create fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing_id to create squad in
         * @param {PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFleetsFleetIdWingsWingIdSquads(fleetId: number, wingId: number, datasource?: PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostFleetsFleetIdWingsWingIdSquadsCreated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFleetsFleetIdWingsWingIdSquads(fleetId, wingId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.postFleetsFleetIdWingsWingIdSquads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/` 
         * @summary Update fleet
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
         * @param {PutFleetsFleetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFleetsFleetId(fleetId: number, newSettings: PutFleetsFleetIdNewSettings, datasource?: PutFleetsFleetIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFleetsFleetId(fleetId, newSettings, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.putFleetsFleetId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Move fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
         * @param {PutFleetsFleetIdMembersMemberIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, movement: PutFleetsFleetIdMembersMemberIdMovement, datasource?: PutFleetsFleetIdMembersMemberIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFleetsFleetIdMembersMemberId(fleetId, memberId, movement, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.putFleetsFleetIdMembersMemberId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Rename fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} squadId The squad to rename
         * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
         * @param {PutFleetsFleetIdSquadsSquadIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFleetsFleetIdSquadsSquadId(fleetId: number, squadId: number, naming: PutFleetsFleetIdSquadsSquadIdNaming, datasource?: PutFleetsFleetIdSquadsSquadIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFleetsFleetIdSquadsSquadId(fleetId, squadId, naming, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.putFleetsFleetIdSquadsSquadId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Rename fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing to rename
         * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
         * @param {PutFleetsFleetIdWingsWingIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFleetsFleetIdWingsWingId(fleetId: number, wingId: number, naming: PutFleetsFleetIdWingsWingIdNaming, datasource?: PutFleetsFleetIdWingsWingIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFleetsFleetIdWingsWingId(fleetId, wingId, naming, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FleetsApi.putFleetsFleetIdWingsWingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FleetsApi - factory interface
 */
export const FleetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FleetsApiFp(configuration)
    return {
        /**
         * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Kick fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {DeleteFleetsFleetIdMembersMemberIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, datasource?: DeleteFleetsFleetIdMembersMemberIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFleetsFleetIdMembersMemberId(fleetId, memberId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Delete fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} squadId The squad to delete
         * @param {DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdSquadsSquadId(fleetId: number, squadId: number, datasource?: DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFleetsFleetIdSquadsSquadId(fleetId, squadId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Delete fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing to delete
         * @param {DeleteFleetsFleetIdWingsWingIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFleetsFleetIdWingsWingId(fleetId: number, wingId: number, datasource?: DeleteFleetsFleetIdWingsWingIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFleetsFleetIdWingsWingId(fleetId, wingId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the fleet ID the character is in, if any.  --- Alternate route: `/dev/characters/{character_id}/fleet/`  Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  Alternate route: `/v2/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds
         * @summary Get character fleet info
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdFleetDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdFleet(characterId: number, datasource?: GetCharactersCharacterIdFleetDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdFleetOk> {
            return localVarFp.getCharactersCharacterIdFleet(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet information
         * @param {number} fleetId ID for a fleet
         * @param {GetFleetsFleetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetId(fleetId: number, datasource?: GetFleetsFleetIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetFleetsFleetIdOk> {
            return localVarFp.getFleetsFleetId(fleetId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet members
         * @param {number} fleetId ID for a fleet
         * @param {GetFleetsFleetIdMembersAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetFleetsFleetIdMembersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetFleetsFleetIdMembersLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetIdMembers(fleetId: number, acceptLanguage?: GetFleetsFleetIdMembersAcceptLanguageEnum, datasource?: GetFleetsFleetIdMembersDatasourceEnum, ifNoneMatch?: string, language?: GetFleetsFleetIdMembersLanguageEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFleetsFleetIdMembers200Ok>> {
            return localVarFp.getFleetsFleetIdMembers(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
         * @summary Get fleet wings
         * @param {number} fleetId ID for a fleet
         * @param {GetFleetsFleetIdWingsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetFleetsFleetIdWingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetFleetsFleetIdWingsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFleetsFleetIdWings(fleetId: number, acceptLanguage?: GetFleetsFleetIdWingsAcceptLanguageEnum, datasource?: GetFleetsFleetIdWingsDatasourceEnum, ifNoneMatch?: string, language?: GetFleetsFleetIdWingsLanguageEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetFleetsFleetIdWings200Ok>> {
            return localVarFp.getFleetsFleetIdWings(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/` 
         * @summary Create fleet invitation
         * @param {number} fleetId ID for a fleet
         * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
         * @param {PostFleetsFleetIdMembersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdMembers(fleetId: number, invitation: PostFleetsFleetIdMembersInvitation, datasource?: PostFleetsFleetIdMembersDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postFleetsFleetIdMembers(fleetId, invitation, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/` 
         * @summary Create fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {PostFleetsFleetIdWingsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdWings(fleetId: number, datasource?: PostFleetsFleetIdWingsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<PostFleetsFleetIdWingsCreated> {
            return localVarFp.postFleetsFleetIdWings(fleetId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/` 
         * @summary Create fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing_id to create squad in
         * @param {PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFleetsFleetIdWingsWingIdSquads(fleetId: number, wingId: number, datasource?: PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<PostFleetsFleetIdWingsWingIdSquadsCreated> {
            return localVarFp.postFleetsFleetIdWingsWingIdSquads(fleetId, wingId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/` 
         * @summary Update fleet
         * @param {number} fleetId ID for a fleet
         * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
         * @param {PutFleetsFleetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetId(fleetId: number, newSettings: PutFleetsFleetIdNewSettings, datasource?: PutFleetsFleetIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putFleetsFleetId(fleetId, newSettings, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
         * @summary Move fleet member
         * @param {number} fleetId ID for a fleet
         * @param {number} memberId The character ID of a member in this fleet
         * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
         * @param {PutFleetsFleetIdMembersMemberIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, movement: PutFleetsFleetIdMembersMemberIdMovement, datasource?: PutFleetsFleetIdMembersMemberIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putFleetsFleetIdMembersMemberId(fleetId, memberId, movement, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
         * @summary Rename fleet squad
         * @param {number} fleetId ID for a fleet
         * @param {number} squadId The squad to rename
         * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
         * @param {PutFleetsFleetIdSquadsSquadIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdSquadsSquadId(fleetId: number, squadId: number, naming: PutFleetsFleetIdSquadsSquadIdNaming, datasource?: PutFleetsFleetIdSquadsSquadIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putFleetsFleetIdSquadsSquadId(fleetId, squadId, naming, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
         * @summary Rename fleet wing
         * @param {number} fleetId ID for a fleet
         * @param {number} wingId The wing to rename
         * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
         * @param {PutFleetsFleetIdWingsWingIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFleetsFleetIdWingsWingId(fleetId: number, wingId: number, naming: PutFleetsFleetIdWingsWingIdNaming, datasource?: PutFleetsFleetIdWingsWingIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putFleetsFleetIdWingsWingId(fleetId, wingId, naming, datasource, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FleetsApi - object-oriented interface
 */
export class FleetsApi extends BaseAPI {
    /**
     * Kick a fleet member  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
     * @summary Kick fleet member
     * @param {number} fleetId ID for a fleet
     * @param {number} memberId The character ID of a member in this fleet
     * @param {DeleteFleetsFleetIdMembersMemberIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, datasource?: DeleteFleetsFleetIdMembersMemberIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).deleteFleetsFleetIdMembersMemberId(fleetId, memberId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a fleet squad, only empty squads can be deleted  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
     * @summary Delete fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} squadId The squad to delete
     * @param {DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFleetsFleetIdSquadsSquadId(fleetId: number, squadId: number, datasource?: DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).deleteFleetsFleetIdSquadsSquadId(fleetId, squadId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
     * @summary Delete fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing to delete
     * @param {DeleteFleetsFleetIdWingsWingIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFleetsFleetIdWingsWingId(fleetId: number, wingId: number, datasource?: DeleteFleetsFleetIdWingsWingIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).deleteFleetsFleetIdWingsWingId(fleetId, wingId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the fleet ID the character is in, if any.  --- Alternate route: `/dev/characters/{character_id}/fleet/`  Alternate route: `/legacy/characters/{character_id}/fleet/`  Alternate route: `/v1/characters/{character_id}/fleet/`  Alternate route: `/v2/characters/{character_id}/fleet/`  --- This route is cached for up to 60 seconds
     * @summary Get character fleet info
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdFleetDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdFleet(characterId: number, datasource?: GetCharactersCharacterIdFleetDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).getCharactersCharacterIdFleet(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return details about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet information
     * @param {number} fleetId ID for a fleet
     * @param {GetFleetsFleetIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFleetsFleetId(fleetId: number, datasource?: GetFleetsFleetIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).getFleetsFleetId(fleetId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return information about fleet members  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet members
     * @param {number} fleetId ID for a fleet
     * @param {GetFleetsFleetIdMembersAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetFleetsFleetIdMembersDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetFleetsFleetIdMembersLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFleetsFleetIdMembers(fleetId: number, acceptLanguage?: GetFleetsFleetIdMembersAcceptLanguageEnum, datasource?: GetFleetsFleetIdMembersDatasourceEnum, ifNoneMatch?: string, language?: GetFleetsFleetIdMembersLanguageEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).getFleetsFleetIdMembers(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return information about wings in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/`  --- This route is cached for up to 5 seconds
     * @summary Get fleet wings
     * @param {number} fleetId ID for a fleet
     * @param {GetFleetsFleetIdWingsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetFleetsFleetIdWingsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetFleetsFleetIdWingsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFleetsFleetIdWings(fleetId: number, acceptLanguage?: GetFleetsFleetIdWingsAcceptLanguageEnum, datasource?: GetFleetsFleetIdWingsDatasourceEnum, ifNoneMatch?: string, language?: GetFleetsFleetIdWingsLanguageEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).getFleetsFleetIdWings(fleetId, acceptLanguage, datasource, ifNoneMatch, language, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI  --- Alternate route: `/dev/fleets/{fleet_id}/members/`  Alternate route: `/legacy/fleets/{fleet_id}/members/`  Alternate route: `/v1/fleets/{fleet_id}/members/` 
     * @summary Create fleet invitation
     * @param {number} fleetId ID for a fleet
     * @param {PostFleetsFleetIdMembersInvitation} invitation Details of the invitation
     * @param {PostFleetsFleetIdMembersDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFleetsFleetIdMembers(fleetId: number, invitation: PostFleetsFleetIdMembersInvitation, datasource?: PostFleetsFleetIdMembersDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).postFleetsFleetIdMembers(fleetId, invitation, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new wing in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/`  Alternate route: `/v1/fleets/{fleet_id}/wings/` 
     * @summary Create fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {PostFleetsFleetIdWingsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFleetsFleetIdWings(fleetId: number, datasource?: PostFleetsFleetIdWingsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).postFleetsFleetIdWings(fleetId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new squad in a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/` 
     * @summary Create fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing_id to create squad in
     * @param {PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFleetsFleetIdWingsWingIdSquads(fleetId: number, wingId: number, datasource?: PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).postFleetsFleetIdWingsWingIdSquads(fleetId, wingId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update settings about a fleet  --- Alternate route: `/dev/fleets/{fleet_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/`  Alternate route: `/v1/fleets/{fleet_id}/` 
     * @summary Update fleet
     * @param {number} fleetId ID for a fleet
     * @param {PutFleetsFleetIdNewSettings} newSettings What to update for this fleet
     * @param {PutFleetsFleetIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFleetsFleetId(fleetId: number, newSettings: PutFleetsFleetIdNewSettings, datasource?: PutFleetsFleetIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).putFleetsFleetId(fleetId, newSettings, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move a fleet member around  --- Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`  Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/` 
     * @summary Move fleet member
     * @param {number} fleetId ID for a fleet
     * @param {number} memberId The character ID of a member in this fleet
     * @param {PutFleetsFleetIdMembersMemberIdMovement} movement Details of the invitation
     * @param {PutFleetsFleetIdMembersMemberIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFleetsFleetIdMembersMemberId(fleetId: number, memberId: number, movement: PutFleetsFleetIdMembersMemberIdMovement, datasource?: PutFleetsFleetIdMembersMemberIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).putFleetsFleetIdMembersMemberId(fleetId, memberId, movement, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rename a fleet squad  --- Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`  Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/` 
     * @summary Rename fleet squad
     * @param {number} fleetId ID for a fleet
     * @param {number} squadId The squad to rename
     * @param {PutFleetsFleetIdSquadsSquadIdNaming} naming New name of the squad
     * @param {PutFleetsFleetIdSquadsSquadIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFleetsFleetIdSquadsSquadId(fleetId: number, squadId: number, naming: PutFleetsFleetIdSquadsSquadIdNaming, datasource?: PutFleetsFleetIdSquadsSquadIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).putFleetsFleetIdSquadsSquadId(fleetId, squadId, naming, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rename a fleet wing  --- Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`  Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/` 
     * @summary Rename fleet wing
     * @param {number} fleetId ID for a fleet
     * @param {number} wingId The wing to rename
     * @param {PutFleetsFleetIdWingsWingIdNaming} naming New name of the wing
     * @param {PutFleetsFleetIdWingsWingIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFleetsFleetIdWingsWingId(fleetId: number, wingId: number, naming: PutFleetsFleetIdWingsWingIdNaming, datasource?: PutFleetsFleetIdWingsWingIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return FleetsApiFp(this.configuration).putFleetsFleetIdWingsWingId(fleetId, wingId, naming, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const DeleteFleetsFleetIdMembersMemberIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type DeleteFleetsFleetIdMembersMemberIdDatasourceEnum = typeof DeleteFleetsFleetIdMembersMemberIdDatasourceEnum[keyof typeof DeleteFleetsFleetIdMembersMemberIdDatasourceEnum];
export const DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum = typeof DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum[keyof typeof DeleteFleetsFleetIdSquadsSquadIdDatasourceEnum];
export const DeleteFleetsFleetIdWingsWingIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type DeleteFleetsFleetIdWingsWingIdDatasourceEnum = typeof DeleteFleetsFleetIdWingsWingIdDatasourceEnum[keyof typeof DeleteFleetsFleetIdWingsWingIdDatasourceEnum];
export const GetCharactersCharacterIdFleetDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdFleetDatasourceEnum = typeof GetCharactersCharacterIdFleetDatasourceEnum[keyof typeof GetCharactersCharacterIdFleetDatasourceEnum];
export const GetFleetsFleetIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetFleetsFleetIdDatasourceEnum = typeof GetFleetsFleetIdDatasourceEnum[keyof typeof GetFleetsFleetIdDatasourceEnum];
export const GetFleetsFleetIdMembersAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetFleetsFleetIdMembersAcceptLanguageEnum = typeof GetFleetsFleetIdMembersAcceptLanguageEnum[keyof typeof GetFleetsFleetIdMembersAcceptLanguageEnum];
export const GetFleetsFleetIdMembersDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetFleetsFleetIdMembersDatasourceEnum = typeof GetFleetsFleetIdMembersDatasourceEnum[keyof typeof GetFleetsFleetIdMembersDatasourceEnum];
export const GetFleetsFleetIdMembersLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetFleetsFleetIdMembersLanguageEnum = typeof GetFleetsFleetIdMembersLanguageEnum[keyof typeof GetFleetsFleetIdMembersLanguageEnum];
export const GetFleetsFleetIdWingsAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetFleetsFleetIdWingsAcceptLanguageEnum = typeof GetFleetsFleetIdWingsAcceptLanguageEnum[keyof typeof GetFleetsFleetIdWingsAcceptLanguageEnum];
export const GetFleetsFleetIdWingsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetFleetsFleetIdWingsDatasourceEnum = typeof GetFleetsFleetIdWingsDatasourceEnum[keyof typeof GetFleetsFleetIdWingsDatasourceEnum];
export const GetFleetsFleetIdWingsLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetFleetsFleetIdWingsLanguageEnum = typeof GetFleetsFleetIdWingsLanguageEnum[keyof typeof GetFleetsFleetIdWingsLanguageEnum];
export const PostFleetsFleetIdMembersDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostFleetsFleetIdMembersDatasourceEnum = typeof PostFleetsFleetIdMembersDatasourceEnum[keyof typeof PostFleetsFleetIdMembersDatasourceEnum];
export const PostFleetsFleetIdWingsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostFleetsFleetIdWingsDatasourceEnum = typeof PostFleetsFleetIdWingsDatasourceEnum[keyof typeof PostFleetsFleetIdWingsDatasourceEnum];
export const PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum = typeof PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum[keyof typeof PostFleetsFleetIdWingsWingIdSquadsDatasourceEnum];
export const PutFleetsFleetIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PutFleetsFleetIdDatasourceEnum = typeof PutFleetsFleetIdDatasourceEnum[keyof typeof PutFleetsFleetIdDatasourceEnum];
export const PutFleetsFleetIdMembersMemberIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PutFleetsFleetIdMembersMemberIdDatasourceEnum = typeof PutFleetsFleetIdMembersMemberIdDatasourceEnum[keyof typeof PutFleetsFleetIdMembersMemberIdDatasourceEnum];
export const PutFleetsFleetIdSquadsSquadIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PutFleetsFleetIdSquadsSquadIdDatasourceEnum = typeof PutFleetsFleetIdSquadsSquadIdDatasourceEnum[keyof typeof PutFleetsFleetIdSquadsSquadIdDatasourceEnum];
export const PutFleetsFleetIdWingsWingIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PutFleetsFleetIdWingsWingIdDatasourceEnum = typeof PutFleetsFleetIdWingsWingIdDatasourceEnum[keyof typeof PutFleetsFleetIdWingsWingIdDatasourceEnum];


/**
 * IncursionsApi - axios parameter creator
 */
export const IncursionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
         * @summary List incursions
         * @param {GetIncursionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncursions: async (datasource?: GetIncursionsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/incursions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IncursionsApi - functional programming interface
 */
export const IncursionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IncursionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
         * @summary List incursions
         * @param {GetIncursionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncursions(datasource?: GetIncursionsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetIncursions200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncursions(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncursionsApi.getIncursions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IncursionsApi - factory interface
 */
export const IncursionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IncursionsApiFp(configuration)
    return {
        /**
         * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
         * @summary List incursions
         * @param {GetIncursionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncursions(datasource?: GetIncursionsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetIncursions200Ok>> {
            return localVarFp.getIncursions(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IncursionsApi - object-oriented interface
 */
export class IncursionsApi extends BaseAPI {
    /**
     * Return a list of current incursions  --- Alternate route: `/dev/incursions/`  Alternate route: `/legacy/incursions/`  Alternate route: `/v1/incursions/`  --- This route is cached for up to 300 seconds
     * @summary List incursions
     * @param {GetIncursionsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getIncursions(datasource?: GetIncursionsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return IncursionsApiFp(this.configuration).getIncursions(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetIncursionsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetIncursionsDatasourceEnum = typeof GetIncursionsDatasourceEnum[keyof typeof GetIncursionsDatasourceEnum];


/**
 * IndustryApi - axios parameter creator
 */
export const IndustryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
         * @summary List character industry jobs
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdIndustryJobsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdIndustryJobs: async (characterId: number, datasource?: GetCharactersCharacterIdIndustryJobsDatasourceEnum, ifNoneMatch?: string, includeCompleted?: boolean, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdIndustryJobs', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/industry/jobs/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-industry.read_character_jobs.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (includeCompleted !== undefined) {
                localVarQueryParameter['include_completed'] = includeCompleted;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
         * @summary Character mining ledger
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMiningDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMining: async (characterId: number, datasource?: GetCharactersCharacterIdMiningDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdMining', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/mining/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-industry.read_character_mining.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Moon extraction timers
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationCorporationIdMiningExtractionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningExtractions: async (corporationId: number, datasource?: GetCorporationCorporationIdMiningExtractionsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationCorporationIdMiningExtractions', 'corporationId', corporationId)
            const localVarPath = `/corporation/{corporation_id}/mining/extractions/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-industry.read_corporation_mining.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Corporation mining observers
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationCorporationIdMiningObserversDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningObservers: async (corporationId: number, datasource?: GetCorporationCorporationIdMiningObserversDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationCorporationIdMiningObservers', 'corporationId', corporationId)
            const localVarPath = `/corporation/{corporation_id}/mining/observers/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-industry.read_corporation_mining.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Observed corporation mining
         * @param {number} corporationId An EVE corporation ID
         * @param {number} observerId A mining observer id
         * @param {GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningObserversObserverId: async (corporationId: number, observerId: number, datasource?: GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationCorporationIdMiningObserversObserverId', 'corporationId', corporationId)
            // verify required parameter 'observerId' is not null or undefined
            assertParamExists('getCorporationCorporationIdMiningObserversObserverId', 'observerId', observerId)
            const localVarPath = `/corporation/{corporation_id}/mining/observers/{observer_id}/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)))
                .replace(`{${"observer_id"}}`, encodeURIComponent(String(observerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-industry.read_corporation_mining.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary List corporation industry jobs
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdIndustryJobsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdIndustryJobs: async (corporationId: number, datasource?: GetCorporationsCorporationIdIndustryJobsDatasourceEnum, ifNoneMatch?: string, includeCompleted?: boolean, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdIndustryJobs', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/industry/jobs/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-industry.read_corporation_jobs.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (includeCompleted !== undefined) {
                localVarQueryParameter['include_completed'] = includeCompleted;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
         * @summary List industry facilities
         * @param {GetIndustryFacilitiesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndustryFacilities: async (datasource?: GetIndustryFacilitiesDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/industry/facilities/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
         * @summary List solar system cost indices
         * @param {GetIndustrySystemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndustrySystems: async (datasource?: GetIndustrySystemsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/industry/systems/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IndustryApi - functional programming interface
 */
export const IndustryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IndustryApiAxiosParamCreator(configuration)
    return {
        /**
         * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
         * @summary List character industry jobs
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdIndustryJobsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdIndustryJobs(characterId: number, datasource?: GetCharactersCharacterIdIndustryJobsDatasourceEnum, ifNoneMatch?: string, includeCompleted?: boolean, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdIndustryJobs200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdIndustryJobs(characterId, datasource, ifNoneMatch, includeCompleted, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndustryApi.getCharactersCharacterIdIndustryJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
         * @summary Character mining ledger
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMiningDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdMining(characterId: number, datasource?: GetCharactersCharacterIdMiningDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdMining200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdMining(characterId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndustryApi.getCharactersCharacterIdMining']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Moon extraction timers
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationCorporationIdMiningExtractionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationCorporationIdMiningExtractions(corporationId: number, datasource?: GetCorporationCorporationIdMiningExtractionsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationCorporationIdMiningExtractions200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationCorporationIdMiningExtractions(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndustryApi.getCorporationCorporationIdMiningExtractions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Corporation mining observers
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationCorporationIdMiningObserversDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationCorporationIdMiningObservers(corporationId: number, datasource?: GetCorporationCorporationIdMiningObserversDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationCorporationIdMiningObservers200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationCorporationIdMiningObservers(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndustryApi.getCorporationCorporationIdMiningObservers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Observed corporation mining
         * @param {number} corporationId An EVE corporation ID
         * @param {number} observerId A mining observer id
         * @param {GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationCorporationIdMiningObserversObserverId(corporationId: number, observerId: number, datasource?: GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationCorporationIdMiningObserversObserverId200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationCorporationIdMiningObserversObserverId(corporationId, observerId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndustryApi.getCorporationCorporationIdMiningObserversObserverId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary List corporation industry jobs
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdIndustryJobsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdIndustryJobs(corporationId: number, datasource?: GetCorporationsCorporationIdIndustryJobsDatasourceEnum, ifNoneMatch?: string, includeCompleted?: boolean, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdIndustryJobs200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdIndustryJobs(corporationId, datasource, ifNoneMatch, includeCompleted, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndustryApi.getCorporationsCorporationIdIndustryJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
         * @summary List industry facilities
         * @param {GetIndustryFacilitiesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndustryFacilities(datasource?: GetIndustryFacilitiesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetIndustryFacilities200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndustryFacilities(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndustryApi.getIndustryFacilities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
         * @summary List solar system cost indices
         * @param {GetIndustrySystemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndustrySystems(datasource?: GetIndustrySystemsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetIndustrySystems200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndustrySystems(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndustryApi.getIndustrySystems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IndustryApi - factory interface
 */
export const IndustryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IndustryApiFp(configuration)
    return {
        /**
         * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
         * @summary List character industry jobs
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdIndustryJobsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdIndustryJobs(characterId: number, datasource?: GetCharactersCharacterIdIndustryJobsDatasourceEnum, ifNoneMatch?: string, includeCompleted?: boolean, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdIndustryJobs200Ok>> {
            return localVarFp.getCharactersCharacterIdIndustryJobs(characterId, datasource, ifNoneMatch, includeCompleted, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
         * @summary Character mining ledger
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMiningDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMining(characterId: number, datasource?: GetCharactersCharacterIdMiningDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdMining200Ok>> {
            return localVarFp.getCharactersCharacterIdMining(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
         * @summary Moon extraction timers
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationCorporationIdMiningExtractionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningExtractions(corporationId: number, datasource?: GetCorporationCorporationIdMiningExtractionsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationCorporationIdMiningExtractions200Ok>> {
            return localVarFp.getCorporationCorporationIdMiningExtractions(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Corporation mining observers
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationCorporationIdMiningObserversDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningObservers(corporationId: number, datasource?: GetCorporationCorporationIdMiningObserversDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationCorporationIdMiningObservers200Ok>> {
            return localVarFp.getCorporationCorporationIdMiningObservers(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
         * @summary Observed corporation mining
         * @param {number} corporationId An EVE corporation ID
         * @param {number} observerId A mining observer id
         * @param {GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationCorporationIdMiningObserversObserverId(corporationId: number, observerId: number, datasource?: GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationCorporationIdMiningObserversObserverId200Ok>> {
            return localVarFp.getCorporationCorporationIdMiningObserversObserverId(corporationId, observerId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
         * @summary List corporation industry jobs
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdIndustryJobsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdIndustryJobs(corporationId: number, datasource?: GetCorporationsCorporationIdIndustryJobsDatasourceEnum, ifNoneMatch?: string, includeCompleted?: boolean, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdIndustryJobs200Ok>> {
            return localVarFp.getCorporationsCorporationIdIndustryJobs(corporationId, datasource, ifNoneMatch, includeCompleted, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
         * @summary List industry facilities
         * @param {GetIndustryFacilitiesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndustryFacilities(datasource?: GetIndustryFacilitiesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetIndustryFacilities200Ok>> {
            return localVarFp.getIndustryFacilities(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
         * @summary List solar system cost indices
         * @param {GetIndustrySystemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndustrySystems(datasource?: GetIndustrySystemsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetIndustrySystems200Ok>> {
            return localVarFp.getIndustrySystems(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IndustryApi - object-oriented interface
 */
export class IndustryApi extends BaseAPI {
    /**
     * List industry jobs placed by a character  --- Alternate route: `/dev/characters/{character_id}/industry/jobs/`  Alternate route: `/legacy/characters/{character_id}/industry/jobs/`  Alternate route: `/v1/characters/{character_id}/industry/jobs/`  --- This route is cached for up to 300 seconds
     * @summary List character industry jobs
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdIndustryJobsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {boolean} [includeCompleted] Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdIndustryJobs(characterId: number, datasource?: GetCharactersCharacterIdIndustryJobsDatasourceEnum, ifNoneMatch?: string, includeCompleted?: boolean, token?: string, options?: RawAxiosRequestConfig) {
        return IndustryApiFp(this.configuration).getCharactersCharacterIdIndustryJobs(characterId, datasource, ifNoneMatch, includeCompleted, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Paginated record of all mining done by a character for the past 30 days   --- Alternate route: `/dev/characters/{character_id}/mining/`  Alternate route: `/legacy/characters/{character_id}/mining/`  Alternate route: `/v1/characters/{character_id}/mining/`  --- This route is cached for up to 600 seconds
     * @summary Character mining ledger
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdMiningDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdMining(characterId: number, datasource?: GetCharactersCharacterIdMiningDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return IndustryApiFp(this.configuration).getCharactersCharacterIdMining(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.   --- Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`  Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`  --- This route is cached for up to 1800 seconds  --- Requires one of the following EVE corporation role(s): Station_Manager 
     * @summary Moon extraction timers
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationCorporationIdMiningExtractionsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationCorporationIdMiningExtractions(corporationId: number, datasource?: GetCorporationCorporationIdMiningExtractionsDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return IndustryApiFp(this.configuration).getCorporationCorporationIdMiningExtractions(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Paginated list of all entities capable of observing and recording mining for a corporation   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
     * @summary Corporation mining observers
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationCorporationIdMiningObserversDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationCorporationIdMiningObservers(corporationId: number, datasource?: GetCorporationCorporationIdMiningObserversDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return IndustryApiFp(this.configuration).getCorporationCorporationIdMiningObservers(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Paginated record of all mining seen by an observer   --- Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`  Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant 
     * @summary Observed corporation mining
     * @param {number} corporationId An EVE corporation ID
     * @param {number} observerId A mining observer id
     * @param {GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationCorporationIdMiningObserversObserverId(corporationId: number, observerId: number, datasource?: GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return IndustryApiFp(this.configuration).getCorporationCorporationIdMiningObserversObserverId(corporationId, observerId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List industry jobs run by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`  Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Factory_Manager 
     * @summary List corporation industry jobs
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdIndustryJobsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {boolean} [includeCompleted] Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdIndustryJobs(corporationId: number, datasource?: GetCorporationsCorporationIdIndustryJobsDatasourceEnum, ifNoneMatch?: string, includeCompleted?: boolean, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return IndustryApiFp(this.configuration).getCorporationsCorporationIdIndustryJobs(corporationId, datasource, ifNoneMatch, includeCompleted, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of industry facilities  --- Alternate route: `/dev/industry/facilities/`  Alternate route: `/legacy/industry/facilities/`  Alternate route: `/v1/industry/facilities/`  --- This route is cached for up to 3600 seconds
     * @summary List industry facilities
     * @param {GetIndustryFacilitiesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getIndustryFacilities(datasource?: GetIndustryFacilitiesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return IndustryApiFp(this.configuration).getIndustryFacilities(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return cost indices for solar systems  --- Alternate route: `/dev/industry/systems/`  Alternate route: `/legacy/industry/systems/`  Alternate route: `/v1/industry/systems/`  --- This route is cached for up to 3600 seconds
     * @summary List solar system cost indices
     * @param {GetIndustrySystemsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getIndustrySystems(datasource?: GetIndustrySystemsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return IndustryApiFp(this.configuration).getIndustrySystems(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdIndustryJobsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdIndustryJobsDatasourceEnum = typeof GetCharactersCharacterIdIndustryJobsDatasourceEnum[keyof typeof GetCharactersCharacterIdIndustryJobsDatasourceEnum];
export const GetCharactersCharacterIdMiningDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdMiningDatasourceEnum = typeof GetCharactersCharacterIdMiningDatasourceEnum[keyof typeof GetCharactersCharacterIdMiningDatasourceEnum];
export const GetCorporationCorporationIdMiningExtractionsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationCorporationIdMiningExtractionsDatasourceEnum = typeof GetCorporationCorporationIdMiningExtractionsDatasourceEnum[keyof typeof GetCorporationCorporationIdMiningExtractionsDatasourceEnum];
export const GetCorporationCorporationIdMiningObserversDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationCorporationIdMiningObserversDatasourceEnum = typeof GetCorporationCorporationIdMiningObserversDatasourceEnum[keyof typeof GetCorporationCorporationIdMiningObserversDatasourceEnum];
export const GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum = typeof GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum[keyof typeof GetCorporationCorporationIdMiningObserversObserverIdDatasourceEnum];
export const GetCorporationsCorporationIdIndustryJobsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdIndustryJobsDatasourceEnum = typeof GetCorporationsCorporationIdIndustryJobsDatasourceEnum[keyof typeof GetCorporationsCorporationIdIndustryJobsDatasourceEnum];
export const GetIndustryFacilitiesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetIndustryFacilitiesDatasourceEnum = typeof GetIndustryFacilitiesDatasourceEnum[keyof typeof GetIndustryFacilitiesDatasourceEnum];
export const GetIndustrySystemsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetIndustrySystemsDatasourceEnum = typeof GetIndustrySystemsDatasourceEnum[keyof typeof GetIndustrySystemsDatasourceEnum];


/**
 * InsuranceApi - axios parameter creator
 */
export const InsuranceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List insurance levels
         * @param {GetInsurancePricesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetInsurancePricesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetInsurancePricesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsurancePrices: async (acceptLanguage?: GetInsurancePricesAcceptLanguageEnum, datasource?: GetInsurancePricesDatasourceEnum, ifNoneMatch?: string, language?: GetInsurancePricesLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insurance/prices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsuranceApi - functional programming interface
 */
export const InsuranceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InsuranceApiAxiosParamCreator(configuration)
    return {
        /**
         * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List insurance levels
         * @param {GetInsurancePricesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetInsurancePricesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetInsurancePricesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInsurancePrices(acceptLanguage?: GetInsurancePricesAcceptLanguageEnum, datasource?: GetInsurancePricesDatasourceEnum, ifNoneMatch?: string, language?: GetInsurancePricesLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetInsurancePrices200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInsurancePrices(acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InsuranceApi.getInsurancePrices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InsuranceApi - factory interface
 */
export const InsuranceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InsuranceApiFp(configuration)
    return {
        /**
         * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List insurance levels
         * @param {GetInsurancePricesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetInsurancePricesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetInsurancePricesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsurancePrices(acceptLanguage?: GetInsurancePricesAcceptLanguageEnum, datasource?: GetInsurancePricesDatasourceEnum, ifNoneMatch?: string, language?: GetInsurancePricesLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetInsurancePrices200Ok>> {
            return localVarFp.getInsurancePrices(acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsuranceApi - object-oriented interface
 */
export class InsuranceApi extends BaseAPI {
    /**
     * Return available insurance levels for all ship types  --- Alternate route: `/dev/insurance/prices/`  Alternate route: `/legacy/insurance/prices/`  Alternate route: `/v1/insurance/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List insurance levels
     * @param {GetInsurancePricesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetInsurancePricesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetInsurancePricesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getInsurancePrices(acceptLanguage?: GetInsurancePricesAcceptLanguageEnum, datasource?: GetInsurancePricesDatasourceEnum, ifNoneMatch?: string, language?: GetInsurancePricesLanguageEnum, options?: RawAxiosRequestConfig) {
        return InsuranceApiFp(this.configuration).getInsurancePrices(acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetInsurancePricesAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetInsurancePricesAcceptLanguageEnum = typeof GetInsurancePricesAcceptLanguageEnum[keyof typeof GetInsurancePricesAcceptLanguageEnum];
export const GetInsurancePricesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetInsurancePricesDatasourceEnum = typeof GetInsurancePricesDatasourceEnum[keyof typeof GetInsurancePricesDatasourceEnum];
export const GetInsurancePricesLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetInsurancePricesLanguageEnum = typeof GetInsurancePricesLanguageEnum[keyof typeof GetInsurancePricesLanguageEnum];


/**
 * KillmailsApi - axios parameter creator
 */
export const KillmailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of a character\'s kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
         * @summary Get a character\'s recent kills and losses
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdKillmailsRecentDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdKillmailsRecent: async (characterId: number, datasource?: GetCharactersCharacterIdKillmailsRecentDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdKillmailsRecent', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/killmails/recent/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-killmails.read_killmails.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of a corporation\'s kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get a corporation\'s recent kills and losses
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdKillmailsRecentDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdKillmailsRecent: async (corporationId: number, datasource?: GetCorporationsCorporationIdKillmailsRecentDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdKillmailsRecent', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/killmails/recent/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-killmails.read_corporation_killmails.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
         * @summary Get a single killmail
         * @param {string} killmailHash The killmail hash for verification
         * @param {number} killmailId The killmail ID to be queried
         * @param {GetKillmailsKillmailIdKillmailHashDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKillmailsKillmailIdKillmailHash: async (killmailHash: string, killmailId: number, datasource?: GetKillmailsKillmailIdKillmailHashDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'killmailHash' is not null or undefined
            assertParamExists('getKillmailsKillmailIdKillmailHash', 'killmailHash', killmailHash)
            // verify required parameter 'killmailId' is not null or undefined
            assertParamExists('getKillmailsKillmailIdKillmailHash', 'killmailId', killmailId)
            const localVarPath = `/killmails/{killmail_id}/{killmail_hash}/`
                .replace(`{${"killmail_hash"}}`, encodeURIComponent(String(killmailHash)))
                .replace(`{${"killmail_id"}}`, encodeURIComponent(String(killmailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KillmailsApi - functional programming interface
 */
export const KillmailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KillmailsApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a list of a character\'s kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
         * @summary Get a character\'s recent kills and losses
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdKillmailsRecentDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdKillmailsRecent(characterId: number, datasource?: GetCharactersCharacterIdKillmailsRecentDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdKillmailsRecent200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdKillmailsRecent(characterId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KillmailsApi.getCharactersCharacterIdKillmailsRecent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of a corporation\'s kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get a corporation\'s recent kills and losses
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdKillmailsRecentDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdKillmailsRecent(corporationId: number, datasource?: GetCorporationsCorporationIdKillmailsRecentDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdKillmailsRecent200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdKillmailsRecent(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KillmailsApi.getCorporationsCorporationIdKillmailsRecent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
         * @summary Get a single killmail
         * @param {string} killmailHash The killmail hash for verification
         * @param {number} killmailId The killmail ID to be queried
         * @param {GetKillmailsKillmailIdKillmailHashDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKillmailsKillmailIdKillmailHash(killmailHash: string, killmailId: number, datasource?: GetKillmailsKillmailIdKillmailHashDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetKillmailsKillmailIdKillmailHashOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKillmailsKillmailIdKillmailHash(killmailHash, killmailId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KillmailsApi.getKillmailsKillmailIdKillmailHash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KillmailsApi - factory interface
 */
export const KillmailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KillmailsApiFp(configuration)
    return {
        /**
         * Return a list of a character\'s kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
         * @summary Get a character\'s recent kills and losses
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdKillmailsRecentDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdKillmailsRecent(characterId: number, datasource?: GetCharactersCharacterIdKillmailsRecentDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdKillmailsRecent200Ok>> {
            return localVarFp.getCharactersCharacterIdKillmailsRecent(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of a corporation\'s kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary Get a corporation\'s recent kills and losses
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdKillmailsRecentDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdKillmailsRecent(corporationId: number, datasource?: GetCorporationsCorporationIdKillmailsRecentDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdKillmailsRecent200Ok>> {
            return localVarFp.getCorporationsCorporationIdKillmailsRecent(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
         * @summary Get a single killmail
         * @param {string} killmailHash The killmail hash for verification
         * @param {number} killmailId The killmail ID to be queried
         * @param {GetKillmailsKillmailIdKillmailHashDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKillmailsKillmailIdKillmailHash(killmailHash: string, killmailId: number, datasource?: GetKillmailsKillmailIdKillmailHashDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetKillmailsKillmailIdKillmailHashOk> {
            return localVarFp.getKillmailsKillmailIdKillmailHash(killmailHash, killmailId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KillmailsApi - object-oriented interface
 */
export class KillmailsApi extends BaseAPI {
    /**
     * Return a list of a character\'s kills and losses going back 90 days  --- Alternate route: `/dev/characters/{character_id}/killmails/recent/`  Alternate route: `/legacy/characters/{character_id}/killmails/recent/`  Alternate route: `/v1/characters/{character_id}/killmails/recent/`  --- This route is cached for up to 300 seconds
     * @summary Get a character\'s recent kills and losses
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdKillmailsRecentDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdKillmailsRecent(characterId: number, datasource?: GetCharactersCharacterIdKillmailsRecentDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return KillmailsApiFp(this.configuration).getCharactersCharacterIdKillmailsRecent(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of a corporation\'s kills and losses going back 90 days  --- Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`  Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary Get a corporation\'s recent kills and losses
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdKillmailsRecentDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdKillmailsRecent(corporationId: number, datasource?: GetCorporationsCorporationIdKillmailsRecentDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return KillmailsApiFp(this.configuration).getCorporationsCorporationIdKillmailsRecent(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a single killmail from its ID and hash  --- Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`  Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`  --- This route is cached for up to 30758400 seconds
     * @summary Get a single killmail
     * @param {string} killmailHash The killmail hash for verification
     * @param {number} killmailId The killmail ID to be queried
     * @param {GetKillmailsKillmailIdKillmailHashDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getKillmailsKillmailIdKillmailHash(killmailHash: string, killmailId: number, datasource?: GetKillmailsKillmailIdKillmailHashDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return KillmailsApiFp(this.configuration).getKillmailsKillmailIdKillmailHash(killmailHash, killmailId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdKillmailsRecentDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdKillmailsRecentDatasourceEnum = typeof GetCharactersCharacterIdKillmailsRecentDatasourceEnum[keyof typeof GetCharactersCharacterIdKillmailsRecentDatasourceEnum];
export const GetCorporationsCorporationIdKillmailsRecentDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdKillmailsRecentDatasourceEnum = typeof GetCorporationsCorporationIdKillmailsRecentDatasourceEnum[keyof typeof GetCorporationsCorporationIdKillmailsRecentDatasourceEnum];
export const GetKillmailsKillmailIdKillmailHashDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetKillmailsKillmailIdKillmailHashDatasourceEnum = typeof GetKillmailsKillmailIdKillmailHashDatasourceEnum[keyof typeof GetKillmailsKillmailIdKillmailHashDatasourceEnum];


/**
 * LocationApi - axios parameter creator
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
         * @summary Get character location
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdLocationDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdLocation: async (characterId: number, datasource?: GetCharactersCharacterIdLocationDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdLocation', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/location/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-location.read_location.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
         * @summary Get character online
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdOnlineDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOnline: async (characterId: number, datasource?: GetCharactersCharacterIdOnlineDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdOnline', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/online/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-location.read_online.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
         * @summary Get current ship
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdShipDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdShip: async (characterId: number, datasource?: GetCharactersCharacterIdShipDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdShip', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/ship/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-location.read_ship_type.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
         * @summary Get character location
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdLocationDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdLocation(characterId: number, datasource?: GetCharactersCharacterIdLocationDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdLocationOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdLocation(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.getCharactersCharacterIdLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
         * @summary Get character online
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdOnlineDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdOnline(characterId: number, datasource?: GetCharactersCharacterIdOnlineDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdOnlineOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdOnline(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.getCharactersCharacterIdOnline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
         * @summary Get current ship
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdShipDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdShip(characterId: number, datasource?: GetCharactersCharacterIdShipDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdShipOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdShip(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.getCharactersCharacterIdShip']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
         * @summary Get character location
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdLocationDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdLocation(characterId: number, datasource?: GetCharactersCharacterIdLocationDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdLocationOk> {
            return localVarFp.getCharactersCharacterIdLocation(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
         * @summary Get character online
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdOnlineDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOnline(characterId: number, datasource?: GetCharactersCharacterIdOnlineDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdOnlineOk> {
            return localVarFp.getCharactersCharacterIdOnline(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
         * @summary Get current ship
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdShipDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdShip(characterId: number, datasource?: GetCharactersCharacterIdShipDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdShipOk> {
            return localVarFp.getCharactersCharacterIdShip(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationApi - object-oriented interface
 */
export class LocationApi extends BaseAPI {
    /**
     * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable  --- Alternate route: `/dev/characters/{character_id}/location/`  Alternate route: `/legacy/characters/{character_id}/location/`  Alternate route: `/v1/characters/{character_id}/location/`  Alternate route: `/v2/characters/{character_id}/location/`  --- This route is cached for up to 5 seconds
     * @summary Get character location
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdLocationDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdLocation(characterId: number, datasource?: GetCharactersCharacterIdLocationDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).getCharactersCharacterIdLocation(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the character is currently online  --- Alternate route: `/dev/characters/{character_id}/online/`  Alternate route: `/v2/characters/{character_id}/online/`  Alternate route: `/v3/characters/{character_id}/online/`  --- This route is cached for up to 60 seconds
     * @summary Get character online
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdOnlineDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdOnline(characterId: number, datasource?: GetCharactersCharacterIdOnlineDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).getCharactersCharacterIdOnline(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current ship type, name and id  --- Alternate route: `/dev/characters/{character_id}/ship/`  Alternate route: `/legacy/characters/{character_id}/ship/`  Alternate route: `/v1/characters/{character_id}/ship/`  Alternate route: `/v2/characters/{character_id}/ship/`  --- This route is cached for up to 5 seconds
     * @summary Get current ship
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdShipDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdShip(characterId: number, datasource?: GetCharactersCharacterIdShipDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).getCharactersCharacterIdShip(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdLocationDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdLocationDatasourceEnum = typeof GetCharactersCharacterIdLocationDatasourceEnum[keyof typeof GetCharactersCharacterIdLocationDatasourceEnum];
export const GetCharactersCharacterIdOnlineDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdOnlineDatasourceEnum = typeof GetCharactersCharacterIdOnlineDatasourceEnum[keyof typeof GetCharactersCharacterIdOnlineDatasourceEnum];
export const GetCharactersCharacterIdShipDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdShipDatasourceEnum = typeof GetCharactersCharacterIdShipDatasourceEnum[keyof typeof GetCharactersCharacterIdShipDatasourceEnum];


/**
 * LoyaltyApi - axios parameter creator
 */
export const LoyaltyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
         * @summary Get loyalty points
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdLoyaltyPointsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdLoyaltyPoints: async (characterId: number, datasource?: GetCharactersCharacterIdLoyaltyPointsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdLoyaltyPoints', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/loyalty/points/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-characters.read_loyalty.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of offers from a specific corporation\'s loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
         * @summary List loyalty store offers
         * @param {number} corporationId An EVE corporation ID
         * @param {GetLoyaltyStoresCorporationIdOffersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoyaltyStoresCorporationIdOffers: async (corporationId: number, datasource?: GetLoyaltyStoresCorporationIdOffersDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getLoyaltyStoresCorporationIdOffers', 'corporationId', corporationId)
            const localVarPath = `/loyalty/stores/{corporation_id}/offers/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoyaltyApi - functional programming interface
 */
export const LoyaltyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoyaltyApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
         * @summary Get loyalty points
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdLoyaltyPointsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdLoyaltyPoints(characterId: number, datasource?: GetCharactersCharacterIdLoyaltyPointsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdLoyaltyPoints200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdLoyaltyPoints(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoyaltyApi.getCharactersCharacterIdLoyaltyPoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of offers from a specific corporation\'s loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
         * @summary List loyalty store offers
         * @param {number} corporationId An EVE corporation ID
         * @param {GetLoyaltyStoresCorporationIdOffersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoyaltyStoresCorporationIdOffers(corporationId: number, datasource?: GetLoyaltyStoresCorporationIdOffersDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetLoyaltyStoresCorporationIdOffers200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoyaltyStoresCorporationIdOffers(corporationId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoyaltyApi.getLoyaltyStoresCorporationIdOffers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LoyaltyApi - factory interface
 */
export const LoyaltyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoyaltyApiFp(configuration)
    return {
        /**
         * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
         * @summary Get loyalty points
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdLoyaltyPointsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdLoyaltyPoints(characterId: number, datasource?: GetCharactersCharacterIdLoyaltyPointsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdLoyaltyPoints200Ok>> {
            return localVarFp.getCharactersCharacterIdLoyaltyPoints(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of offers from a specific corporation\'s loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
         * @summary List loyalty store offers
         * @param {number} corporationId An EVE corporation ID
         * @param {GetLoyaltyStoresCorporationIdOffersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoyaltyStoresCorporationIdOffers(corporationId: number, datasource?: GetLoyaltyStoresCorporationIdOffersDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetLoyaltyStoresCorporationIdOffers200Ok>> {
            return localVarFp.getLoyaltyStoresCorporationIdOffers(corporationId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoyaltyApi - object-oriented interface
 */
export class LoyaltyApi extends BaseAPI {
    /**
     * Return a list of loyalty points for all corporations the character has worked for  --- Alternate route: `/dev/characters/{character_id}/loyalty/points/`  Alternate route: `/legacy/characters/{character_id}/loyalty/points/`  Alternate route: `/v1/characters/{character_id}/loyalty/points/`  --- This route is cached for up to 3600 seconds
     * @summary Get loyalty points
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdLoyaltyPointsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdLoyaltyPoints(characterId: number, datasource?: GetCharactersCharacterIdLoyaltyPointsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return LoyaltyApiFp(this.configuration).getCharactersCharacterIdLoyaltyPoints(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of offers from a specific corporation\'s loyalty store  --- Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`  Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`  --- This route expires daily at 11:05
     * @summary List loyalty store offers
     * @param {number} corporationId An EVE corporation ID
     * @param {GetLoyaltyStoresCorporationIdOffersDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLoyaltyStoresCorporationIdOffers(corporationId: number, datasource?: GetLoyaltyStoresCorporationIdOffersDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return LoyaltyApiFp(this.configuration).getLoyaltyStoresCorporationIdOffers(corporationId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdLoyaltyPointsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdLoyaltyPointsDatasourceEnum = typeof GetCharactersCharacterIdLoyaltyPointsDatasourceEnum[keyof typeof GetCharactersCharacterIdLoyaltyPointsDatasourceEnum];
export const GetLoyaltyStoresCorporationIdOffersDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetLoyaltyStoresCorporationIdOffersDatasourceEnum = typeof GetLoyaltyStoresCorporationIdOffersDatasourceEnum[keyof typeof GetLoyaltyStoresCorporationIdOffersDatasourceEnum];


/**
 * MailApi - axios parameter creator
 */
export const MailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/` 
         * @summary Delete a mail label
         * @param {number} characterId An EVE character ID
         * @param {number} labelId An EVE label id
         * @param {DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdMailLabelsLabelId: async (characterId: number, labelId: number, datasource?: DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('deleteCharactersCharacterIdMailLabelsLabelId', 'characterId', characterId)
            // verify required parameter 'labelId' is not null or undefined
            assertParamExists('deleteCharactersCharacterIdMailLabelsLabelId', 'labelId', labelId)
            const localVarPath = `/characters/{character_id}/mail/labels/{label_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"label_id"}}`, encodeURIComponent(String(labelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-mail.organize_mail.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Delete a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {DeleteCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdMailMailId: async (characterId: number, mailId: number, datasource?: DeleteCharactersCharacterIdMailMailIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('deleteCharactersCharacterIdMailMailId', 'characterId', characterId)
            // verify required parameter 'mailId' is not null or undefined
            assertParamExists('deleteCharactersCharacterIdMailMailId', 'mailId', mailId)
            const localVarPath = `/characters/{character_id}/mail/{mail_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"mail_id"}}`, encodeURIComponent(String(mailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-mail.organize_mail.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
         * @summary Return mail headers
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMailDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {Set<number>} [labels] Fetch only mails that match one or more of the given labels
         * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMail: async (characterId: number, datasource?: GetCharactersCharacterIdMailDatasourceEnum, ifNoneMatch?: string, labels?: Set<number>, lastMailId?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdMail', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/mail/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-mail.read_mail.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (labels) {
                localVarQueryParameter['labels'] = Array.from(labels).join(COLLECTION_FORMATS.csv);
            }

            if (lastMailId !== undefined) {
                localVarQueryParameter['last_mail_id'] = lastMailId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
         * @summary Get mail labels and unread counts
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMailLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailLabels: async (characterId: number, datasource?: GetCharactersCharacterIdMailLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdMailLabels', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/mail/labels/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-mail.read_mail.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
         * @summary Return mailing list subscriptions
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMailListsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailLists: async (characterId: number, datasource?: GetCharactersCharacterIdMailListsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdMailLists', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/mail/lists/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-mail.read_mail.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
         * @summary Return a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {GetCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailMailId: async (characterId: number, mailId: number, datasource?: GetCharactersCharacterIdMailMailIdDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdMailMailId', 'characterId', characterId)
            // verify required parameter 'mailId' is not null or undefined
            assertParamExists('getCharactersCharacterIdMailMailId', 'mailId', mailId)
            const localVarPath = `/characters/{character_id}/mail/{mail_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"mail_id"}}`, encodeURIComponent(String(mailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-mail.read_mail.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/` 
         * @summary Send a new mail
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailMail} mail The mail to send
         * @param {PostCharactersCharacterIdMailDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdMail: async (characterId: number, mail: PostCharactersCharacterIdMailMail, datasource?: PostCharactersCharacterIdMailDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('postCharactersCharacterIdMail', 'characterId', characterId)
            // verify required parameter 'mail' is not null or undefined
            assertParamExists('postCharactersCharacterIdMail', 'mail', mail)
            const localVarPath = `/characters/{character_id}/mail/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-mail.send_mail.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/` 
         * @summary Create a mail label
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
         * @param {PostCharactersCharacterIdMailLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdMailLabels: async (characterId: number, label: PostCharactersCharacterIdMailLabelsLabel, datasource?: PostCharactersCharacterIdMailLabelsDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('postCharactersCharacterIdMailLabels', 'characterId', characterId)
            // verify required parameter 'label' is not null or undefined
            assertParamExists('postCharactersCharacterIdMailLabels', 'label', label)
            const localVarPath = `/characters/{character_id}/mail/labels/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-mail.organize_mail.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(label, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Update metadata about a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
         * @param {PutCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdMailMailId: async (characterId: number, mailId: number, contents: PutCharactersCharacterIdMailMailIdContents, datasource?: PutCharactersCharacterIdMailMailIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('putCharactersCharacterIdMailMailId', 'characterId', characterId)
            // verify required parameter 'mailId' is not null or undefined
            assertParamExists('putCharactersCharacterIdMailMailId', 'mailId', mailId)
            // verify required parameter 'contents' is not null or undefined
            assertParamExists('putCharactersCharacterIdMailMailId', 'contents', contents)
            const localVarPath = `/characters/{character_id}/mail/{mail_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"mail_id"}}`, encodeURIComponent(String(mailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-mail.organize_mail.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contents, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailApi - functional programming interface
 */
export const MailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MailApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/` 
         * @summary Delete a mail label
         * @param {number} characterId An EVE character ID
         * @param {number} labelId An EVE label id
         * @param {DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharactersCharacterIdMailLabelsLabelId(characterId: number, labelId: number, datasource?: DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCharactersCharacterIdMailLabelsLabelId(characterId, labelId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.deleteCharactersCharacterIdMailLabelsLabelId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Delete a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {DeleteCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: DeleteCharactersCharacterIdMailMailIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCharactersCharacterIdMailMailId(characterId, mailId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.deleteCharactersCharacterIdMailMailId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
         * @summary Return mail headers
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMailDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {Set<number>} [labels] Fetch only mails that match one or more of the given labels
         * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdMail(characterId: number, datasource?: GetCharactersCharacterIdMailDatasourceEnum, ifNoneMatch?: string, labels?: Set<number>, lastMailId?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdMail200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdMail(characterId, datasource, ifNoneMatch, labels, lastMailId, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.getCharactersCharacterIdMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
         * @summary Get mail labels and unread counts
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMailLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdMailLabels(characterId: number, datasource?: GetCharactersCharacterIdMailLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdMailLabelsOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdMailLabels(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.getCharactersCharacterIdMailLabels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
         * @summary Return mailing list subscriptions
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMailListsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdMailLists(characterId: number, datasource?: GetCharactersCharacterIdMailListsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdMailLists200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdMailLists(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.getCharactersCharacterIdMailLists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
         * @summary Return a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {GetCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: GetCharactersCharacterIdMailMailIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdMailMailIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdMailMailId(characterId, mailId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.getCharactersCharacterIdMailMailId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/` 
         * @summary Send a new mail
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailMail} mail The mail to send
         * @param {PostCharactersCharacterIdMailDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCharactersCharacterIdMail(characterId: number, mail: PostCharactersCharacterIdMailMail, datasource?: PostCharactersCharacterIdMailDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCharactersCharacterIdMail(characterId, mail, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.postCharactersCharacterIdMail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/` 
         * @summary Create a mail label
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
         * @param {PostCharactersCharacterIdMailLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCharactersCharacterIdMailLabels(characterId: number, label: PostCharactersCharacterIdMailLabelsLabel, datasource?: PostCharactersCharacterIdMailLabelsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCharactersCharacterIdMailLabels(characterId, label, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.postCharactersCharacterIdMailLabels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Update metadata about a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
         * @param {PutCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCharactersCharacterIdMailMailId(characterId: number, mailId: number, contents: PutCharactersCharacterIdMailMailIdContents, datasource?: PutCharactersCharacterIdMailMailIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCharactersCharacterIdMailMailId(characterId, mailId, contents, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.putCharactersCharacterIdMailMailId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MailApi - factory interface
 */
export const MailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MailApiFp(configuration)
    return {
        /**
         * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/` 
         * @summary Delete a mail label
         * @param {number} characterId An EVE character ID
         * @param {number} labelId An EVE label id
         * @param {DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdMailLabelsLabelId(characterId: number, labelId: number, datasource?: DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCharactersCharacterIdMailLabelsLabelId(characterId, labelId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Delete a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {DeleteCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: DeleteCharactersCharacterIdMailMailIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCharactersCharacterIdMailMailId(characterId, mailId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
         * @summary Return mail headers
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMailDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {Set<number>} [labels] Fetch only mails that match one or more of the given labels
         * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMail(characterId: number, datasource?: GetCharactersCharacterIdMailDatasourceEnum, ifNoneMatch?: string, labels?: Set<number>, lastMailId?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdMail200Ok>> {
            return localVarFp.getCharactersCharacterIdMail(characterId, datasource, ifNoneMatch, labels, lastMailId, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
         * @summary Get mail labels and unread counts
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMailLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailLabels(characterId: number, datasource?: GetCharactersCharacterIdMailLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdMailLabelsOk> {
            return localVarFp.getCharactersCharacterIdMailLabels(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
         * @summary Return mailing list subscriptions
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdMailListsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailLists(characterId: number, datasource?: GetCharactersCharacterIdMailListsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdMailLists200Ok>> {
            return localVarFp.getCharactersCharacterIdMailLists(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
         * @summary Return a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {GetCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: GetCharactersCharacterIdMailMailIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdMailMailIdOk> {
            return localVarFp.getCharactersCharacterIdMailMailId(characterId, mailId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/` 
         * @summary Send a new mail
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailMail} mail The mail to send
         * @param {PostCharactersCharacterIdMailDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdMail(characterId: number, mail: PostCharactersCharacterIdMailMail, datasource?: PostCharactersCharacterIdMailDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.postCharactersCharacterIdMail(characterId, mail, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/` 
         * @summary Create a mail label
         * @param {number} characterId An EVE character ID
         * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
         * @param {PostCharactersCharacterIdMailLabelsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCharactersCharacterIdMailLabels(characterId: number, label: PostCharactersCharacterIdMailLabelsLabel, datasource?: PostCharactersCharacterIdMailLabelsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.postCharactersCharacterIdMailLabels(characterId, label, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
         * @summary Update metadata about a mail
         * @param {number} characterId An EVE character ID
         * @param {number} mailId An EVE mail ID
         * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
         * @param {PutCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCharactersCharacterIdMailMailId(characterId: number, mailId: number, contents: PutCharactersCharacterIdMailMailIdContents, datasource?: PutCharactersCharacterIdMailMailIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putCharactersCharacterIdMailMailId(characterId, mailId, contents, datasource, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MailApi - object-oriented interface
 */
export class MailApi extends BaseAPI {
    /**
     * Delete a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`  Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/` 
     * @summary Delete a mail label
     * @param {number} characterId An EVE character ID
     * @param {number} labelId An EVE label id
     * @param {DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCharactersCharacterIdMailLabelsLabelId(characterId: number, labelId: number, datasource?: DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).deleteCharactersCharacterIdMailLabelsLabelId(characterId, labelId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
     * @summary Delete a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {DeleteCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: DeleteCharactersCharacterIdMailMailIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).deleteCharactersCharacterIdMailMailId(characterId, mailId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/`  --- This route is cached for up to 30 seconds
     * @summary Return mail headers
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdMailDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {Set<number>} [labels] Fetch only mails that match one or more of the given labels
     * @param {number} [lastMailId] List only mail with an ID lower than the given ID, if present
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdMail(characterId: number, datasource?: GetCharactersCharacterIdMailDatasourceEnum, ifNoneMatch?: string, labels?: Set<number>, lastMailId?: number, token?: string, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).getCharactersCharacterIdMail(characterId, datasource, ifNoneMatch, labels, lastMailId, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of the users mail labels, unread counts for each label and a total unread count.  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/v3/characters/{character_id}/mail/labels/`  --- This route is cached for up to 30 seconds
     * @summary Get mail labels and unread counts
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdMailLabelsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdMailLabels(characterId: number, datasource?: GetCharactersCharacterIdMailLabelsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).getCharactersCharacterIdMailLabels(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return all mailing lists that the character is subscribed to  --- Alternate route: `/dev/characters/{character_id}/mail/lists/`  Alternate route: `/legacy/characters/{character_id}/mail/lists/`  Alternate route: `/v1/characters/{character_id}/mail/lists/`  --- This route is cached for up to 120 seconds
     * @summary Return mailing list subscriptions
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdMailListsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdMailLists(characterId: number, datasource?: GetCharactersCharacterIdMailListsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).getCharactersCharacterIdMailLists(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the contents of an EVE mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`  --- This route is cached for up to 30 seconds
     * @summary Return a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {GetCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdMailMailId(characterId: number, mailId: number, datasource?: GetCharactersCharacterIdMailMailIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).getCharactersCharacterIdMailMailId(characterId, mailId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create and send a new mail  --- Alternate route: `/dev/characters/{character_id}/mail/`  Alternate route: `/legacy/characters/{character_id}/mail/`  Alternate route: `/v1/characters/{character_id}/mail/` 
     * @summary Send a new mail
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdMailMail} mail The mail to send
     * @param {PostCharactersCharacterIdMailDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCharactersCharacterIdMail(characterId: number, mail: PostCharactersCharacterIdMailMail, datasource?: PostCharactersCharacterIdMailDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).postCharactersCharacterIdMail(characterId, mail, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a mail label  --- Alternate route: `/dev/characters/{character_id}/mail/labels/`  Alternate route: `/legacy/characters/{character_id}/mail/labels/`  Alternate route: `/v2/characters/{character_id}/mail/labels/` 
     * @summary Create a mail label
     * @param {number} characterId An EVE character ID
     * @param {PostCharactersCharacterIdMailLabelsLabel} label Label to create
     * @param {PostCharactersCharacterIdMailLabelsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCharactersCharacterIdMailLabels(characterId: number, label: PostCharactersCharacterIdMailLabelsLabel, datasource?: PostCharactersCharacterIdMailLabelsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).postCharactersCharacterIdMailLabels(characterId, label, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update metadata about a mail  --- Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`  Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/` 
     * @summary Update metadata about a mail
     * @param {number} characterId An EVE character ID
     * @param {number} mailId An EVE mail ID
     * @param {PutCharactersCharacterIdMailMailIdContents} contents Data used to update the mail
     * @param {PutCharactersCharacterIdMailMailIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putCharactersCharacterIdMailMailId(characterId: number, mailId: number, contents: PutCharactersCharacterIdMailMailIdContents, datasource?: PutCharactersCharacterIdMailMailIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).putCharactersCharacterIdMailMailId(characterId, mailId, contents, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum = typeof DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum[keyof typeof DeleteCharactersCharacterIdMailLabelsLabelIdDatasourceEnum];
export const DeleteCharactersCharacterIdMailMailIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type DeleteCharactersCharacterIdMailMailIdDatasourceEnum = typeof DeleteCharactersCharacterIdMailMailIdDatasourceEnum[keyof typeof DeleteCharactersCharacterIdMailMailIdDatasourceEnum];
export const GetCharactersCharacterIdMailDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdMailDatasourceEnum = typeof GetCharactersCharacterIdMailDatasourceEnum[keyof typeof GetCharactersCharacterIdMailDatasourceEnum];
export const GetCharactersCharacterIdMailLabelsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdMailLabelsDatasourceEnum = typeof GetCharactersCharacterIdMailLabelsDatasourceEnum[keyof typeof GetCharactersCharacterIdMailLabelsDatasourceEnum];
export const GetCharactersCharacterIdMailListsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdMailListsDatasourceEnum = typeof GetCharactersCharacterIdMailListsDatasourceEnum[keyof typeof GetCharactersCharacterIdMailListsDatasourceEnum];
export const GetCharactersCharacterIdMailMailIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdMailMailIdDatasourceEnum = typeof GetCharactersCharacterIdMailMailIdDatasourceEnum[keyof typeof GetCharactersCharacterIdMailMailIdDatasourceEnum];
export const PostCharactersCharacterIdMailDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostCharactersCharacterIdMailDatasourceEnum = typeof PostCharactersCharacterIdMailDatasourceEnum[keyof typeof PostCharactersCharacterIdMailDatasourceEnum];
export const PostCharactersCharacterIdMailLabelsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostCharactersCharacterIdMailLabelsDatasourceEnum = typeof PostCharactersCharacterIdMailLabelsDatasourceEnum[keyof typeof PostCharactersCharacterIdMailLabelsDatasourceEnum];
export const PutCharactersCharacterIdMailMailIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PutCharactersCharacterIdMailMailIdDatasourceEnum = typeof PutCharactersCharacterIdMailMailIdDatasourceEnum[keyof typeof PutCharactersCharacterIdMailMailIdDatasourceEnum];


/**
 * MarketApi - axios parameter creator
 */
export const MarketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
         * @summary List open orders from a character
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdOrdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOrders: async (characterId: number, datasource?: GetCharactersCharacterIdOrdersDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdOrders', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/orders/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-markets.read_character_orders.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
         * @summary List historical orders by a character
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdOrdersHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOrdersHistory: async (characterId: number, datasource?: GetCharactersCharacterIdOrdersHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdOrdersHistory', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/orders/history/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-markets.read_character_orders.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/legacy/corporations/{corporation_id}/orders/`  Alternate route: `/v2/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List open orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdOrdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdOrders: async (corporationId: number, datasource?: GetCorporationsCorporationIdOrdersDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdOrders', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/orders/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-markets.read_corporation_orders.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/legacy/corporations/{corporation_id}/orders/history/`  Alternate route: `/v1/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List historical orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdOrdersHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdOrdersHistory: async (corporationId: number, datasource?: GetCorporationsCorporationIdOrdersHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdOrdersHistory', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/orders/history/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-markets.read_corporation_orders.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {GetMarketsGroupsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsGroups: async (datasource?: GetMarketsGroupsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markets/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} marketGroupId An Eve item group ID
         * @param {GetMarketsGroupsMarketGroupIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetMarketsGroupsMarketGroupIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetMarketsGroupsMarketGroupIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsGroupsMarketGroupId: async (marketGroupId: number, acceptLanguage?: GetMarketsGroupsMarketGroupIdAcceptLanguageEnum, datasource?: GetMarketsGroupsMarketGroupIdDatasourceEnum, ifNoneMatch?: string, language?: GetMarketsGroupsMarketGroupIdLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketGroupId' is not null or undefined
            assertParamExists('getMarketsGroupsMarketGroupId', 'marketGroupId', marketGroupId)
            const localVarPath = `/markets/groups/{market_group_id}/`
                .replace(`{${"market_group_id"}}`, encodeURIComponent(String(marketGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List market prices
         * @param {GetMarketsPricesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsPrices: async (datasource?: GetMarketsPricesDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/markets/prices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
         * @summary List historical market statistics in a region
         * @param {number} regionId Return statistics in this region
         * @param {number} typeId Return statistics for this type
         * @param {GetMarketsRegionIdHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdHistory: async (regionId: number, typeId: number, datasource?: GetMarketsRegionIdHistoryDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('getMarketsRegionIdHistory', 'regionId', regionId)
            // verify required parameter 'typeId' is not null or undefined
            assertParamExists('getMarketsRegionIdHistory', 'typeId', typeId)
            const localVarPath = `/markets/{region_id}/history/`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['type_id'] = typeId;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a region
         * @param {GetMarketsRegionIdOrdersOrderTypeEnum} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
         * @param {number} regionId Return orders in this region
         * @param {GetMarketsRegionIdOrdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {number} [typeId] Return orders only for this type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdOrders: async (orderType: GetMarketsRegionIdOrdersOrderTypeEnum, regionId: number, datasource?: GetMarketsRegionIdOrdersDatasourceEnum, ifNoneMatch?: string, page?: number, typeId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderType' is not null or undefined
            assertParamExists('getMarketsRegionIdOrders', 'orderType', orderType)
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('getMarketsRegionIdOrders', 'regionId', regionId)
            const localVarPath = `/markets/{region_id}/orders/`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['order_type'] = orderType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['type_id'] = typeId;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
         * @summary List type IDs relevant to a market
         * @param {number} regionId Return statistics in this region
         * @param {GetMarketsRegionIdTypesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdTypes: async (regionId: number, datasource?: GetMarketsRegionIdTypesDatasourceEnum, ifNoneMatch?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('getMarketsRegionIdTypes', 'regionId', regionId)
            const localVarPath = `/markets/{region_id}/types/`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a structure
         * @param {number} structureId Return orders in this structure
         * @param {GetMarketsStructuresStructureIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsStructuresStructureId: async (structureId: number, datasource?: GetMarketsStructuresStructureIdDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'structureId' is not null or undefined
            assertParamExists('getMarketsStructuresStructureId', 'structureId', structureId)
            const localVarPath = `/markets/structures/{structure_id}/`
                .replace(`{${"structure_id"}}`, encodeURIComponent(String(structureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-markets.structure_markets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketApi - functional programming interface
 */
export const MarketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketApiAxiosParamCreator(configuration)
    return {
        /**
         * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
         * @summary List open orders from a character
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdOrdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdOrders(characterId: number, datasource?: GetCharactersCharacterIdOrdersDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdOrders200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdOrders(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getCharactersCharacterIdOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
         * @summary List historical orders by a character
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdOrdersHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdOrdersHistory(characterId: number, datasource?: GetCharactersCharacterIdOrdersHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdOrdersHistory200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdOrdersHistory(characterId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getCharactersCharacterIdOrdersHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/legacy/corporations/{corporation_id}/orders/`  Alternate route: `/v2/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List open orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdOrdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdOrders(corporationId: number, datasource?: GetCorporationsCorporationIdOrdersDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdOrders200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdOrders(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getCorporationsCorporationIdOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/legacy/corporations/{corporation_id}/orders/history/`  Alternate route: `/v1/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List historical orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdOrdersHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdOrdersHistory(corporationId: number, datasource?: GetCorporationsCorporationIdOrdersHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdOrdersHistory200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdOrdersHistory(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getCorporationsCorporationIdOrdersHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {GetMarketsGroupsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketsGroups(datasource?: GetMarketsGroupsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketsGroups(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getMarketsGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} marketGroupId An Eve item group ID
         * @param {GetMarketsGroupsMarketGroupIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetMarketsGroupsMarketGroupIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetMarketsGroupsMarketGroupIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketsGroupsMarketGroupId(marketGroupId: number, acceptLanguage?: GetMarketsGroupsMarketGroupIdAcceptLanguageEnum, datasource?: GetMarketsGroupsMarketGroupIdDatasourceEnum, ifNoneMatch?: string, language?: GetMarketsGroupsMarketGroupIdLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarketsGroupsMarketGroupIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketsGroupsMarketGroupId(marketGroupId, acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getMarketsGroupsMarketGroupId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List market prices
         * @param {GetMarketsPricesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketsPrices(datasource?: GetMarketsPricesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarketsPrices200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketsPrices(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getMarketsPrices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
         * @summary List historical market statistics in a region
         * @param {number} regionId Return statistics in this region
         * @param {number} typeId Return statistics for this type
         * @param {GetMarketsRegionIdHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketsRegionIdHistory(regionId: number, typeId: number, datasource?: GetMarketsRegionIdHistoryDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarketsRegionIdHistory200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketsRegionIdHistory(regionId, typeId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getMarketsRegionIdHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a region
         * @param {GetMarketsRegionIdOrdersOrderTypeEnum} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
         * @param {number} regionId Return orders in this region
         * @param {GetMarketsRegionIdOrdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {number} [typeId] Return orders only for this type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketsRegionIdOrders(orderType: GetMarketsRegionIdOrdersOrderTypeEnum, regionId: number, datasource?: GetMarketsRegionIdOrdersDatasourceEnum, ifNoneMatch?: string, page?: number, typeId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarketsRegionIdOrders200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketsRegionIdOrders(orderType, regionId, datasource, ifNoneMatch, page, typeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getMarketsRegionIdOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
         * @summary List type IDs relevant to a market
         * @param {number} regionId Return statistics in this region
         * @param {GetMarketsRegionIdTypesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketsRegionIdTypes(regionId: number, datasource?: GetMarketsRegionIdTypesDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketsRegionIdTypes(regionId, datasource, ifNoneMatch, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getMarketsRegionIdTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a structure
         * @param {number} structureId Return orders in this structure
         * @param {GetMarketsStructuresStructureIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketsStructuresStructureId(structureId: number, datasource?: GetMarketsStructuresStructureIdDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMarketsStructuresStructureId200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketsStructuresStructureId(structureId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketApi.getMarketsStructuresStructureId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarketApi - factory interface
 */
export const MarketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketApiFp(configuration)
    return {
        /**
         * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
         * @summary List open orders from a character
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdOrdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOrders(characterId: number, datasource?: GetCharactersCharacterIdOrdersDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdOrders200Ok>> {
            return localVarFp.getCharactersCharacterIdOrders(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
         * @summary List historical orders by a character
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdOrdersHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdOrdersHistory(characterId: number, datasource?: GetCharactersCharacterIdOrdersHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdOrdersHistory200Ok>> {
            return localVarFp.getCharactersCharacterIdOrdersHistory(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/legacy/corporations/{corporation_id}/orders/`  Alternate route: `/v2/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List open orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdOrdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdOrders(corporationId: number, datasource?: GetCorporationsCorporationIdOrdersDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdOrders200Ok>> {
            return localVarFp.getCorporationsCorporationIdOrders(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/legacy/corporations/{corporation_id}/orders/history/`  Alternate route: `/v1/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
         * @summary List historical orders from a corporation
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdOrdersHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdOrdersHistory(corporationId: number, datasource?: GetCorporationsCorporationIdOrdersHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdOrdersHistory200Ok>> {
            return localVarFp.getCorporationsCorporationIdOrdersHistory(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {GetMarketsGroupsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsGroups(datasource?: GetMarketsGroupsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getMarketsGroups(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} marketGroupId An Eve item group ID
         * @param {GetMarketsGroupsMarketGroupIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetMarketsGroupsMarketGroupIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetMarketsGroupsMarketGroupIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsGroupsMarketGroupId(marketGroupId: number, acceptLanguage?: GetMarketsGroupsMarketGroupIdAcceptLanguageEnum, datasource?: GetMarketsGroupsMarketGroupIdDatasourceEnum, ifNoneMatch?: string, language?: GetMarketsGroupsMarketGroupIdLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetMarketsGroupsMarketGroupIdOk> {
            return localVarFp.getMarketsGroupsMarketGroupId(marketGroupId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
         * @summary List market prices
         * @param {GetMarketsPricesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsPrices(datasource?: GetMarketsPricesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarketsPrices200Ok>> {
            return localVarFp.getMarketsPrices(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
         * @summary List historical market statistics in a region
         * @param {number} regionId Return statistics in this region
         * @param {number} typeId Return statistics for this type
         * @param {GetMarketsRegionIdHistoryDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdHistory(regionId: number, typeId: number, datasource?: GetMarketsRegionIdHistoryDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarketsRegionIdHistory200Ok>> {
            return localVarFp.getMarketsRegionIdHistory(regionId, typeId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a region
         * @param {GetMarketsRegionIdOrdersOrderTypeEnum} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
         * @param {number} regionId Return orders in this region
         * @param {GetMarketsRegionIdOrdersDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {number} [typeId] Return orders only for this type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdOrders(orderType: GetMarketsRegionIdOrdersOrderTypeEnum, regionId: number, datasource?: GetMarketsRegionIdOrdersDatasourceEnum, ifNoneMatch?: string, page?: number, typeId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarketsRegionIdOrders200Ok>> {
            return localVarFp.getMarketsRegionIdOrders(orderType, regionId, datasource, ifNoneMatch, page, typeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
         * @summary List type IDs relevant to a market
         * @param {number} regionId Return statistics in this region
         * @param {GetMarketsRegionIdTypesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsRegionIdTypes(regionId: number, datasource?: GetMarketsRegionIdTypesDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getMarketsRegionIdTypes(regionId, datasource, ifNoneMatch, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
         * @summary List orders in a structure
         * @param {number} structureId Return orders in this structure
         * @param {GetMarketsStructuresStructureIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketsStructuresStructureId(structureId: number, datasource?: GetMarketsStructuresStructureIdDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetMarketsStructuresStructureId200Ok>> {
            return localVarFp.getMarketsStructuresStructureId(structureId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketApi - object-oriented interface
 */
export class MarketApi extends BaseAPI {
    /**
     * List open market orders placed by a character  --- Alternate route: `/dev/characters/{character_id}/orders/`  Alternate route: `/v2/characters/{character_id}/orders/`  --- This route is cached for up to 1200 seconds
     * @summary List open orders from a character
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdOrdersDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdOrders(characterId: number, datasource?: GetCharactersCharacterIdOrdersDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getCharactersCharacterIdOrders(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List cancelled and expired market orders placed by a character up to 90 days in the past.  --- Alternate route: `/dev/characters/{character_id}/orders/history/`  Alternate route: `/legacy/characters/{character_id}/orders/history/`  Alternate route: `/v1/characters/{character_id}/orders/history/`  --- This route is cached for up to 3600 seconds
     * @summary List historical orders by a character
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdOrdersHistoryDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdOrdersHistory(characterId: number, datasource?: GetCharactersCharacterIdOrdersHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getCharactersCharacterIdOrdersHistory(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List open market orders placed on behalf of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/orders/`  Alternate route: `/legacy/corporations/{corporation_id}/orders/`  Alternate route: `/v2/corporations/{corporation_id}/orders/`  Alternate route: `/v3/corporations/{corporation_id}/orders/`  --- This route is cached for up to 1200 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
     * @summary List open orders from a corporation
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdOrdersDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdOrders(corporationId: number, datasource?: GetCorporationsCorporationIdOrdersDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getCorporationsCorporationIdOrders(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.  --- Alternate route: `/dev/corporations/{corporation_id}/orders/history/`  Alternate route: `/legacy/corporations/{corporation_id}/orders/history/`  Alternate route: `/v1/corporations/{corporation_id}/orders/history/`  Alternate route: `/v2/corporations/{corporation_id}/orders/history/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Trader 
     * @summary List historical orders from a corporation
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdOrdersHistoryDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdOrdersHistory(corporationId: number, datasource?: GetCorporationsCorporationIdOrdersHistoryDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getCorporationsCorporationIdOrdersHistory(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of item groups  --- Alternate route: `/dev/markets/groups/`  Alternate route: `/legacy/markets/groups/`  Alternate route: `/v1/markets/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param {GetMarketsGroupsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMarketsGroups(datasource?: GetMarketsGroupsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMarketsGroups(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on an item group  --- Alternate route: `/dev/markets/groups/{market_group_id}/`  Alternate route: `/legacy/markets/groups/{market_group_id}/`  Alternate route: `/v1/markets/groups/{market_group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param {number} marketGroupId An Eve item group ID
     * @param {GetMarketsGroupsMarketGroupIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetMarketsGroupsMarketGroupIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetMarketsGroupsMarketGroupIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMarketsGroupsMarketGroupId(marketGroupId: number, acceptLanguage?: GetMarketsGroupsMarketGroupIdAcceptLanguageEnum, datasource?: GetMarketsGroupsMarketGroupIdDatasourceEnum, ifNoneMatch?: string, language?: GetMarketsGroupsMarketGroupIdLanguageEnum, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMarketsGroupsMarketGroupId(marketGroupId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of prices  --- Alternate route: `/dev/markets/prices/`  Alternate route: `/legacy/markets/prices/`  Alternate route: `/v1/markets/prices/`  --- This route is cached for up to 3600 seconds
     * @summary List market prices
     * @param {GetMarketsPricesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMarketsPrices(datasource?: GetMarketsPricesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMarketsPrices(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of historical market statistics for the specified type in a region  --- Alternate route: `/dev/markets/{region_id}/history/`  Alternate route: `/legacy/markets/{region_id}/history/`  Alternate route: `/v1/markets/{region_id}/history/`  --- This route expires daily at 11:05
     * @summary List historical market statistics in a region
     * @param {number} regionId Return statistics in this region
     * @param {number} typeId Return statistics for this type
     * @param {GetMarketsRegionIdHistoryDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMarketsRegionIdHistory(regionId: number, typeId: number, datasource?: GetMarketsRegionIdHistoryDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMarketsRegionIdHistory(regionId, typeId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of orders in a region  --- Alternate route: `/dev/markets/{region_id}/orders/`  Alternate route: `/legacy/markets/{region_id}/orders/`  Alternate route: `/v1/markets/{region_id}/orders/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a region
     * @param {GetMarketsRegionIdOrdersOrderTypeEnum} orderType Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
     * @param {number} regionId Return orders in this region
     * @param {GetMarketsRegionIdOrdersDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {number} [typeId] Return orders only for this type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMarketsRegionIdOrders(orderType: GetMarketsRegionIdOrdersOrderTypeEnum, regionId: number, datasource?: GetMarketsRegionIdOrdersDatasourceEnum, ifNoneMatch?: string, page?: number, typeId?: number, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMarketsRegionIdOrders(orderType, regionId, datasource, ifNoneMatch, page, typeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of type IDs that have active orders in the region, for efficient market indexing.  --- Alternate route: `/dev/markets/{region_id}/types/`  Alternate route: `/legacy/markets/{region_id}/types/`  Alternate route: `/v1/markets/{region_id}/types/`  --- This route is cached for up to 600 seconds
     * @summary List type IDs relevant to a market
     * @param {number} regionId Return statistics in this region
     * @param {GetMarketsRegionIdTypesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMarketsRegionIdTypes(regionId: number, datasource?: GetMarketsRegionIdTypesDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMarketsRegionIdTypes(regionId, datasource, ifNoneMatch, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return all orders in a structure  --- Alternate route: `/dev/markets/structures/{structure_id}/`  Alternate route: `/legacy/markets/structures/{structure_id}/`  Alternate route: `/v1/markets/structures/{structure_id}/`  --- This route is cached for up to 300 seconds
     * @summary List orders in a structure
     * @param {number} structureId Return orders in this structure
     * @param {GetMarketsStructuresStructureIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMarketsStructuresStructureId(structureId: number, datasource?: GetMarketsStructuresStructureIdDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return MarketApiFp(this.configuration).getMarketsStructuresStructureId(structureId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdOrdersDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdOrdersDatasourceEnum = typeof GetCharactersCharacterIdOrdersDatasourceEnum[keyof typeof GetCharactersCharacterIdOrdersDatasourceEnum];
export const GetCharactersCharacterIdOrdersHistoryDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdOrdersHistoryDatasourceEnum = typeof GetCharactersCharacterIdOrdersHistoryDatasourceEnum[keyof typeof GetCharactersCharacterIdOrdersHistoryDatasourceEnum];
export const GetCorporationsCorporationIdOrdersDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdOrdersDatasourceEnum = typeof GetCorporationsCorporationIdOrdersDatasourceEnum[keyof typeof GetCorporationsCorporationIdOrdersDatasourceEnum];
export const GetCorporationsCorporationIdOrdersHistoryDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdOrdersHistoryDatasourceEnum = typeof GetCorporationsCorporationIdOrdersHistoryDatasourceEnum[keyof typeof GetCorporationsCorporationIdOrdersHistoryDatasourceEnum];
export const GetMarketsGroupsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetMarketsGroupsDatasourceEnum = typeof GetMarketsGroupsDatasourceEnum[keyof typeof GetMarketsGroupsDatasourceEnum];
export const GetMarketsGroupsMarketGroupIdAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetMarketsGroupsMarketGroupIdAcceptLanguageEnum = typeof GetMarketsGroupsMarketGroupIdAcceptLanguageEnum[keyof typeof GetMarketsGroupsMarketGroupIdAcceptLanguageEnum];
export const GetMarketsGroupsMarketGroupIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetMarketsGroupsMarketGroupIdDatasourceEnum = typeof GetMarketsGroupsMarketGroupIdDatasourceEnum[keyof typeof GetMarketsGroupsMarketGroupIdDatasourceEnum];
export const GetMarketsGroupsMarketGroupIdLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetMarketsGroupsMarketGroupIdLanguageEnum = typeof GetMarketsGroupsMarketGroupIdLanguageEnum[keyof typeof GetMarketsGroupsMarketGroupIdLanguageEnum];
export const GetMarketsPricesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetMarketsPricesDatasourceEnum = typeof GetMarketsPricesDatasourceEnum[keyof typeof GetMarketsPricesDatasourceEnum];
export const GetMarketsRegionIdHistoryDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetMarketsRegionIdHistoryDatasourceEnum = typeof GetMarketsRegionIdHistoryDatasourceEnum[keyof typeof GetMarketsRegionIdHistoryDatasourceEnum];
export const GetMarketsRegionIdOrdersOrderTypeEnum = {
    Buy: 'buy',
    Sell: 'sell',
    All: 'all'
} as const;
export type GetMarketsRegionIdOrdersOrderTypeEnum = typeof GetMarketsRegionIdOrdersOrderTypeEnum[keyof typeof GetMarketsRegionIdOrdersOrderTypeEnum];
export const GetMarketsRegionIdOrdersDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetMarketsRegionIdOrdersDatasourceEnum = typeof GetMarketsRegionIdOrdersDatasourceEnum[keyof typeof GetMarketsRegionIdOrdersDatasourceEnum];
export const GetMarketsRegionIdTypesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetMarketsRegionIdTypesDatasourceEnum = typeof GetMarketsRegionIdTypesDatasourceEnum[keyof typeof GetMarketsRegionIdTypesDatasourceEnum];
export const GetMarketsStructuresStructureIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetMarketsStructuresStructureIdDatasourceEnum = typeof GetMarketsStructuresStructureIdDatasourceEnum[keyof typeof GetMarketsStructuresStructureIdDatasourceEnum];


/**
 * PlanetaryInteractionApi - axios parameter creator
 */
export const PlanetaryInteractionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
         * @summary Get colonies
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdPlanetsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPlanets: async (characterId: number, datasource?: GetCharactersCharacterIdPlanetsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdPlanets', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/planets/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-planets.manage_planets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/` 
         * @summary Get colony layout
         * @param {number} characterId An EVE character ID
         * @param {number} planetId Planet id of the target planet
         * @param {GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPlanetsPlanetId: async (characterId: number, planetId: number, datasource?: GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdPlanetsPlanetId', 'characterId', characterId)
            // verify required parameter 'planetId' is not null or undefined
            assertParamExists('getCharactersCharacterIdPlanetsPlanetId', 'planetId', planetId)
            const localVarPath = `/characters/{character_id}/planets/{planet_id}/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)))
                .replace(`{${"planet_id"}}`, encodeURIComponent(String(planetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-planets.manage_planets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary List corporation customs offices
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdCustomsOfficesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdCustomsOffices: async (corporationId: number, datasource?: GetCorporationsCorporationIdCustomsOfficesDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdCustomsOffices', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/customs_offices/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-planets.read_customs_offices.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get schematic information
         * @param {number} schematicId A PI schematic ID
         * @param {GetUniverseSchematicsSchematicIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSchematicsSchematicId: async (schematicId: number, datasource?: GetUniverseSchematicsSchematicIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schematicId' is not null or undefined
            assertParamExists('getUniverseSchematicsSchematicId', 'schematicId', schematicId)
            const localVarPath = `/universe/schematics/{schematic_id}/`
                .replace(`{${"schematic_id"}}`, encodeURIComponent(String(schematicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlanetaryInteractionApi - functional programming interface
 */
export const PlanetaryInteractionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlanetaryInteractionApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
         * @summary Get colonies
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdPlanetsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdPlanets(characterId: number, datasource?: GetCharactersCharacterIdPlanetsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdPlanets200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdPlanets(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanetaryInteractionApi.getCharactersCharacterIdPlanets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/` 
         * @summary Get colony layout
         * @param {number} characterId An EVE character ID
         * @param {number} planetId Planet id of the target planet
         * @param {GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdPlanetsPlanetId(characterId: number, planetId: number, datasource?: GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdPlanetsPlanetIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdPlanetsPlanetId(characterId, planetId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanetaryInteractionApi.getCharactersCharacterIdPlanetsPlanetId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary List corporation customs offices
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdCustomsOfficesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdCustomsOffices(corporationId: number, datasource?: GetCorporationsCorporationIdCustomsOfficesDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdCustomsOffices200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdCustomsOffices(corporationId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanetaryInteractionApi.getCorporationsCorporationIdCustomsOffices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get schematic information
         * @param {number} schematicId A PI schematic ID
         * @param {GetUniverseSchematicsSchematicIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseSchematicsSchematicId(schematicId: number, datasource?: GetUniverseSchematicsSchematicIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseSchematicsSchematicIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseSchematicsSchematicId(schematicId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlanetaryInteractionApi.getUniverseSchematicsSchematicId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlanetaryInteractionApi - factory interface
 */
export const PlanetaryInteractionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlanetaryInteractionApiFp(configuration)
    return {
        /**
         * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
         * @summary Get colonies
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdPlanetsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPlanets(characterId: number, datasource?: GetCharactersCharacterIdPlanetsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdPlanets200Ok>> {
            return localVarFp.getCharactersCharacterIdPlanets(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/` 
         * @summary Get colony layout
         * @param {number} characterId An EVE character ID
         * @param {number} planetId Planet id of the target planet
         * @param {GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdPlanetsPlanetId(characterId: number, planetId: number, datasource?: GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdPlanetsPlanetIdOk> {
            return localVarFp.getCharactersCharacterIdPlanetsPlanetId(characterId, planetId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
         * @summary List corporation customs offices
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdCustomsOfficesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdCustomsOffices(corporationId: number, datasource?: GetCorporationsCorporationIdCustomsOfficesDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdCustomsOffices200Ok>> {
            return localVarFp.getCorporationsCorporationIdCustomsOffices(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get schematic information
         * @param {number} schematicId A PI schematic ID
         * @param {GetUniverseSchematicsSchematicIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSchematicsSchematicId(schematicId: number, datasource?: GetUniverseSchematicsSchematicIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseSchematicsSchematicIdOk> {
            return localVarFp.getUniverseSchematicsSchematicId(schematicId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlanetaryInteractionApi - object-oriented interface
 */
export class PlanetaryInteractionApi extends BaseAPI {
    /**
     * Returns a list of all planetary colonies owned by a character.  --- Alternate route: `/dev/characters/{character_id}/planets/`  Alternate route: `/legacy/characters/{character_id}/planets/`  Alternate route: `/v1/characters/{character_id}/planets/`  --- This route is cached for up to 600 seconds
     * @summary Get colonies
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdPlanetsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdPlanets(characterId: number, datasource?: GetCharactersCharacterIdPlanetsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return PlanetaryInteractionApiFp(this.configuration).getCharactersCharacterIdPlanets(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.  --- Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`  Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/` 
     * @summary Get colony layout
     * @param {number} characterId An EVE character ID
     * @param {number} planetId Planet id of the target planet
     * @param {GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdPlanetsPlanetId(characterId: number, planetId: number, datasource?: GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return PlanetaryInteractionApiFp(this.configuration).getCharactersCharacterIdPlanetsPlanetId(characterId, planetId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List customs offices owned by a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`  Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`  Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Director 
     * @summary List corporation customs offices
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdCustomsOfficesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdCustomsOffices(corporationId: number, datasource?: GetCorporationsCorporationIdCustomsOfficesDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return PlanetaryInteractionApiFp(this.configuration).getCorporationsCorporationIdCustomsOffices(corporationId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a planetary factory schematic  --- Alternate route: `/dev/universe/schematics/{schematic_id}/`  Alternate route: `/legacy/universe/schematics/{schematic_id}/`  Alternate route: `/v1/universe/schematics/{schematic_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get schematic information
     * @param {number} schematicId A PI schematic ID
     * @param {GetUniverseSchematicsSchematicIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseSchematicsSchematicId(schematicId: number, datasource?: GetUniverseSchematicsSchematicIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return PlanetaryInteractionApiFp(this.configuration).getUniverseSchematicsSchematicId(schematicId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdPlanetsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdPlanetsDatasourceEnum = typeof GetCharactersCharacterIdPlanetsDatasourceEnum[keyof typeof GetCharactersCharacterIdPlanetsDatasourceEnum];
export const GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum = typeof GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum[keyof typeof GetCharactersCharacterIdPlanetsPlanetIdDatasourceEnum];
export const GetCorporationsCorporationIdCustomsOfficesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdCustomsOfficesDatasourceEnum = typeof GetCorporationsCorporationIdCustomsOfficesDatasourceEnum[keyof typeof GetCorporationsCorporationIdCustomsOfficesDatasourceEnum];
export const GetUniverseSchematicsSchematicIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseSchematicsSchematicIdDatasourceEnum = typeof GetUniverseSchematicsSchematicIdDatasourceEnum[keyof typeof GetUniverseSchematicsSchematicIdDatasourceEnum];


/**
 * RoutesApi - axios parameter creator
 */
export const RoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
         * @summary Get route
         * @param {number} destination destination solar system ID
         * @param {number} origin origin solar system ID
         * @param {Set<number>} [avoid] avoid solar system ID(s)
         * @param {Set<Set<number>>} [connections] connected solar system pairs
         * @param {GetRouteOriginDestinationDatasourceEnum} [datasource] The server name you would like data from
         * @param {GetRouteOriginDestinationFlagEnum} [flag] route security preference
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteOriginDestination: async (destination: number, origin: number, avoid?: Set<number>, connections?: Set<Set<number>>, datasource?: GetRouteOriginDestinationDatasourceEnum, flag?: GetRouteOriginDestinationFlagEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destination' is not null or undefined
            assertParamExists('getRouteOriginDestination', 'destination', destination)
            // verify required parameter 'origin' is not null or undefined
            assertParamExists('getRouteOriginDestination', 'origin', origin)
            const localVarPath = `/route/{origin}/{destination}/`
                .replace(`{${"destination"}}`, encodeURIComponent(String(destination)))
                .replace(`{${"origin"}}`, encodeURIComponent(String(origin)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (avoid) {
                localVarQueryParameter['avoid'] = Array.from(avoid).join(COLLECTION_FORMATS.csv);
            }

            if (connections) {
                localVarQueryParameter['connections'] = Array.from(connections).join(COLLECTION_FORMATS.csv);
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutesApi - functional programming interface
 */
export const RoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
         * @summary Get route
         * @param {number} destination destination solar system ID
         * @param {number} origin origin solar system ID
         * @param {Set<number>} [avoid] avoid solar system ID(s)
         * @param {Set<Set<number>>} [connections] connected solar system pairs
         * @param {GetRouteOriginDestinationDatasourceEnum} [datasource] The server name you would like data from
         * @param {GetRouteOriginDestinationFlagEnum} [flag] route security preference
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteOriginDestination(destination: number, origin: number, avoid?: Set<number>, connections?: Set<Set<number>>, datasource?: GetRouteOriginDestinationDatasourceEnum, flag?: GetRouteOriginDestinationFlagEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteOriginDestination(destination, origin, avoid, connections, datasource, flag, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutesApi.getRouteOriginDestination']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoutesApi - factory interface
 */
export const RoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoutesApiFp(configuration)
    return {
        /**
         * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
         * @summary Get route
         * @param {number} destination destination solar system ID
         * @param {number} origin origin solar system ID
         * @param {Set<number>} [avoid] avoid solar system ID(s)
         * @param {Set<Set<number>>} [connections] connected solar system pairs
         * @param {GetRouteOriginDestinationDatasourceEnum} [datasource] The server name you would like data from
         * @param {GetRouteOriginDestinationFlagEnum} [flag] route security preference
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteOriginDestination(destination: number, origin: number, avoid?: Set<number>, connections?: Set<Set<number>>, datasource?: GetRouteOriginDestinationDatasourceEnum, flag?: GetRouteOriginDestinationFlagEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getRouteOriginDestination(destination, origin, avoid, connections, datasource, flag, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoutesApi - object-oriented interface
 */
export class RoutesApi extends BaseAPI {
    /**
     * Get the systems between origin and destination  --- Alternate route: `/dev/route/{origin}/{destination}/`  Alternate route: `/legacy/route/{origin}/{destination}/`  Alternate route: `/v1/route/{origin}/{destination}/`  --- This route is cached for up to 86400 seconds
     * @summary Get route
     * @param {number} destination destination solar system ID
     * @param {number} origin origin solar system ID
     * @param {Set<number>} [avoid] avoid solar system ID(s)
     * @param {Set<Set<number>>} [connections] connected solar system pairs
     * @param {GetRouteOriginDestinationDatasourceEnum} [datasource] The server name you would like data from
     * @param {GetRouteOriginDestinationFlagEnum} [flag] route security preference
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRouteOriginDestination(destination: number, origin: number, avoid?: Set<number>, connections?: Set<Set<number>>, datasource?: GetRouteOriginDestinationDatasourceEnum, flag?: GetRouteOriginDestinationFlagEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return RoutesApiFp(this.configuration).getRouteOriginDestination(destination, origin, avoid, connections, datasource, flag, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetRouteOriginDestinationDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetRouteOriginDestinationDatasourceEnum = typeof GetRouteOriginDestinationDatasourceEnum[keyof typeof GetRouteOriginDestinationDatasourceEnum];
export const GetRouteOriginDestinationFlagEnum = {
    Shortest: 'shortest',
    Secure: 'secure',
    Insecure: 'insecure'
} as const;
export type GetRouteOriginDestinationFlagEnum = typeof GetRouteOriginDestinationFlagEnum[keyof typeof GetRouteOriginDestinationFlagEnum];


/**
 * SearchApi - axios parameter creator
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
         * @summary Search on a string
         * @param {Set<GetCharactersCharacterIdSearchCategoriesEnum>} categories Type of entities to search for
         * @param {number} characterId An EVE character ID
         * @param {string} search The string to search on
         * @param {GetCharactersCharacterIdSearchAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetCharactersCharacterIdSearchDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetCharactersCharacterIdSearchLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {boolean} [strict] Whether the search should be a strict match
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSearch: async (categories: Set<GetCharactersCharacterIdSearchCategoriesEnum>, characterId: number, search: string, acceptLanguage?: GetCharactersCharacterIdSearchAcceptLanguageEnum, datasource?: GetCharactersCharacterIdSearchDatasourceEnum, ifNoneMatch?: string, language?: GetCharactersCharacterIdSearchLanguageEnum, strict?: boolean, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categories' is not null or undefined
            assertParamExists('getCharactersCharacterIdSearch', 'categories', categories)
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdSearch', 'characterId', characterId)
            // verify required parameter 'search' is not null or undefined
            assertParamExists('getCharactersCharacterIdSearch', 'search', search)
            const localVarPath = `/characters/{character_id}/search/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-search.search_structures.v1"], configuration)

            if (categories) {
                localVarQueryParameter['categories'] = Array.from(categories).join(COLLECTION_FORMATS.csv);
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (strict !== undefined) {
                localVarQueryParameter['strict'] = strict;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
         * @summary Search on a string
         * @param {Set<GetCharactersCharacterIdSearchCategoriesEnum>} categories Type of entities to search for
         * @param {number} characterId An EVE character ID
         * @param {string} search The string to search on
         * @param {GetCharactersCharacterIdSearchAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetCharactersCharacterIdSearchDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetCharactersCharacterIdSearchLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {boolean} [strict] Whether the search should be a strict match
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdSearch(categories: Set<GetCharactersCharacterIdSearchCategoriesEnum>, characterId: number, search: string, acceptLanguage?: GetCharactersCharacterIdSearchAcceptLanguageEnum, datasource?: GetCharactersCharacterIdSearchDatasourceEnum, ifNoneMatch?: string, language?: GetCharactersCharacterIdSearchLanguageEnum, strict?: boolean, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdSearchOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdSearch(categories, characterId, search, acceptLanguage, datasource, ifNoneMatch, language, strict, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.getCharactersCharacterIdSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
         * @summary Search on a string
         * @param {Set<GetCharactersCharacterIdSearchCategoriesEnum>} categories Type of entities to search for
         * @param {number} characterId An EVE character ID
         * @param {string} search The string to search on
         * @param {GetCharactersCharacterIdSearchAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetCharactersCharacterIdSearchDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetCharactersCharacterIdSearchLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {boolean} [strict] Whether the search should be a strict match
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSearch(categories: Set<GetCharactersCharacterIdSearchCategoriesEnum>, characterId: number, search: string, acceptLanguage?: GetCharactersCharacterIdSearchAcceptLanguageEnum, datasource?: GetCharactersCharacterIdSearchDatasourceEnum, ifNoneMatch?: string, language?: GetCharactersCharacterIdSearchLanguageEnum, strict?: boolean, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdSearchOk> {
            return localVarFp.getCharactersCharacterIdSearch(categories, characterId, search, acceptLanguage, datasource, ifNoneMatch, language, strict, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 */
export class SearchApi extends BaseAPI {
    /**
     * Search for entities that match a given sub-string.  --- Alternate route: `/dev/characters/{character_id}/search/`  Alternate route: `/legacy/characters/{character_id}/search/`  Alternate route: `/v3/characters/{character_id}/search/`  --- This route is cached for up to 3600 seconds
     * @summary Search on a string
     * @param {Set<GetCharactersCharacterIdSearchCategoriesEnum>} categories Type of entities to search for
     * @param {number} characterId An EVE character ID
     * @param {string} search The string to search on
     * @param {GetCharactersCharacterIdSearchAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetCharactersCharacterIdSearchDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetCharactersCharacterIdSearchLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {boolean} [strict] Whether the search should be a strict match
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdSearch(categories: Set<GetCharactersCharacterIdSearchCategoriesEnum>, characterId: number, search: string, acceptLanguage?: GetCharactersCharacterIdSearchAcceptLanguageEnum, datasource?: GetCharactersCharacterIdSearchDatasourceEnum, ifNoneMatch?: string, language?: GetCharactersCharacterIdSearchLanguageEnum, strict?: boolean, token?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).getCharactersCharacterIdSearch(categories, characterId, search, acceptLanguage, datasource, ifNoneMatch, language, strict, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdSearchCategoriesEnum = {
    Agent: 'agent',
    Alliance: 'alliance',
    Character: 'character',
    Constellation: 'constellation',
    Corporation: 'corporation',
    Faction: 'faction',
    InventoryType: 'inventory_type',
    Region: 'region',
    SolarSystem: 'solar_system',
    Station: 'station',
    Structure: 'structure'
} as const;
export type GetCharactersCharacterIdSearchCategoriesEnum = typeof GetCharactersCharacterIdSearchCategoriesEnum[keyof typeof GetCharactersCharacterIdSearchCategoriesEnum];
export const GetCharactersCharacterIdSearchAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdSearchAcceptLanguageEnum = typeof GetCharactersCharacterIdSearchAcceptLanguageEnum[keyof typeof GetCharactersCharacterIdSearchAcceptLanguageEnum];
export const GetCharactersCharacterIdSearchDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdSearchDatasourceEnum = typeof GetCharactersCharacterIdSearchDatasourceEnum[keyof typeof GetCharactersCharacterIdSearchDatasourceEnum];
export const GetCharactersCharacterIdSearchLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetCharactersCharacterIdSearchLanguageEnum = typeof GetCharactersCharacterIdSearchLanguageEnum[keyof typeof GetCharactersCharacterIdSearchLanguageEnum];


/**
 * SkillsApi - axios parameter creator
 */
export const SkillsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
         * @summary Get character attributes
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdAttributesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAttributes: async (characterId: number, datasource?: GetCharactersCharacterIdAttributesDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdAttributes', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/attributes/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-skills.read_skills.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
         * @summary Get character\'s skill queue
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdSkillqueueDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSkillqueue: async (characterId: number, datasource?: GetCharactersCharacterIdSkillqueueDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdSkillqueue', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/skillqueue/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-skills.read_skillqueue.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
         * @summary Get character skills
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdSkillsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSkills: async (characterId: number, datasource?: GetCharactersCharacterIdSkillsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdSkills', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/skills/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-skills.read_skills.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkillsApi - functional programming interface
 */
export const SkillsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SkillsApiAxiosParamCreator(configuration)
    return {
        /**
         * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
         * @summary Get character attributes
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdAttributesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdAttributes(characterId: number, datasource?: GetCharactersCharacterIdAttributesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdAttributesOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdAttributes(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.getCharactersCharacterIdAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
         * @summary Get character\'s skill queue
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdSkillqueueDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdSkillqueue(characterId: number, datasource?: GetCharactersCharacterIdSkillqueueDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdSkillqueue200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdSkillqueue(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.getCharactersCharacterIdSkillqueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
         * @summary Get character skills
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdSkillsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdSkills(characterId: number, datasource?: GetCharactersCharacterIdSkillsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCharactersCharacterIdSkillsOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdSkills(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.getCharactersCharacterIdSkills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SkillsApi - factory interface
 */
export const SkillsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkillsApiFp(configuration)
    return {
        /**
         * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
         * @summary Get character attributes
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdAttributesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdAttributes(characterId: number, datasource?: GetCharactersCharacterIdAttributesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdAttributesOk> {
            return localVarFp.getCharactersCharacterIdAttributes(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
         * @summary Get character\'s skill queue
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdSkillqueueDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSkillqueue(characterId: number, datasource?: GetCharactersCharacterIdSkillqueueDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdSkillqueue200Ok>> {
            return localVarFp.getCharactersCharacterIdSkillqueue(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
         * @summary Get character skills
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdSkillsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdSkills(characterId: number, datasource?: GetCharactersCharacterIdSkillsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCharactersCharacterIdSkillsOk> {
            return localVarFp.getCharactersCharacterIdSkills(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkillsApi - object-oriented interface
 */
export class SkillsApi extends BaseAPI {
    /**
     * Return attributes of a character  --- Alternate route: `/dev/characters/{character_id}/attributes/`  Alternate route: `/legacy/characters/{character_id}/attributes/`  Alternate route: `/v1/characters/{character_id}/attributes/`  --- This route is cached for up to 120 seconds
     * @summary Get character attributes
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdAttributesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdAttributes(characterId: number, datasource?: GetCharactersCharacterIdAttributesDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).getCharactersCharacterIdAttributes(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the configured skill queue for the given character  --- Alternate route: `/dev/characters/{character_id}/skillqueue/`  Alternate route: `/legacy/characters/{character_id}/skillqueue/`  Alternate route: `/v2/characters/{character_id}/skillqueue/`  --- This route is cached for up to 120 seconds
     * @summary Get character\'s skill queue
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdSkillqueueDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdSkillqueue(characterId: number, datasource?: GetCharactersCharacterIdSkillqueueDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).getCharactersCharacterIdSkillqueue(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all trained skills for the given character  --- Alternate route: `/dev/characters/{character_id}/skills/`  Alternate route: `/v4/characters/{character_id}/skills/`  --- This route is cached for up to 120 seconds
     * @summary Get character skills
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdSkillsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdSkills(characterId: number, datasource?: GetCharactersCharacterIdSkillsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).getCharactersCharacterIdSkills(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdAttributesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdAttributesDatasourceEnum = typeof GetCharactersCharacterIdAttributesDatasourceEnum[keyof typeof GetCharactersCharacterIdAttributesDatasourceEnum];
export const GetCharactersCharacterIdSkillqueueDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdSkillqueueDatasourceEnum = typeof GetCharactersCharacterIdSkillqueueDatasourceEnum[keyof typeof GetCharactersCharacterIdSkillqueueDatasourceEnum];
export const GetCharactersCharacterIdSkillsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdSkillsDatasourceEnum = typeof GetCharactersCharacterIdSkillsDatasourceEnum[keyof typeof GetCharactersCharacterIdSkillsDatasourceEnum];


/**
 * SovereigntyApi - axios parameter creator
 */
export const SovereigntyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
         * @summary List sovereignty campaigns
         * @param {GetSovereigntyCampaignsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyCampaigns: async (datasource?: GetSovereigntyCampaignsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sovereignty/campaigns/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
         * @summary List sovereignty of systems
         * @param {GetSovereigntyMapDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyMap: async (datasource?: GetSovereigntyMapDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sovereignty/map/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
         * @summary List sovereignty structures
         * @param {GetSovereigntyStructuresDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyStructures: async (datasource?: GetSovereigntyStructuresDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sovereignty/structures/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SovereigntyApi - functional programming interface
 */
export const SovereigntyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SovereigntyApiAxiosParamCreator(configuration)
    return {
        /**
         * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
         * @summary List sovereignty campaigns
         * @param {GetSovereigntyCampaignsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSovereigntyCampaigns(datasource?: GetSovereigntyCampaignsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetSovereigntyCampaigns200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSovereigntyCampaigns(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SovereigntyApi.getSovereigntyCampaigns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
         * @summary List sovereignty of systems
         * @param {GetSovereigntyMapDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSovereigntyMap(datasource?: GetSovereigntyMapDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetSovereigntyMap200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSovereigntyMap(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SovereigntyApi.getSovereigntyMap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
         * @summary List sovereignty structures
         * @param {GetSovereigntyStructuresDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSovereigntyStructures(datasource?: GetSovereigntyStructuresDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetSovereigntyStructures200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSovereigntyStructures(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SovereigntyApi.getSovereigntyStructures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SovereigntyApi - factory interface
 */
export const SovereigntyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SovereigntyApiFp(configuration)
    return {
        /**
         * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
         * @summary List sovereignty campaigns
         * @param {GetSovereigntyCampaignsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyCampaigns(datasource?: GetSovereigntyCampaignsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetSovereigntyCampaigns200Ok>> {
            return localVarFp.getSovereigntyCampaigns(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
         * @summary List sovereignty of systems
         * @param {GetSovereigntyMapDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyMap(datasource?: GetSovereigntyMapDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetSovereigntyMap200Ok>> {
            return localVarFp.getSovereigntyMap(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
         * @summary List sovereignty structures
         * @param {GetSovereigntyStructuresDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSovereigntyStructures(datasource?: GetSovereigntyStructuresDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetSovereigntyStructures200Ok>> {
            return localVarFp.getSovereigntyStructures(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SovereigntyApi - object-oriented interface
 */
export class SovereigntyApi extends BaseAPI {
    /**
     * Shows sovereignty data for campaigns.  --- Alternate route: `/dev/sovereignty/campaigns/`  Alternate route: `/legacy/sovereignty/campaigns/`  Alternate route: `/v1/sovereignty/campaigns/`  --- This route is cached for up to 5 seconds
     * @summary List sovereignty campaigns
     * @param {GetSovereigntyCampaignsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSovereigntyCampaigns(datasource?: GetSovereigntyCampaignsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return SovereigntyApiFp(this.configuration).getSovereigntyCampaigns(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Shows sovereignty information for solar systems  --- Alternate route: `/dev/sovereignty/map/`  Alternate route: `/legacy/sovereignty/map/`  Alternate route: `/v1/sovereignty/map/`  --- This route is cached for up to 3600 seconds
     * @summary List sovereignty of systems
     * @param {GetSovereigntyMapDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSovereigntyMap(datasource?: GetSovereigntyMapDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return SovereigntyApiFp(this.configuration).getSovereigntyMap(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Shows sovereignty data for structures.  --- Alternate route: `/dev/sovereignty/structures/`  Alternate route: `/legacy/sovereignty/structures/`  Alternate route: `/v1/sovereignty/structures/`  --- This route is cached for up to 120 seconds
     * @summary List sovereignty structures
     * @param {GetSovereigntyStructuresDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSovereigntyStructures(datasource?: GetSovereigntyStructuresDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return SovereigntyApiFp(this.configuration).getSovereigntyStructures(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetSovereigntyCampaignsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetSovereigntyCampaignsDatasourceEnum = typeof GetSovereigntyCampaignsDatasourceEnum[keyof typeof GetSovereigntyCampaignsDatasourceEnum];
export const GetSovereigntyMapDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetSovereigntyMapDatasourceEnum = typeof GetSovereigntyMapDatasourceEnum[keyof typeof GetSovereigntyMapDatasourceEnum];
export const GetSovereigntyStructuresDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetSovereigntyStructuresDatasourceEnum = typeof GetSovereigntyStructuresDatasourceEnum[keyof typeof GetSovereigntyStructuresDatasourceEnum];


/**
 * StatusApi - axios parameter creator
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
         * @summary Retrieve the uptime and player counts
         * @param {GetStatusDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (datasource?: GetStatusDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
         * @summary Retrieve the uptime and player counts
         * @param {GetStatusDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(datasource?: GetStatusDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
         * @summary Retrieve the uptime and player counts
         * @param {GetStatusDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(datasource?: GetStatusDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetStatusOk> {
            return localVarFp.getStatus(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 */
export class StatusApi extends BaseAPI {
    /**
     * EVE Server status  --- Alternate route: `/dev/status/`  Alternate route: `/legacy/status/`  Alternate route: `/v1/status/`  Alternate route: `/v2/status/`  --- This route is cached for up to 30 seconds
     * @summary Retrieve the uptime and player counts
     * @param {GetStatusDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStatus(datasource?: GetStatusDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).getStatus(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetStatusDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetStatusDatasourceEnum = typeof GetStatusDatasourceEnum[keyof typeof GetStatusDatasourceEnum];


/**
 * UniverseApi - axios parameter creator
 */
export const UniverseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
         * @summary Get ancestries
         * @param {GetUniverseAncestriesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseAncestriesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseAncestriesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseAncestries: async (acceptLanguage?: GetUniverseAncestriesAcceptLanguageEnum, datasource?: GetUniverseAncestriesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseAncestriesLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/ancestries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
         * @summary Get asteroid belt information
         * @param {number} asteroidBeltId asteroid_belt_id integer
         * @param {GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseAsteroidBeltsAsteroidBeltId: async (asteroidBeltId: number, datasource?: GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asteroidBeltId' is not null or undefined
            assertParamExists('getUniverseAsteroidBeltsAsteroidBeltId', 'asteroidBeltId', asteroidBeltId)
            const localVarPath = `/universe/asteroid_belts/{asteroid_belt_id}/`
                .replace(`{${"asteroid_belt_id"}}`, encodeURIComponent(String(asteroidBeltId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
         * @summary Get bloodlines
         * @param {GetUniverseBloodlinesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseBloodlinesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseBloodlinesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseBloodlines: async (acceptLanguage?: GetUniverseBloodlinesAcceptLanguageEnum, datasource?: GetUniverseBloodlinesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseBloodlinesLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/bloodlines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
         * @summary Get item categories
         * @param {GetUniverseCategoriesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseCategories: async (datasource?: GetUniverseCategoriesDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
         * @summary Get item category information
         * @param {number} categoryId An Eve item category ID
         * @param {GetUniverseCategoriesCategoryIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseCategoriesCategoryIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseCategoriesCategoryIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseCategoriesCategoryId: async (categoryId: number, acceptLanguage?: GetUniverseCategoriesCategoryIdAcceptLanguageEnum, datasource?: GetUniverseCategoriesCategoryIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseCategoriesCategoryIdLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getUniverseCategoriesCategoryId', 'categoryId', categoryId)
            const localVarPath = `/universe/categories/{category_id}/`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
         * @summary Get constellations
         * @param {GetUniverseConstellationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseConstellations: async (datasource?: GetUniverseConstellationsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/constellations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
         * @summary Get constellation information
         * @param {number} constellationId constellation_id integer
         * @param {GetUniverseConstellationsConstellationIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseConstellationsConstellationIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseConstellationsConstellationIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseConstellationsConstellationId: async (constellationId: number, acceptLanguage?: GetUniverseConstellationsConstellationIdAcceptLanguageEnum, datasource?: GetUniverseConstellationsConstellationIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseConstellationsConstellationIdLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'constellationId' is not null or undefined
            assertParamExists('getUniverseConstellationsConstellationId', 'constellationId', constellationId)
            const localVarPath = `/universe/constellations/{constellation_id}/`
                .replace(`{${"constellation_id"}}`, encodeURIComponent(String(constellationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
         * @summary Get factions
         * @param {GetUniverseFactionsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseFactionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseFactionsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseFactions: async (acceptLanguage?: GetUniverseFactionsAcceptLanguageEnum, datasource?: GetUniverseFactionsDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseFactionsLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/factions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
         * @summary Get graphics
         * @param {GetUniverseGraphicsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGraphics: async (datasource?: GetUniverseGraphicsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/graphics/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
         * @summary Get graphic information
         * @param {number} graphicId graphic_id integer
         * @param {GetUniverseGraphicsGraphicIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGraphicsGraphicId: async (graphicId: number, datasource?: GetUniverseGraphicsGraphicIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphicId' is not null or undefined
            assertParamExists('getUniverseGraphicsGraphicId', 'graphicId', graphicId)
            const localVarPath = `/universe/graphics/{graphic_id}/`
                .replace(`{${"graphic_id"}}`, encodeURIComponent(String(graphicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {GetUniverseGroupsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGroups: async (datasource?: GetUniverseGroupsDatasourceEnum, ifNoneMatch?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} groupId An Eve item group ID
         * @param {GetUniverseGroupsGroupIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseGroupsGroupIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseGroupsGroupIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGroupsGroupId: async (groupId: number, acceptLanguage?: GetUniverseGroupsGroupIdAcceptLanguageEnum, datasource?: GetUniverseGroupsGroupIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseGroupsGroupIdLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getUniverseGroupsGroupId', 'groupId', groupId)
            const localVarPath = `/universe/groups/{group_id}/`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
         * @summary Get moon information
         * @param {number} moonId moon_id integer
         * @param {GetUniverseMoonsMoonIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseMoonsMoonId: async (moonId: number, datasource?: GetUniverseMoonsMoonIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moonId' is not null or undefined
            assertParamExists('getUniverseMoonsMoonId', 'moonId', moonId)
            const localVarPath = `/universe/moons/{moon_id}/`
                .replace(`{${"moon_id"}}`, encodeURIComponent(String(moonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
         * @summary Get planet information
         * @param {number} planetId planet_id integer
         * @param {GetUniversePlanetsPlanetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversePlanetsPlanetId: async (planetId: number, datasource?: GetUniversePlanetsPlanetIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planetId' is not null or undefined
            assertParamExists('getUniversePlanetsPlanetId', 'planetId', planetId)
            const localVarPath = `/universe/planets/{planet_id}/`
                .replace(`{${"planet_id"}}`, encodeURIComponent(String(planetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
         * @summary Get character races
         * @param {GetUniverseRacesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseRacesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseRacesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRaces: async (acceptLanguage?: GetUniverseRacesAcceptLanguageEnum, datasource?: GetUniverseRacesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseRacesLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/races/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
         * @summary Get regions
         * @param {GetUniverseRegionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRegions: async (datasource?: GetUniverseRegionsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/regions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
         * @summary Get region information
         * @param {number} regionId region_id integer
         * @param {GetUniverseRegionsRegionIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseRegionsRegionIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseRegionsRegionIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRegionsRegionId: async (regionId: number, acceptLanguage?: GetUniverseRegionsRegionIdAcceptLanguageEnum, datasource?: GetUniverseRegionsRegionIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseRegionsRegionIdLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('getUniverseRegionsRegionId', 'regionId', regionId)
            const localVarPath = `/universe/regions/{region_id}/`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
         * @summary Get stargate information
         * @param {number} stargateId stargate_id integer
         * @param {GetUniverseStargatesStargateIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStargatesStargateId: async (stargateId: number, datasource?: GetUniverseStargatesStargateIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stargateId' is not null or undefined
            assertParamExists('getUniverseStargatesStargateId', 'stargateId', stargateId)
            const localVarPath = `/universe/stargates/{stargate_id}/`
                .replace(`{${"stargate_id"}}`, encodeURIComponent(String(stargateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
         * @summary Get star information
         * @param {number} starId star_id integer
         * @param {GetUniverseStarsStarIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStarsStarId: async (starId: number, datasource?: GetUniverseStarsStarIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'starId' is not null or undefined
            assertParamExists('getUniverseStarsStarId', 'starId', starId)
            const localVarPath = `/universe/stars/{star_id}/`
                .replace(`{${"star_id"}}`, encodeURIComponent(String(starId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
         * @summary Get station information
         * @param {number} stationId station_id integer
         * @param {GetUniverseStationsStationIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStationsStationId: async (stationId: number, datasource?: GetUniverseStationsStationIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stationId' is not null or undefined
            assertParamExists('getUniverseStationsStationId', 'stationId', stationId)
            const localVarPath = `/universe/stations/{station_id}/`
                .replace(`{${"station_id"}}`, encodeURIComponent(String(stationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
         * @summary List all public structures
         * @param {GetUniverseStructuresDatasourceEnum} [datasource] The server name you would like data from
         * @param {GetUniverseStructuresFilterEnum} [filter] Only list public structures that have this service online
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStructures: async (datasource?: GetUniverseStructuresDatasourceEnum, filter?: GetUniverseStructuresFilterEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/structures/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/legacy/universe/structures/{structure_id}/`  Alternate route: `/v1/universe/structures/{structure_id}/`  Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get structure information
         * @param {number} structureId An Eve structure ID
         * @param {GetUniverseStructuresStructureIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStructuresStructureId: async (structureId: number, datasource?: GetUniverseStructuresStructureIdDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'structureId' is not null or undefined
            assertParamExists('getUniverseStructuresStructureId', 'structureId', structureId)
            const localVarPath = `/universe/structures/{structure_id}/`
                .replace(`{${"structure_id"}}`, encodeURIComponent(String(structureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-universe.read_structures.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
         * @summary Get system jumps
         * @param {GetUniverseSystemJumpsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemJumps: async (datasource?: GetUniverseSystemJumpsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/system_jumps/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
         * @summary Get system kills
         * @param {GetUniverseSystemKillsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemKills: async (datasource?: GetUniverseSystemKillsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/system_kills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
         * @summary Get solar systems
         * @param {GetUniverseSystemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystems: async (datasource?: GetUniverseSystemsDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/systems/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
         * @summary Get solar system information
         * @param {number} systemId system_id integer
         * @param {GetUniverseSystemsSystemIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseSystemsSystemIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseSystemsSystemIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemsSystemId: async (systemId: number, acceptLanguage?: GetUniverseSystemsSystemIdAcceptLanguageEnum, datasource?: GetUniverseSystemsSystemIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseSystemsSystemIdLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('getUniverseSystemsSystemId', 'systemId', systemId)
            const localVarPath = `/universe/systems/{system_id}/`
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
         * @summary Get types
         * @param {GetUniverseTypesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseTypes: async (datasource?: GetUniverseTypesDatasourceEnum, ifNoneMatch?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/universe/types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/legacy/universe/types/{type_id}/`  Alternate route: `/v2/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
         * @summary Get type information
         * @param {number} typeId An Eve item type ID
         * @param {GetUniverseTypesTypeIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseTypesTypeIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseTypesTypeIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseTypesTypeId: async (typeId: number, acceptLanguage?: GetUniverseTypesTypeIdAcceptLanguageEnum, datasource?: GetUniverseTypesTypeIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseTypesTypeIdLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeId' is not null or undefined
            assertParamExists('getUniverseTypesTypeId', 'typeId', typeId)
            const localVarPath = `/universe/types/{type_id}/`
                .replace(`{${"type_id"}}`, encodeURIComponent(String(typeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
         * @summary Bulk names to IDs
         * @param {Set<string>} names The names to resolve
         * @param {PostUniverseIdsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {PostUniverseIdsDatasourceEnum} [datasource] The server name you would like data from
         * @param {PostUniverseIdsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUniverseIds: async (names: Set<string>, acceptLanguage?: PostUniverseIdsAcceptLanguageEnum, datasource?: PostUniverseIdsDatasourceEnum, language?: PostUniverseIdsLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'names' is not null or undefined
            assertParamExists('postUniverseIds', 'names', names)
            const localVarPath = `/universe/ids/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(names, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/legacy/universe/names/`  Alternate route: `/v2/universe/names/`  Alternate route: `/v3/universe/names/` 
         * @summary Get names and categories for a set of IDs
         * @param {Set<number>} ids The ids to resolve
         * @param {PostUniverseNamesDatasourceEnum} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUniverseNames: async (ids: Set<number>, datasource?: PostUniverseNamesDatasourceEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('postUniverseNames', 'ids', ids)
            const localVarPath = `/universe/names/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ids, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UniverseApi - functional programming interface
 */
export const UniverseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UniverseApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
         * @summary Get ancestries
         * @param {GetUniverseAncestriesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseAncestriesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseAncestriesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseAncestries(acceptLanguage?: GetUniverseAncestriesAcceptLanguageEnum, datasource?: GetUniverseAncestriesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseAncestriesLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUniverseAncestries200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseAncestries(acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseAncestries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
         * @summary Get asteroid belt information
         * @param {number} asteroidBeltId asteroid_belt_id integer
         * @param {GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId: number, datasource?: GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseAsteroidBeltsAsteroidBeltIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseAsteroidBeltsAsteroidBeltId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
         * @summary Get bloodlines
         * @param {GetUniverseBloodlinesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseBloodlinesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseBloodlinesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseBloodlines(acceptLanguage?: GetUniverseBloodlinesAcceptLanguageEnum, datasource?: GetUniverseBloodlinesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseBloodlinesLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUniverseBloodlines200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseBloodlines(acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseBloodlines']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
         * @summary Get item categories
         * @param {GetUniverseCategoriesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseCategories(datasource?: GetUniverseCategoriesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseCategories(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
         * @summary Get item category information
         * @param {number} categoryId An Eve item category ID
         * @param {GetUniverseCategoriesCategoryIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseCategoriesCategoryIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseCategoriesCategoryIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseCategoriesCategoryId(categoryId: number, acceptLanguage?: GetUniverseCategoriesCategoryIdAcceptLanguageEnum, datasource?: GetUniverseCategoriesCategoryIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseCategoriesCategoryIdLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseCategoriesCategoryIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseCategoriesCategoryId(categoryId, acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseCategoriesCategoryId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
         * @summary Get constellations
         * @param {GetUniverseConstellationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseConstellations(datasource?: GetUniverseConstellationsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseConstellations(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseConstellations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
         * @summary Get constellation information
         * @param {number} constellationId constellation_id integer
         * @param {GetUniverseConstellationsConstellationIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseConstellationsConstellationIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseConstellationsConstellationIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseConstellationsConstellationId(constellationId: number, acceptLanguage?: GetUniverseConstellationsConstellationIdAcceptLanguageEnum, datasource?: GetUniverseConstellationsConstellationIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseConstellationsConstellationIdLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseConstellationsConstellationIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseConstellationsConstellationId(constellationId, acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseConstellationsConstellationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
         * @summary Get factions
         * @param {GetUniverseFactionsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseFactionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseFactionsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseFactions(acceptLanguage?: GetUniverseFactionsAcceptLanguageEnum, datasource?: GetUniverseFactionsDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseFactionsLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUniverseFactions200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseFactions(acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseFactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
         * @summary Get graphics
         * @param {GetUniverseGraphicsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseGraphics(datasource?: GetUniverseGraphicsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseGraphics(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseGraphics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
         * @summary Get graphic information
         * @param {number} graphicId graphic_id integer
         * @param {GetUniverseGraphicsGraphicIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseGraphicsGraphicId(graphicId: number, datasource?: GetUniverseGraphicsGraphicIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseGraphicsGraphicIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseGraphicsGraphicId(graphicId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseGraphicsGraphicId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {GetUniverseGroupsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseGroups(datasource?: GetUniverseGroupsDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseGroups(datasource, ifNoneMatch, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} groupId An Eve item group ID
         * @param {GetUniverseGroupsGroupIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseGroupsGroupIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseGroupsGroupIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseGroupsGroupId(groupId: number, acceptLanguage?: GetUniverseGroupsGroupIdAcceptLanguageEnum, datasource?: GetUniverseGroupsGroupIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseGroupsGroupIdLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseGroupsGroupIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseGroupsGroupId(groupId, acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseGroupsGroupId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
         * @summary Get moon information
         * @param {number} moonId moon_id integer
         * @param {GetUniverseMoonsMoonIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseMoonsMoonId(moonId: number, datasource?: GetUniverseMoonsMoonIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseMoonsMoonIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseMoonsMoonId(moonId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseMoonsMoonId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
         * @summary Get planet information
         * @param {number} planetId planet_id integer
         * @param {GetUniversePlanetsPlanetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniversePlanetsPlanetId(planetId: number, datasource?: GetUniversePlanetsPlanetIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniversePlanetsPlanetIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniversePlanetsPlanetId(planetId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniversePlanetsPlanetId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
         * @summary Get character races
         * @param {GetUniverseRacesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseRacesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseRacesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseRaces(acceptLanguage?: GetUniverseRacesAcceptLanguageEnum, datasource?: GetUniverseRacesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseRacesLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUniverseRaces200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseRaces(acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseRaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
         * @summary Get regions
         * @param {GetUniverseRegionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseRegions(datasource?: GetUniverseRegionsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseRegions(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseRegions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
         * @summary Get region information
         * @param {number} regionId region_id integer
         * @param {GetUniverseRegionsRegionIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseRegionsRegionIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseRegionsRegionIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseRegionsRegionId(regionId: number, acceptLanguage?: GetUniverseRegionsRegionIdAcceptLanguageEnum, datasource?: GetUniverseRegionsRegionIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseRegionsRegionIdLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseRegionsRegionIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseRegionsRegionId(regionId, acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseRegionsRegionId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
         * @summary Get stargate information
         * @param {number} stargateId stargate_id integer
         * @param {GetUniverseStargatesStargateIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseStargatesStargateId(stargateId: number, datasource?: GetUniverseStargatesStargateIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseStargatesStargateIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseStargatesStargateId(stargateId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseStargatesStargateId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
         * @summary Get star information
         * @param {number} starId star_id integer
         * @param {GetUniverseStarsStarIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseStarsStarId(starId: number, datasource?: GetUniverseStarsStarIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseStarsStarIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseStarsStarId(starId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseStarsStarId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
         * @summary Get station information
         * @param {number} stationId station_id integer
         * @param {GetUniverseStationsStationIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseStationsStationId(stationId: number, datasource?: GetUniverseStationsStationIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseStationsStationIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseStationsStationId(stationId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseStationsStationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
         * @summary List all public structures
         * @param {GetUniverseStructuresDatasourceEnum} [datasource] The server name you would like data from
         * @param {GetUniverseStructuresFilterEnum} [filter] Only list public structures that have this service online
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseStructures(datasource?: GetUniverseStructuresDatasourceEnum, filter?: GetUniverseStructuresFilterEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseStructures(datasource, filter, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseStructures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/legacy/universe/structures/{structure_id}/`  Alternate route: `/v1/universe/structures/{structure_id}/`  Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get structure information
         * @param {number} structureId An Eve structure ID
         * @param {GetUniverseStructuresStructureIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseStructuresStructureId(structureId: number, datasource?: GetUniverseStructuresStructureIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseStructuresStructureIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseStructuresStructureId(structureId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseStructuresStructureId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
         * @summary Get system jumps
         * @param {GetUniverseSystemJumpsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseSystemJumps(datasource?: GetUniverseSystemJumpsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUniverseSystemJumps200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseSystemJumps(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseSystemJumps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
         * @summary Get system kills
         * @param {GetUniverseSystemKillsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseSystemKills(datasource?: GetUniverseSystemKillsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUniverseSystemKills200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseSystemKills(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseSystemKills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
         * @summary Get solar systems
         * @param {GetUniverseSystemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseSystems(datasource?: GetUniverseSystemsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseSystems(datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseSystems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
         * @summary Get solar system information
         * @param {number} systemId system_id integer
         * @param {GetUniverseSystemsSystemIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseSystemsSystemIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseSystemsSystemIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseSystemsSystemId(systemId: number, acceptLanguage?: GetUniverseSystemsSystemIdAcceptLanguageEnum, datasource?: GetUniverseSystemsSystemIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseSystemsSystemIdLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseSystemsSystemIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseSystemsSystemId(systemId, acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseSystemsSystemId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
         * @summary Get types
         * @param {GetUniverseTypesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseTypes(datasource?: GetUniverseTypesDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseTypes(datasource, ifNoneMatch, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/legacy/universe/types/{type_id}/`  Alternate route: `/v2/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
         * @summary Get type information
         * @param {number} typeId An Eve item type ID
         * @param {GetUniverseTypesTypeIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseTypesTypeIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseTypesTypeIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverseTypesTypeId(typeId: number, acceptLanguage?: GetUniverseTypesTypeIdAcceptLanguageEnum, datasource?: GetUniverseTypesTypeIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseTypesTypeIdLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUniverseTypesTypeIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverseTypesTypeId(typeId, acceptLanguage, datasource, ifNoneMatch, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.getUniverseTypesTypeId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
         * @summary Bulk names to IDs
         * @param {Set<string>} names The names to resolve
         * @param {PostUniverseIdsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {PostUniverseIdsDatasourceEnum} [datasource] The server name you would like data from
         * @param {PostUniverseIdsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUniverseIds(names: Set<string>, acceptLanguage?: PostUniverseIdsAcceptLanguageEnum, datasource?: PostUniverseIdsDatasourceEnum, language?: PostUniverseIdsLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostUniverseIdsOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUniverseIds(names, acceptLanguage, datasource, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.postUniverseIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/legacy/universe/names/`  Alternate route: `/v2/universe/names/`  Alternate route: `/v3/universe/names/` 
         * @summary Get names and categories for a set of IDs
         * @param {Set<number>} ids The ids to resolve
         * @param {PostUniverseNamesDatasourceEnum} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUniverseNames(ids: Set<number>, datasource?: PostUniverseNamesDatasourceEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostUniverseNames200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUniverseNames(ids, datasource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UniverseApi.postUniverseNames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UniverseApi - factory interface
 */
export const UniverseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UniverseApiFp(configuration)
    return {
        /**
         * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
         * @summary Get ancestries
         * @param {GetUniverseAncestriesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseAncestriesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseAncestriesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseAncestries(acceptLanguage?: GetUniverseAncestriesAcceptLanguageEnum, datasource?: GetUniverseAncestriesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseAncestriesLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUniverseAncestries200Ok>> {
            return localVarFp.getUniverseAncestries(acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
         * @summary Get asteroid belt information
         * @param {number} asteroidBeltId asteroid_belt_id integer
         * @param {GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId: number, datasource?: GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseAsteroidBeltsAsteroidBeltIdOk> {
            return localVarFp.getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
         * @summary Get bloodlines
         * @param {GetUniverseBloodlinesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseBloodlinesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseBloodlinesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseBloodlines(acceptLanguage?: GetUniverseBloodlinesAcceptLanguageEnum, datasource?: GetUniverseBloodlinesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseBloodlinesLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUniverseBloodlines200Ok>> {
            return localVarFp.getUniverseBloodlines(acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
         * @summary Get item categories
         * @param {GetUniverseCategoriesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseCategories(datasource?: GetUniverseCategoriesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getUniverseCategories(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
         * @summary Get item category information
         * @param {number} categoryId An Eve item category ID
         * @param {GetUniverseCategoriesCategoryIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseCategoriesCategoryIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseCategoriesCategoryIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseCategoriesCategoryId(categoryId: number, acceptLanguage?: GetUniverseCategoriesCategoryIdAcceptLanguageEnum, datasource?: GetUniverseCategoriesCategoryIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseCategoriesCategoryIdLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseCategoriesCategoryIdOk> {
            return localVarFp.getUniverseCategoriesCategoryId(categoryId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
         * @summary Get constellations
         * @param {GetUniverseConstellationsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseConstellations(datasource?: GetUniverseConstellationsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getUniverseConstellations(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
         * @summary Get constellation information
         * @param {number} constellationId constellation_id integer
         * @param {GetUniverseConstellationsConstellationIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseConstellationsConstellationIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseConstellationsConstellationIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseConstellationsConstellationId(constellationId: number, acceptLanguage?: GetUniverseConstellationsConstellationIdAcceptLanguageEnum, datasource?: GetUniverseConstellationsConstellationIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseConstellationsConstellationIdLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseConstellationsConstellationIdOk> {
            return localVarFp.getUniverseConstellationsConstellationId(constellationId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
         * @summary Get factions
         * @param {GetUniverseFactionsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseFactionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseFactionsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseFactions(acceptLanguage?: GetUniverseFactionsAcceptLanguageEnum, datasource?: GetUniverseFactionsDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseFactionsLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUniverseFactions200Ok>> {
            return localVarFp.getUniverseFactions(acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
         * @summary Get graphics
         * @param {GetUniverseGraphicsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGraphics(datasource?: GetUniverseGraphicsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getUniverseGraphics(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
         * @summary Get graphic information
         * @param {number} graphicId graphic_id integer
         * @param {GetUniverseGraphicsGraphicIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGraphicsGraphicId(graphicId: number, datasource?: GetUniverseGraphicsGraphicIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseGraphicsGraphicIdOk> {
            return localVarFp.getUniverseGraphicsGraphicId(graphicId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
         * @summary Get item groups
         * @param {GetUniverseGroupsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGroups(datasource?: GetUniverseGroupsDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getUniverseGroups(datasource, ifNoneMatch, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
         * @summary Get item group information
         * @param {number} groupId An Eve item group ID
         * @param {GetUniverseGroupsGroupIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseGroupsGroupIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseGroupsGroupIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseGroupsGroupId(groupId: number, acceptLanguage?: GetUniverseGroupsGroupIdAcceptLanguageEnum, datasource?: GetUniverseGroupsGroupIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseGroupsGroupIdLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseGroupsGroupIdOk> {
            return localVarFp.getUniverseGroupsGroupId(groupId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
         * @summary Get moon information
         * @param {number} moonId moon_id integer
         * @param {GetUniverseMoonsMoonIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseMoonsMoonId(moonId: number, datasource?: GetUniverseMoonsMoonIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseMoonsMoonIdOk> {
            return localVarFp.getUniverseMoonsMoonId(moonId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
         * @summary Get planet information
         * @param {number} planetId planet_id integer
         * @param {GetUniversePlanetsPlanetIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversePlanetsPlanetId(planetId: number, datasource?: GetUniversePlanetsPlanetIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUniversePlanetsPlanetIdOk> {
            return localVarFp.getUniversePlanetsPlanetId(planetId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
         * @summary Get character races
         * @param {GetUniverseRacesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseRacesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseRacesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRaces(acceptLanguage?: GetUniverseRacesAcceptLanguageEnum, datasource?: GetUniverseRacesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseRacesLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUniverseRaces200Ok>> {
            return localVarFp.getUniverseRaces(acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
         * @summary Get regions
         * @param {GetUniverseRegionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRegions(datasource?: GetUniverseRegionsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getUniverseRegions(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
         * @summary Get region information
         * @param {number} regionId region_id integer
         * @param {GetUniverseRegionsRegionIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseRegionsRegionIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseRegionsRegionIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseRegionsRegionId(regionId: number, acceptLanguage?: GetUniverseRegionsRegionIdAcceptLanguageEnum, datasource?: GetUniverseRegionsRegionIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseRegionsRegionIdLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseRegionsRegionIdOk> {
            return localVarFp.getUniverseRegionsRegionId(regionId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
         * @summary Get stargate information
         * @param {number} stargateId stargate_id integer
         * @param {GetUniverseStargatesStargateIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStargatesStargateId(stargateId: number, datasource?: GetUniverseStargatesStargateIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseStargatesStargateIdOk> {
            return localVarFp.getUniverseStargatesStargateId(stargateId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
         * @summary Get star information
         * @param {number} starId star_id integer
         * @param {GetUniverseStarsStarIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStarsStarId(starId: number, datasource?: GetUniverseStarsStarIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseStarsStarIdOk> {
            return localVarFp.getUniverseStarsStarId(starId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
         * @summary Get station information
         * @param {number} stationId station_id integer
         * @param {GetUniverseStationsStationIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStationsStationId(stationId: number, datasource?: GetUniverseStationsStationIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseStationsStationIdOk> {
            return localVarFp.getUniverseStationsStationId(stationId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
         * @summary List all public structures
         * @param {GetUniverseStructuresDatasourceEnum} [datasource] The server name you would like data from
         * @param {GetUniverseStructuresFilterEnum} [filter] Only list public structures that have this service online
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStructures(datasource?: GetUniverseStructuresDatasourceEnum, filter?: GetUniverseStructuresFilterEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Set<number>> {
            return localVarFp.getUniverseStructures(datasource, filter, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/legacy/universe/structures/{structure_id}/`  Alternate route: `/v1/universe/structures/{structure_id}/`  Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get structure information
         * @param {number} structureId An Eve structure ID
         * @param {GetUniverseStructuresStructureIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseStructuresStructureId(structureId: number, datasource?: GetUniverseStructuresStructureIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseStructuresStructureIdOk> {
            return localVarFp.getUniverseStructuresStructureId(structureId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
         * @summary Get system jumps
         * @param {GetUniverseSystemJumpsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemJumps(datasource?: GetUniverseSystemJumpsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUniverseSystemJumps200Ok>> {
            return localVarFp.getUniverseSystemJumps(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
         * @summary Get system kills
         * @param {GetUniverseSystemKillsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemKills(datasource?: GetUniverseSystemKillsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUniverseSystemKills200Ok>> {
            return localVarFp.getUniverseSystemKills(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
         * @summary Get solar systems
         * @param {GetUniverseSystemsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystems(datasource?: GetUniverseSystemsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getUniverseSystems(datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
         * @summary Get solar system information
         * @param {number} systemId system_id integer
         * @param {GetUniverseSystemsSystemIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseSystemsSystemIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseSystemsSystemIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseSystemsSystemId(systemId: number, acceptLanguage?: GetUniverseSystemsSystemIdAcceptLanguageEnum, datasource?: GetUniverseSystemsSystemIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseSystemsSystemIdLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseSystemsSystemIdOk> {
            return localVarFp.getUniverseSystemsSystemId(systemId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
         * @summary Get types
         * @param {GetUniverseTypesDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseTypes(datasource?: GetUniverseTypesDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getUniverseTypes(datasource, ifNoneMatch, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/legacy/universe/types/{type_id}/`  Alternate route: `/v2/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
         * @summary Get type information
         * @param {number} typeId An Eve item type ID
         * @param {GetUniverseTypesTypeIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {GetUniverseTypesTypeIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {GetUniverseTypesTypeIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverseTypesTypeId(typeId: number, acceptLanguage?: GetUniverseTypesTypeIdAcceptLanguageEnum, datasource?: GetUniverseTypesTypeIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseTypesTypeIdLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetUniverseTypesTypeIdOk> {
            return localVarFp.getUniverseTypesTypeId(typeId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
         * @summary Bulk names to IDs
         * @param {Set<string>} names The names to resolve
         * @param {PostUniverseIdsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
         * @param {PostUniverseIdsDatasourceEnum} [datasource] The server name you would like data from
         * @param {PostUniverseIdsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUniverseIds(names: Set<string>, acceptLanguage?: PostUniverseIdsAcceptLanguageEnum, datasource?: PostUniverseIdsDatasourceEnum, language?: PostUniverseIdsLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<PostUniverseIdsOk> {
            return localVarFp.postUniverseIds(names, acceptLanguage, datasource, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/legacy/universe/names/`  Alternate route: `/v2/universe/names/`  Alternate route: `/v3/universe/names/` 
         * @summary Get names and categories for a set of IDs
         * @param {Set<number>} ids The ids to resolve
         * @param {PostUniverseNamesDatasourceEnum} [datasource] The server name you would like data from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUniverseNames(ids: Set<number>, datasource?: PostUniverseNamesDatasourceEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<PostUniverseNames200Ok>> {
            return localVarFp.postUniverseNames(ids, datasource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UniverseApi - object-oriented interface
 */
export class UniverseApi extends BaseAPI {
    /**
     * Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
     * @summary Get ancestries
     * @param {GetUniverseAncestriesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetUniverseAncestriesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetUniverseAncestriesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseAncestries(acceptLanguage?: GetUniverseAncestriesAcceptLanguageEnum, datasource?: GetUniverseAncestriesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseAncestriesLanguageEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseAncestries(acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
     * @summary Get asteroid belt information
     * @param {number} asteroidBeltId asteroid_belt_id integer
     * @param {GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId: number, datasource?: GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
     * @summary Get bloodlines
     * @param {GetUniverseBloodlinesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetUniverseBloodlinesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetUniverseBloodlinesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseBloodlines(acceptLanguage?: GetUniverseBloodlinesAcceptLanguageEnum, datasource?: GetUniverseBloodlinesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseBloodlinesLanguageEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseBloodlines(acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
     * @summary Get item categories
     * @param {GetUniverseCategoriesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseCategories(datasource?: GetUniverseCategoriesDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseCategories(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
     * @summary Get item category information
     * @param {number} categoryId An Eve item category ID
     * @param {GetUniverseCategoriesCategoryIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetUniverseCategoriesCategoryIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetUniverseCategoriesCategoryIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseCategoriesCategoryId(categoryId: number, acceptLanguage?: GetUniverseCategoriesCategoryIdAcceptLanguageEnum, datasource?: GetUniverseCategoriesCategoryIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseCategoriesCategoryIdLanguageEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseCategoriesCategoryId(categoryId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
     * @summary Get constellations
     * @param {GetUniverseConstellationsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseConstellations(datasource?: GetUniverseConstellationsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseConstellations(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
     * @summary Get constellation information
     * @param {number} constellationId constellation_id integer
     * @param {GetUniverseConstellationsConstellationIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetUniverseConstellationsConstellationIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetUniverseConstellationsConstellationIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseConstellationsConstellationId(constellationId: number, acceptLanguage?: GetUniverseConstellationsConstellationIdAcceptLanguageEnum, datasource?: GetUniverseConstellationsConstellationIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseConstellationsConstellationIdLanguageEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseConstellationsConstellationId(constellationId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
     * @summary Get factions
     * @param {GetUniverseFactionsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetUniverseFactionsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetUniverseFactionsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseFactions(acceptLanguage?: GetUniverseFactionsAcceptLanguageEnum, datasource?: GetUniverseFactionsDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseFactionsLanguageEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseFactions(acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
     * @summary Get graphics
     * @param {GetUniverseGraphicsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseGraphics(datasource?: GetUniverseGraphicsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseGraphics(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
     * @summary Get graphic information
     * @param {number} graphicId graphic_id integer
     * @param {GetUniverseGraphicsGraphicIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseGraphicsGraphicId(graphicId: number, datasource?: GetUniverseGraphicsGraphicIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseGraphicsGraphicId(graphicId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
     * @summary Get item groups
     * @param {GetUniverseGroupsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseGroups(datasource?: GetUniverseGroupsDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseGroups(datasource, ifNoneMatch, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
     * @summary Get item group information
     * @param {number} groupId An Eve item group ID
     * @param {GetUniverseGroupsGroupIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetUniverseGroupsGroupIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetUniverseGroupsGroupIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseGroupsGroupId(groupId: number, acceptLanguage?: GetUniverseGroupsGroupIdAcceptLanguageEnum, datasource?: GetUniverseGroupsGroupIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseGroupsGroupIdLanguageEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseGroupsGroupId(groupId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
     * @summary Get moon information
     * @param {number} moonId moon_id integer
     * @param {GetUniverseMoonsMoonIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseMoonsMoonId(moonId: number, datasource?: GetUniverseMoonsMoonIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseMoonsMoonId(moonId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
     * @summary Get planet information
     * @param {number} planetId planet_id integer
     * @param {GetUniversePlanetsPlanetIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniversePlanetsPlanetId(planetId: number, datasource?: GetUniversePlanetsPlanetIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniversePlanetsPlanetId(planetId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
     * @summary Get character races
     * @param {GetUniverseRacesAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetUniverseRacesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetUniverseRacesLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseRaces(acceptLanguage?: GetUniverseRacesAcceptLanguageEnum, datasource?: GetUniverseRacesDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseRacesLanguageEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseRaces(acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
     * @summary Get regions
     * @param {GetUniverseRegionsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseRegions(datasource?: GetUniverseRegionsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseRegions(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
     * @summary Get region information
     * @param {number} regionId region_id integer
     * @param {GetUniverseRegionsRegionIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetUniverseRegionsRegionIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetUniverseRegionsRegionIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseRegionsRegionId(regionId: number, acceptLanguage?: GetUniverseRegionsRegionIdAcceptLanguageEnum, datasource?: GetUniverseRegionsRegionIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseRegionsRegionIdLanguageEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseRegionsRegionId(regionId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
     * @summary Get stargate information
     * @param {number} stargateId stargate_id integer
     * @param {GetUniverseStargatesStargateIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseStargatesStargateId(stargateId: number, datasource?: GetUniverseStargatesStargateIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseStargatesStargateId(stargateId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
     * @summary Get star information
     * @param {number} starId star_id integer
     * @param {GetUniverseStarsStarIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseStarsStarId(starId: number, datasource?: GetUniverseStarsStarIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseStarsStarId(starId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
     * @summary Get station information
     * @param {number} stationId station_id integer
     * @param {GetUniverseStationsStationIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseStationsStationId(stationId: number, datasource?: GetUniverseStationsStationIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseStationsStationId(stationId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
     * @summary List all public structures
     * @param {GetUniverseStructuresDatasourceEnum} [datasource] The server name you would like data from
     * @param {GetUniverseStructuresFilterEnum} [filter] Only list public structures that have this service online
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseStructures(datasource?: GetUniverseStructuresDatasourceEnum, filter?: GetUniverseStructuresFilterEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseStructures(datasource, filter, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/legacy/universe/structures/{structure_id}/`  Alternate route: `/v1/universe/structures/{structure_id}/`  Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get structure information
     * @param {number} structureId An Eve structure ID
     * @param {GetUniverseStructuresStructureIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseStructuresStructureId(structureId: number, datasource?: GetUniverseStructuresStructureIdDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseStructuresStructureId(structureId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
     * @summary Get system jumps
     * @param {GetUniverseSystemJumpsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseSystemJumps(datasource?: GetUniverseSystemJumpsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseSystemJumps(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
     * @summary Get system kills
     * @param {GetUniverseSystemKillsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseSystemKills(datasource?: GetUniverseSystemKillsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseSystemKills(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
     * @summary Get solar systems
     * @param {GetUniverseSystemsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseSystems(datasource?: GetUniverseSystemsDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseSystems(datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
     * @summary Get solar system information
     * @param {number} systemId system_id integer
     * @param {GetUniverseSystemsSystemIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetUniverseSystemsSystemIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetUniverseSystemsSystemIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseSystemsSystemId(systemId: number, acceptLanguage?: GetUniverseSystemsSystemIdAcceptLanguageEnum, datasource?: GetUniverseSystemsSystemIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseSystemsSystemIdLanguageEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseSystemsSystemId(systemId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
     * @summary Get types
     * @param {GetUniverseTypesDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseTypes(datasource?: GetUniverseTypesDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseTypes(datasource, ifNoneMatch, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/legacy/universe/types/{type_id}/`  Alternate route: `/v2/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
     * @summary Get type information
     * @param {number} typeId An Eve item type ID
     * @param {GetUniverseTypesTypeIdAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {GetUniverseTypesTypeIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {GetUniverseTypesTypeIdLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUniverseTypesTypeId(typeId: number, acceptLanguage?: GetUniverseTypesTypeIdAcceptLanguageEnum, datasource?: GetUniverseTypesTypeIdDatasourceEnum, ifNoneMatch?: string, language?: GetUniverseTypesTypeIdLanguageEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).getUniverseTypesTypeId(typeId, acceptLanguage, datasource, ifNoneMatch, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
     * @summary Bulk names to IDs
     * @param {Set<string>} names The names to resolve
     * @param {PostUniverseIdsAcceptLanguageEnum} [acceptLanguage] Language to use in the response
     * @param {PostUniverseIdsDatasourceEnum} [datasource] The server name you would like data from
     * @param {PostUniverseIdsLanguageEnum} [language] Language to use in the response, takes precedence over Accept-Language
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUniverseIds(names: Set<string>, acceptLanguage?: PostUniverseIdsAcceptLanguageEnum, datasource?: PostUniverseIdsDatasourceEnum, language?: PostUniverseIdsLanguageEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).postUniverseIds(names, acceptLanguage, datasource, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resolve a set of IDs to names and categories. Supported ID\'s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/legacy/universe/names/`  Alternate route: `/v2/universe/names/`  Alternate route: `/v3/universe/names/` 
     * @summary Get names and categories for a set of IDs
     * @param {Set<number>} ids The ids to resolve
     * @param {PostUniverseNamesDatasourceEnum} [datasource] The server name you would like data from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUniverseNames(ids: Set<number>, datasource?: PostUniverseNamesDatasourceEnum, options?: RawAxiosRequestConfig) {
        return UniverseApiFp(this.configuration).postUniverseNames(ids, datasource, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetUniverseAncestriesAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseAncestriesAcceptLanguageEnum = typeof GetUniverseAncestriesAcceptLanguageEnum[keyof typeof GetUniverseAncestriesAcceptLanguageEnum];
export const GetUniverseAncestriesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseAncestriesDatasourceEnum = typeof GetUniverseAncestriesDatasourceEnum[keyof typeof GetUniverseAncestriesDatasourceEnum];
export const GetUniverseAncestriesLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseAncestriesLanguageEnum = typeof GetUniverseAncestriesLanguageEnum[keyof typeof GetUniverseAncestriesLanguageEnum];
export const GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum = typeof GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum[keyof typeof GetUniverseAsteroidBeltsAsteroidBeltIdDatasourceEnum];
export const GetUniverseBloodlinesAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseBloodlinesAcceptLanguageEnum = typeof GetUniverseBloodlinesAcceptLanguageEnum[keyof typeof GetUniverseBloodlinesAcceptLanguageEnum];
export const GetUniverseBloodlinesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseBloodlinesDatasourceEnum = typeof GetUniverseBloodlinesDatasourceEnum[keyof typeof GetUniverseBloodlinesDatasourceEnum];
export const GetUniverseBloodlinesLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseBloodlinesLanguageEnum = typeof GetUniverseBloodlinesLanguageEnum[keyof typeof GetUniverseBloodlinesLanguageEnum];
export const GetUniverseCategoriesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseCategoriesDatasourceEnum = typeof GetUniverseCategoriesDatasourceEnum[keyof typeof GetUniverseCategoriesDatasourceEnum];
export const GetUniverseCategoriesCategoryIdAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseCategoriesCategoryIdAcceptLanguageEnum = typeof GetUniverseCategoriesCategoryIdAcceptLanguageEnum[keyof typeof GetUniverseCategoriesCategoryIdAcceptLanguageEnum];
export const GetUniverseCategoriesCategoryIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseCategoriesCategoryIdDatasourceEnum = typeof GetUniverseCategoriesCategoryIdDatasourceEnum[keyof typeof GetUniverseCategoriesCategoryIdDatasourceEnum];
export const GetUniverseCategoriesCategoryIdLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseCategoriesCategoryIdLanguageEnum = typeof GetUniverseCategoriesCategoryIdLanguageEnum[keyof typeof GetUniverseCategoriesCategoryIdLanguageEnum];
export const GetUniverseConstellationsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseConstellationsDatasourceEnum = typeof GetUniverseConstellationsDatasourceEnum[keyof typeof GetUniverseConstellationsDatasourceEnum];
export const GetUniverseConstellationsConstellationIdAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseConstellationsConstellationIdAcceptLanguageEnum = typeof GetUniverseConstellationsConstellationIdAcceptLanguageEnum[keyof typeof GetUniverseConstellationsConstellationIdAcceptLanguageEnum];
export const GetUniverseConstellationsConstellationIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseConstellationsConstellationIdDatasourceEnum = typeof GetUniverseConstellationsConstellationIdDatasourceEnum[keyof typeof GetUniverseConstellationsConstellationIdDatasourceEnum];
export const GetUniverseConstellationsConstellationIdLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseConstellationsConstellationIdLanguageEnum = typeof GetUniverseConstellationsConstellationIdLanguageEnum[keyof typeof GetUniverseConstellationsConstellationIdLanguageEnum];
export const GetUniverseFactionsAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseFactionsAcceptLanguageEnum = typeof GetUniverseFactionsAcceptLanguageEnum[keyof typeof GetUniverseFactionsAcceptLanguageEnum];
export const GetUniverseFactionsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseFactionsDatasourceEnum = typeof GetUniverseFactionsDatasourceEnum[keyof typeof GetUniverseFactionsDatasourceEnum];
export const GetUniverseFactionsLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseFactionsLanguageEnum = typeof GetUniverseFactionsLanguageEnum[keyof typeof GetUniverseFactionsLanguageEnum];
export const GetUniverseGraphicsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseGraphicsDatasourceEnum = typeof GetUniverseGraphicsDatasourceEnum[keyof typeof GetUniverseGraphicsDatasourceEnum];
export const GetUniverseGraphicsGraphicIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseGraphicsGraphicIdDatasourceEnum = typeof GetUniverseGraphicsGraphicIdDatasourceEnum[keyof typeof GetUniverseGraphicsGraphicIdDatasourceEnum];
export const GetUniverseGroupsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseGroupsDatasourceEnum = typeof GetUniverseGroupsDatasourceEnum[keyof typeof GetUniverseGroupsDatasourceEnum];
export const GetUniverseGroupsGroupIdAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseGroupsGroupIdAcceptLanguageEnum = typeof GetUniverseGroupsGroupIdAcceptLanguageEnum[keyof typeof GetUniverseGroupsGroupIdAcceptLanguageEnum];
export const GetUniverseGroupsGroupIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseGroupsGroupIdDatasourceEnum = typeof GetUniverseGroupsGroupIdDatasourceEnum[keyof typeof GetUniverseGroupsGroupIdDatasourceEnum];
export const GetUniverseGroupsGroupIdLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseGroupsGroupIdLanguageEnum = typeof GetUniverseGroupsGroupIdLanguageEnum[keyof typeof GetUniverseGroupsGroupIdLanguageEnum];
export const GetUniverseMoonsMoonIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseMoonsMoonIdDatasourceEnum = typeof GetUniverseMoonsMoonIdDatasourceEnum[keyof typeof GetUniverseMoonsMoonIdDatasourceEnum];
export const GetUniversePlanetsPlanetIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniversePlanetsPlanetIdDatasourceEnum = typeof GetUniversePlanetsPlanetIdDatasourceEnum[keyof typeof GetUniversePlanetsPlanetIdDatasourceEnum];
export const GetUniverseRacesAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseRacesAcceptLanguageEnum = typeof GetUniverseRacesAcceptLanguageEnum[keyof typeof GetUniverseRacesAcceptLanguageEnum];
export const GetUniverseRacesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseRacesDatasourceEnum = typeof GetUniverseRacesDatasourceEnum[keyof typeof GetUniverseRacesDatasourceEnum];
export const GetUniverseRacesLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseRacesLanguageEnum = typeof GetUniverseRacesLanguageEnum[keyof typeof GetUniverseRacesLanguageEnum];
export const GetUniverseRegionsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseRegionsDatasourceEnum = typeof GetUniverseRegionsDatasourceEnum[keyof typeof GetUniverseRegionsDatasourceEnum];
export const GetUniverseRegionsRegionIdAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseRegionsRegionIdAcceptLanguageEnum = typeof GetUniverseRegionsRegionIdAcceptLanguageEnum[keyof typeof GetUniverseRegionsRegionIdAcceptLanguageEnum];
export const GetUniverseRegionsRegionIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseRegionsRegionIdDatasourceEnum = typeof GetUniverseRegionsRegionIdDatasourceEnum[keyof typeof GetUniverseRegionsRegionIdDatasourceEnum];
export const GetUniverseRegionsRegionIdLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseRegionsRegionIdLanguageEnum = typeof GetUniverseRegionsRegionIdLanguageEnum[keyof typeof GetUniverseRegionsRegionIdLanguageEnum];
export const GetUniverseStargatesStargateIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseStargatesStargateIdDatasourceEnum = typeof GetUniverseStargatesStargateIdDatasourceEnum[keyof typeof GetUniverseStargatesStargateIdDatasourceEnum];
export const GetUniverseStarsStarIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseStarsStarIdDatasourceEnum = typeof GetUniverseStarsStarIdDatasourceEnum[keyof typeof GetUniverseStarsStarIdDatasourceEnum];
export const GetUniverseStationsStationIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseStationsStationIdDatasourceEnum = typeof GetUniverseStationsStationIdDatasourceEnum[keyof typeof GetUniverseStationsStationIdDatasourceEnum];
export const GetUniverseStructuresDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseStructuresDatasourceEnum = typeof GetUniverseStructuresDatasourceEnum[keyof typeof GetUniverseStructuresDatasourceEnum];
export const GetUniverseStructuresFilterEnum = {
    Market: 'market',
    ManufacturingBasic: 'manufacturing_basic'
} as const;
export type GetUniverseStructuresFilterEnum = typeof GetUniverseStructuresFilterEnum[keyof typeof GetUniverseStructuresFilterEnum];
export const GetUniverseStructuresStructureIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseStructuresStructureIdDatasourceEnum = typeof GetUniverseStructuresStructureIdDatasourceEnum[keyof typeof GetUniverseStructuresStructureIdDatasourceEnum];
export const GetUniverseSystemJumpsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseSystemJumpsDatasourceEnum = typeof GetUniverseSystemJumpsDatasourceEnum[keyof typeof GetUniverseSystemJumpsDatasourceEnum];
export const GetUniverseSystemKillsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseSystemKillsDatasourceEnum = typeof GetUniverseSystemKillsDatasourceEnum[keyof typeof GetUniverseSystemKillsDatasourceEnum];
export const GetUniverseSystemsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseSystemsDatasourceEnum = typeof GetUniverseSystemsDatasourceEnum[keyof typeof GetUniverseSystemsDatasourceEnum];
export const GetUniverseSystemsSystemIdAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseSystemsSystemIdAcceptLanguageEnum = typeof GetUniverseSystemsSystemIdAcceptLanguageEnum[keyof typeof GetUniverseSystemsSystemIdAcceptLanguageEnum];
export const GetUniverseSystemsSystemIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseSystemsSystemIdDatasourceEnum = typeof GetUniverseSystemsSystemIdDatasourceEnum[keyof typeof GetUniverseSystemsSystemIdDatasourceEnum];
export const GetUniverseSystemsSystemIdLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseSystemsSystemIdLanguageEnum = typeof GetUniverseSystemsSystemIdLanguageEnum[keyof typeof GetUniverseSystemsSystemIdLanguageEnum];
export const GetUniverseTypesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseTypesDatasourceEnum = typeof GetUniverseTypesDatasourceEnum[keyof typeof GetUniverseTypesDatasourceEnum];
export const GetUniverseTypesTypeIdAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseTypesTypeIdAcceptLanguageEnum = typeof GetUniverseTypesTypeIdAcceptLanguageEnum[keyof typeof GetUniverseTypesTypeIdAcceptLanguageEnum];
export const GetUniverseTypesTypeIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetUniverseTypesTypeIdDatasourceEnum = typeof GetUniverseTypesTypeIdDatasourceEnum[keyof typeof GetUniverseTypesTypeIdDatasourceEnum];
export const GetUniverseTypesTypeIdLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type GetUniverseTypesTypeIdLanguageEnum = typeof GetUniverseTypesTypeIdLanguageEnum[keyof typeof GetUniverseTypesTypeIdLanguageEnum];
export const PostUniverseIdsAcceptLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type PostUniverseIdsAcceptLanguageEnum = typeof PostUniverseIdsAcceptLanguageEnum[keyof typeof PostUniverseIdsAcceptLanguageEnum];
export const PostUniverseIdsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostUniverseIdsDatasourceEnum = typeof PostUniverseIdsDatasourceEnum[keyof typeof PostUniverseIdsDatasourceEnum];
export const PostUniverseIdsLanguageEnum = {
    En: 'en',
    EnUs: 'en-us',
    De: 'de',
    Fr: 'fr',
    Ja: 'ja',
    Ru: 'ru',
    Zh: 'zh',
    Ko: 'ko',
    Es: 'es'
} as const;
export type PostUniverseIdsLanguageEnum = typeof PostUniverseIdsLanguageEnum[keyof typeof PostUniverseIdsLanguageEnum];
export const PostUniverseNamesDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostUniverseNamesDatasourceEnum = typeof PostUniverseNamesDatasourceEnum[keyof typeof PostUniverseNamesDatasourceEnum];


/**
 * UserInterfaceApi - axios parameter creator
 */
export const UserInterfaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/` 
         * @summary Set Autopilot Waypoint
         * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
         * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
         * @param {number} destinationId The destination to travel to, can be solar system, station or structure\&#39;s id
         * @param {PostUiAutopilotWaypointDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiAutopilotWaypoint: async (addToBeginning: boolean, clearOtherWaypoints: boolean, destinationId: number, datasource?: PostUiAutopilotWaypointDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addToBeginning' is not null or undefined
            assertParamExists('postUiAutopilotWaypoint', 'addToBeginning', addToBeginning)
            // verify required parameter 'clearOtherWaypoints' is not null or undefined
            assertParamExists('postUiAutopilotWaypoint', 'clearOtherWaypoints', clearOtherWaypoints)
            // verify required parameter 'destinationId' is not null or undefined
            assertParamExists('postUiAutopilotWaypoint', 'destinationId', destinationId)
            const localVarPath = `/ui/autopilot/waypoint/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-ui.write_waypoint.v1"], configuration)

            if (addToBeginning !== undefined) {
                localVarQueryParameter['add_to_beginning'] = addToBeginning;
            }

            if (clearOtherWaypoints !== undefined) {
                localVarQueryParameter['clear_other_waypoints'] = clearOtherWaypoints;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (destinationId !== undefined) {
                localVarQueryParameter['destination_id'] = destinationId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/` 
         * @summary Open Contract Window
         * @param {number} contractId The contract to open
         * @param {PostUiOpenwindowContractDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowContract: async (contractId: number, datasource?: PostUiOpenwindowContractDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('postUiOpenwindowContract', 'contractId', contractId)
            const localVarPath = `/ui/openwindow/contract/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-ui.open_window.v1"], configuration)

            if (contractId !== undefined) {
                localVarQueryParameter['contract_id'] = contractId;
            }

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/` 
         * @summary Open Information Window
         * @param {number} targetId The target to open
         * @param {PostUiOpenwindowInformationDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowInformation: async (targetId: number, datasource?: PostUiOpenwindowInformationDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('postUiOpenwindowInformation', 'targetId', targetId)
            const localVarPath = `/ui/openwindow/information/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-ui.open_window.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['target_id'] = targetId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/` 
         * @summary Open Market Details
         * @param {number} typeId The item type to open in market window
         * @param {PostUiOpenwindowMarketdetailsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowMarketdetails: async (typeId: number, datasource?: PostUiOpenwindowMarketdetailsDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeId' is not null or undefined
            assertParamExists('postUiOpenwindowMarketdetails', 'typeId', typeId)
            const localVarPath = `/ui/openwindow/marketdetails/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-ui.open_window.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['type_id'] = typeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/` 
         * @summary Open New Mail Window
         * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
         * @param {PostUiOpenwindowNewmailDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowNewmail: async (newMail: PostUiOpenwindowNewmailNewMail, datasource?: PostUiOpenwindowNewmailDatasourceEnum, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newMail' is not null or undefined
            assertParamExists('postUiOpenwindowNewmail', 'newMail', newMail)
            const localVarPath = `/ui/openwindow/newmail/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-ui.open_window.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newMail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserInterfaceApi - functional programming interface
 */
export const UserInterfaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserInterfaceApiAxiosParamCreator(configuration)
    return {
        /**
         * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/` 
         * @summary Set Autopilot Waypoint
         * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
         * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
         * @param {number} destinationId The destination to travel to, can be solar system, station or structure\&#39;s id
         * @param {PostUiAutopilotWaypointDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUiAutopilotWaypoint(addToBeginning: boolean, clearOtherWaypoints: boolean, destinationId: number, datasource?: PostUiAutopilotWaypointDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUiAutopilotWaypoint(addToBeginning, clearOtherWaypoints, destinationId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserInterfaceApi.postUiAutopilotWaypoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/` 
         * @summary Open Contract Window
         * @param {number} contractId The contract to open
         * @param {PostUiOpenwindowContractDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUiOpenwindowContract(contractId: number, datasource?: PostUiOpenwindowContractDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUiOpenwindowContract(contractId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserInterfaceApi.postUiOpenwindowContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/` 
         * @summary Open Information Window
         * @param {number} targetId The target to open
         * @param {PostUiOpenwindowInformationDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUiOpenwindowInformation(targetId: number, datasource?: PostUiOpenwindowInformationDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUiOpenwindowInformation(targetId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserInterfaceApi.postUiOpenwindowInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/` 
         * @summary Open Market Details
         * @param {number} typeId The item type to open in market window
         * @param {PostUiOpenwindowMarketdetailsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUiOpenwindowMarketdetails(typeId: number, datasource?: PostUiOpenwindowMarketdetailsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUiOpenwindowMarketdetails(typeId, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserInterfaceApi.postUiOpenwindowMarketdetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/` 
         * @summary Open New Mail Window
         * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
         * @param {PostUiOpenwindowNewmailDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUiOpenwindowNewmail(newMail: PostUiOpenwindowNewmailNewMail, datasource?: PostUiOpenwindowNewmailDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUiOpenwindowNewmail(newMail, datasource, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserInterfaceApi.postUiOpenwindowNewmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserInterfaceApi - factory interface
 */
export const UserInterfaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserInterfaceApiFp(configuration)
    return {
        /**
         * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/` 
         * @summary Set Autopilot Waypoint
         * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
         * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
         * @param {number} destinationId The destination to travel to, can be solar system, station or structure\&#39;s id
         * @param {PostUiAutopilotWaypointDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiAutopilotWaypoint(addToBeginning: boolean, clearOtherWaypoints: boolean, destinationId: number, datasource?: PostUiAutopilotWaypointDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUiAutopilotWaypoint(addToBeginning, clearOtherWaypoints, destinationId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/` 
         * @summary Open Contract Window
         * @param {number} contractId The contract to open
         * @param {PostUiOpenwindowContractDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowContract(contractId: number, datasource?: PostUiOpenwindowContractDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUiOpenwindowContract(contractId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/` 
         * @summary Open Information Window
         * @param {number} targetId The target to open
         * @param {PostUiOpenwindowInformationDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowInformation(targetId: number, datasource?: PostUiOpenwindowInformationDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUiOpenwindowInformation(targetId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/` 
         * @summary Open Market Details
         * @param {number} typeId The item type to open in market window
         * @param {PostUiOpenwindowMarketdetailsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowMarketdetails(typeId: number, datasource?: PostUiOpenwindowMarketdetailsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUiOpenwindowMarketdetails(typeId, datasource, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/` 
         * @summary Open New Mail Window
         * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
         * @param {PostUiOpenwindowNewmailDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUiOpenwindowNewmail(newMail: PostUiOpenwindowNewmailNewMail, datasource?: PostUiOpenwindowNewmailDatasourceEnum, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUiOpenwindowNewmail(newMail, datasource, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserInterfaceApi - object-oriented interface
 */
export class UserInterfaceApi extends BaseAPI {
    /**
     * Set a solar system as autopilot waypoint  --- Alternate route: `/dev/ui/autopilot/waypoint/`  Alternate route: `/legacy/ui/autopilot/waypoint/`  Alternate route: `/v2/ui/autopilot/waypoint/` 
     * @summary Set Autopilot Waypoint
     * @param {boolean} addToBeginning Whether this solar system should be added to the beginning of all waypoints
     * @param {boolean} clearOtherWaypoints Whether clean other waypoints beforing adding this one
     * @param {number} destinationId The destination to travel to, can be solar system, station or structure\&#39;s id
     * @param {PostUiAutopilotWaypointDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUiAutopilotWaypoint(addToBeginning: boolean, clearOtherWaypoints: boolean, destinationId: number, datasource?: PostUiAutopilotWaypointDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return UserInterfaceApiFp(this.configuration).postUiAutopilotWaypoint(addToBeginning, clearOtherWaypoints, destinationId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Open the contract window inside the client  --- Alternate route: `/dev/ui/openwindow/contract/`  Alternate route: `/legacy/ui/openwindow/contract/`  Alternate route: `/v1/ui/openwindow/contract/` 
     * @summary Open Contract Window
     * @param {number} contractId The contract to open
     * @param {PostUiOpenwindowContractDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUiOpenwindowContract(contractId: number, datasource?: PostUiOpenwindowContractDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return UserInterfaceApiFp(this.configuration).postUiOpenwindowContract(contractId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Open the information window for a character, corporation or alliance inside the client  --- Alternate route: `/dev/ui/openwindow/information/`  Alternate route: `/legacy/ui/openwindow/information/`  Alternate route: `/v1/ui/openwindow/information/` 
     * @summary Open Information Window
     * @param {number} targetId The target to open
     * @param {PostUiOpenwindowInformationDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUiOpenwindowInformation(targetId: number, datasource?: PostUiOpenwindowInformationDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return UserInterfaceApiFp(this.configuration).postUiOpenwindowInformation(targetId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Open the market details window for a specific typeID inside the client  --- Alternate route: `/dev/ui/openwindow/marketdetails/`  Alternate route: `/legacy/ui/openwindow/marketdetails/`  Alternate route: `/v1/ui/openwindow/marketdetails/` 
     * @summary Open Market Details
     * @param {number} typeId The item type to open in market window
     * @param {PostUiOpenwindowMarketdetailsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUiOpenwindowMarketdetails(typeId: number, datasource?: PostUiOpenwindowMarketdetailsDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return UserInterfaceApiFp(this.configuration).postUiOpenwindowMarketdetails(typeId, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Open the New Mail window, according to settings from the request if applicable  --- Alternate route: `/dev/ui/openwindow/newmail/`  Alternate route: `/legacy/ui/openwindow/newmail/`  Alternate route: `/v1/ui/openwindow/newmail/` 
     * @summary Open New Mail Window
     * @param {PostUiOpenwindowNewmailNewMail} newMail The details of mail to create
     * @param {PostUiOpenwindowNewmailDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUiOpenwindowNewmail(newMail: PostUiOpenwindowNewmailNewMail, datasource?: PostUiOpenwindowNewmailDatasourceEnum, token?: string, options?: RawAxiosRequestConfig) {
        return UserInterfaceApiFp(this.configuration).postUiOpenwindowNewmail(newMail, datasource, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const PostUiAutopilotWaypointDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostUiAutopilotWaypointDatasourceEnum = typeof PostUiAutopilotWaypointDatasourceEnum[keyof typeof PostUiAutopilotWaypointDatasourceEnum];
export const PostUiOpenwindowContractDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostUiOpenwindowContractDatasourceEnum = typeof PostUiOpenwindowContractDatasourceEnum[keyof typeof PostUiOpenwindowContractDatasourceEnum];
export const PostUiOpenwindowInformationDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostUiOpenwindowInformationDatasourceEnum = typeof PostUiOpenwindowInformationDatasourceEnum[keyof typeof PostUiOpenwindowInformationDatasourceEnum];
export const PostUiOpenwindowMarketdetailsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostUiOpenwindowMarketdetailsDatasourceEnum = typeof PostUiOpenwindowMarketdetailsDatasourceEnum[keyof typeof PostUiOpenwindowMarketdetailsDatasourceEnum];
export const PostUiOpenwindowNewmailDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type PostUiOpenwindowNewmailDatasourceEnum = typeof PostUiOpenwindowNewmailDatasourceEnum[keyof typeof PostUiOpenwindowNewmailDatasourceEnum];


/**
 * WalletApi - axios parameter creator
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a character\'s wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
         * @summary Get a character\'s wallet balance
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdWalletDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWallet: async (characterId: number, datasource?: GetCharactersCharacterIdWalletDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdWallet', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/wallet/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-wallet.read_character_wallet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given character\'s wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/legacy/characters/{character_id}/wallet/journal/`  Alternate route: `/v5/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
         * @summary Get character wallet journal
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdWalletJournalDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWalletJournal: async (characterId: number, datasource?: GetCharactersCharacterIdWalletJournalDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdWalletJournal', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/wallet/journal/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-wallet.read_character_wallet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
         * @summary Get wallet transactions
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdWalletTransactionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show transactions happened before the one referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWalletTransactions: async (characterId: number, datasource?: GetCharactersCharacterIdWalletTransactionsDatasourceEnum, fromId?: number, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'characterId' is not null or undefined
            assertParamExists('getCharactersCharacterIdWalletTransactions', 'characterId', characterId)
            const localVarPath = `/characters/{character_id}/wallet/transactions/`
                .replace(`{${"character_id"}}`, encodeURIComponent(String(characterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-wallet.read_character_wallet.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['from_id'] = fromId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a corporation\'s wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Returns a corporation\'s wallet balance
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdWalletsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWallets: async (corporationId: number, datasource?: GetCorporationsCorporationIdWalletsDatasourceEnum, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdWallets', 'corporationId', corporationId)
            const localVarPath = `/corporations/{corporation_id}/wallets/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-wallet.read_corporation_wallets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given corporation\'s wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v3/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet journal
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWalletsDivisionJournal: async (corporationId: number, division: number, datasource?: GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdWalletsDivisionJournal', 'corporationId', corporationId)
            // verify required parameter 'division' is not null or undefined
            assertParamExists('getCorporationsCorporationIdWalletsDivisionJournal', 'division', division)
            const localVarPath = `/corporations/{corporation_id}/wallets/{division}/journal/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)))
                .replace(`{${"division"}}`, encodeURIComponent(String(division)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-wallet.read_corporation_wallets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet transactions
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWalletsDivisionTransactions: async (corporationId: number, division: number, datasource?: GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum, fromId?: number, ifNoneMatch?: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'corporationId' is not null or undefined
            assertParamExists('getCorporationsCorporationIdWalletsDivisionTransactions', 'corporationId', corporationId)
            // verify required parameter 'division' is not null or undefined
            assertParamExists('getCorporationsCorporationIdWalletsDivisionTransactions', 'division', division)
            const localVarPath = `/corporations/{corporation_id}/wallets/{division}/transactions/`
                .replace(`{${"corporation_id"}}`, encodeURIComponent(String(corporationId)))
                .replace(`{${"division"}}`, encodeURIComponent(String(division)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication evesso required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "evesso", ["esi-wallet.read_corporation_wallets.v1"], configuration)

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (fromId !== undefined) {
                localVarQueryParameter['from_id'] = fromId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a character\'s wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
         * @summary Get a character\'s wallet balance
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdWalletDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdWallet(characterId: number, datasource?: GetCharactersCharacterIdWalletDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdWallet(characterId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getCharactersCharacterIdWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the given character\'s wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/legacy/characters/{character_id}/wallet/journal/`  Alternate route: `/v5/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
         * @summary Get character wallet journal
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdWalletJournalDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdWalletJournal(characterId: number, datasource?: GetCharactersCharacterIdWalletJournalDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdWalletJournal200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdWalletJournal(characterId, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getCharactersCharacterIdWalletJournal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
         * @summary Get wallet transactions
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdWalletTransactionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show transactions happened before the one referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharactersCharacterIdWalletTransactions(characterId: number, datasource?: GetCharactersCharacterIdWalletTransactionsDatasourceEnum, fromId?: number, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCharactersCharacterIdWalletTransactions200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharactersCharacterIdWalletTransactions(characterId, datasource, fromId, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getCharactersCharacterIdWalletTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a corporation\'s wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Returns a corporation\'s wallet balance
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdWalletsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdWallets(corporationId: number, datasource?: GetCorporationsCorporationIdWalletsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdWallets200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdWallets(corporationId, datasource, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getCorporationsCorporationIdWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the given corporation\'s wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v3/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet journal
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdWalletsDivisionJournal(corporationId: number, division: number, datasource?: GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdWalletsDivisionJournal200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdWalletsDivisionJournal(corporationId, division, datasource, ifNoneMatch, page, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getCorporationsCorporationIdWalletsDivisionJournal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet transactions
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorporationsCorporationIdWalletsDivisionTransactions(corporationId: number, division: number, datasource?: GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum, fromId?: number, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetCorporationsCorporationIdWalletsDivisionTransactions200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorporationsCorporationIdWalletsDivisionTransactions(corporationId, division, datasource, fromId, ifNoneMatch, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getCorporationsCorporationIdWalletsDivisionTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletApi - factory interface
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * Returns a character\'s wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
         * @summary Get a character\'s wallet balance
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdWalletDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWallet(characterId: number, datasource?: GetCharactersCharacterIdWalletDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getCharactersCharacterIdWallet(characterId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given character\'s wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/legacy/characters/{character_id}/wallet/journal/`  Alternate route: `/v5/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
         * @summary Get character wallet journal
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdWalletJournalDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWalletJournal(characterId: number, datasource?: GetCharactersCharacterIdWalletJournalDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdWalletJournal200Ok>> {
            return localVarFp.getCharactersCharacterIdWalletJournal(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
         * @summary Get wallet transactions
         * @param {number} characterId An EVE character ID
         * @param {GetCharactersCharacterIdWalletTransactionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show transactions happened before the one referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharactersCharacterIdWalletTransactions(characterId: number, datasource?: GetCharactersCharacterIdWalletTransactionsDatasourceEnum, fromId?: number, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCharactersCharacterIdWalletTransactions200Ok>> {
            return localVarFp.getCharactersCharacterIdWalletTransactions(characterId, datasource, fromId, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a corporation\'s wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Returns a corporation\'s wallet balance
         * @param {number} corporationId An EVE corporation ID
         * @param {GetCorporationsCorporationIdWalletsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWallets(corporationId: number, datasource?: GetCorporationsCorporationIdWalletsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdWallets200Ok>> {
            return localVarFp.getCorporationsCorporationIdWallets(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given corporation\'s wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v3/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet journal
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWalletsDivisionJournal(corporationId: number, division: number, datasource?: GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdWalletsDivisionJournal200Ok>> {
            return localVarFp.getCorporationsCorporationIdWalletsDivisionJournal(corporationId, division, datasource, ifNoneMatch, page, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
         * @summary Get corporation wallet transactions
         * @param {number} corporationId An EVE corporation ID
         * @param {number} division Wallet key of the division to fetch journals from
         * @param {GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum} [datasource] The server name you would like data from
         * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} [token] Access token to use if unable to set a header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorporationsCorporationIdWalletsDivisionTransactions(corporationId: number, division: number, datasource?: GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum, fromId?: number, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetCorporationsCorporationIdWalletsDivisionTransactions200Ok>> {
            return localVarFp.getCorporationsCorporationIdWalletsDivisionTransactions(corporationId, division, datasource, fromId, ifNoneMatch, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 */
export class WalletApi extends BaseAPI {
    /**
     * Returns a character\'s wallet balance  --- Alternate route: `/legacy/characters/{character_id}/wallet/`  Alternate route: `/v1/characters/{character_id}/wallet/`  --- This route is cached for up to 120 seconds  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/wallet/)
     * @summary Get a character\'s wallet balance
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdWalletDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdWallet(characterId: number, datasource?: GetCharactersCharacterIdWalletDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getCharactersCharacterIdWallet(characterId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given character\'s wallet journal going 30 days back  --- Alternate route: `/dev/characters/{character_id}/wallet/journal/`  Alternate route: `/legacy/characters/{character_id}/wallet/journal/`  Alternate route: `/v5/characters/{character_id}/wallet/journal/`  Alternate route: `/v6/characters/{character_id}/wallet/journal/`  --- This route is cached for up to 3600 seconds
     * @summary Get character wallet journal
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdWalletJournalDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdWalletJournal(characterId: number, datasource?: GetCharactersCharacterIdWalletJournalDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getCharactersCharacterIdWalletJournal(characterId, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get wallet transactions of a character  --- Alternate route: `/dev/characters/{character_id}/wallet/transactions/`  Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`  Alternate route: `/v1/characters/{character_id}/wallet/transactions/`  --- This route is cached for up to 3600 seconds
     * @summary Get wallet transactions
     * @param {number} characterId An EVE character ID
     * @param {GetCharactersCharacterIdWalletTransactionsDatasourceEnum} [datasource] The server name you would like data from
     * @param {number} [fromId] Only show transactions happened before the one referenced by this id
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCharactersCharacterIdWalletTransactions(characterId: number, datasource?: GetCharactersCharacterIdWalletTransactionsDatasourceEnum, fromId?: number, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getCharactersCharacterIdWalletTransactions(characterId, datasource, fromId, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a corporation\'s wallets  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/`  --- This route is cached for up to 300 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @summary Returns a corporation\'s wallet balance
     * @param {number} corporationId An EVE corporation ID
     * @param {GetCorporationsCorporationIdWalletsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdWallets(corporationId: number, datasource?: GetCorporationsCorporationIdWalletsDatasourceEnum, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getCorporationsCorporationIdWallets(corporationId, datasource, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given corporation\'s wallet journal for the given division going 30 days back  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v3/corporations/{corporation_id}/wallets/{division}/journal/`  Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @summary Get corporation wallet journal
     * @param {number} corporationId An EVE corporation ID
     * @param {number} division Wallet key of the division to fetch journals from
     * @param {GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdWalletsDivisionJournal(corporationId: number, division: number, datasource?: GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum, ifNoneMatch?: string, page?: number, token?: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getCorporationsCorporationIdWalletsDivisionJournal(corporationId, division, datasource, ifNoneMatch, page, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get wallet transactions of a corporation  --- Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`  Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`  --- This route is cached for up to 3600 seconds  --- Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant 
     * @summary Get corporation wallet transactions
     * @param {number} corporationId An EVE corporation ID
     * @param {number} division Wallet key of the division to fetch journals from
     * @param {GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum} [datasource] The server name you would like data from
     * @param {number} [fromId] Only show journal entries happened before the transaction referenced by this id
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {string} [token] Access token to use if unable to set a header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCorporationsCorporationIdWalletsDivisionTransactions(corporationId: number, division: number, datasource?: GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum, fromId?: number, ifNoneMatch?: string, token?: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getCorporationsCorporationIdWalletsDivisionTransactions(corporationId, division, datasource, fromId, ifNoneMatch, token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCharactersCharacterIdWalletDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdWalletDatasourceEnum = typeof GetCharactersCharacterIdWalletDatasourceEnum[keyof typeof GetCharactersCharacterIdWalletDatasourceEnum];
export const GetCharactersCharacterIdWalletJournalDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdWalletJournalDatasourceEnum = typeof GetCharactersCharacterIdWalletJournalDatasourceEnum[keyof typeof GetCharactersCharacterIdWalletJournalDatasourceEnum];
export const GetCharactersCharacterIdWalletTransactionsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCharactersCharacterIdWalletTransactionsDatasourceEnum = typeof GetCharactersCharacterIdWalletTransactionsDatasourceEnum[keyof typeof GetCharactersCharacterIdWalletTransactionsDatasourceEnum];
export const GetCorporationsCorporationIdWalletsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdWalletsDatasourceEnum = typeof GetCorporationsCorporationIdWalletsDatasourceEnum[keyof typeof GetCorporationsCorporationIdWalletsDatasourceEnum];
export const GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum = typeof GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum[keyof typeof GetCorporationsCorporationIdWalletsDivisionJournalDatasourceEnum];
export const GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum = typeof GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum[keyof typeof GetCorporationsCorporationIdWalletsDivisionTransactionsDatasourceEnum];


/**
 * WarsApi - axios parameter creator
 */
export const WarsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
         * @summary List wars
         * @param {GetWarsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [maxWarId] Only return wars with ID smaller than this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWars: async (datasource?: GetWarsDatasourceEnum, ifNoneMatch?: string, maxWarId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wars/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (maxWarId !== undefined) {
                localVarQueryParameter['max_war_id'] = maxWarId;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get war information
         * @param {number} warId ID for a war
         * @param {GetWarsWarIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarsWarId: async (warId: number, datasource?: GetWarsWarIdDatasourceEnum, ifNoneMatch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'warId' is not null or undefined
            assertParamExists('getWarsWarId', 'warId', warId)
            const localVarPath = `/wars/{war_id}/`
                .replace(`{${"war_id"}}`, encodeURIComponent(String(warId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
         * @summary List kills for a war
         * @param {number} warId A valid war ID
         * @param {GetWarsWarIdKillmailsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarsWarIdKillmails: async (warId: number, datasource?: GetWarsWarIdKillmailsDatasourceEnum, ifNoneMatch?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'warId' is not null or undefined
            assertParamExists('getWarsWarIdKillmails', 'warId', warId)
            const localVarPath = `/wars/{war_id}/killmails/`
                .replace(`{${"war_id"}}`, encodeURIComponent(String(warId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasource !== undefined) {
                localVarQueryParameter['datasource'] = datasource;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            if (ifNoneMatch != null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WarsApi - functional programming interface
 */
export const WarsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WarsApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
         * @summary List wars
         * @param {GetWarsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [maxWarId] Only return wars with ID smaller than this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWars(datasource?: GetWarsDatasourceEnum, ifNoneMatch?: string, maxWarId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWars(datasource, ifNoneMatch, maxWarId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarsApi.getWars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get war information
         * @param {number} warId ID for a war
         * @param {GetWarsWarIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWarsWarId(warId: number, datasource?: GetWarsWarIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWarsWarIdOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWarsWarId(warId, datasource, ifNoneMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarsApi.getWarsWarId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
         * @summary List kills for a war
         * @param {number} warId A valid war ID
         * @param {GetWarsWarIdKillmailsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWarsWarIdKillmails(warId: number, datasource?: GetWarsWarIdKillmailsDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetWarsWarIdKillmails200Ok>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWarsWarIdKillmails(warId, datasource, ifNoneMatch, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WarsApi.getWarsWarIdKillmails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WarsApi - factory interface
 */
export const WarsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WarsApiFp(configuration)
    return {
        /**
         * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
         * @summary List wars
         * @param {GetWarsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [maxWarId] Only return wars with ID smaller than this
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWars(datasource?: GetWarsDatasourceEnum, ifNoneMatch?: string, maxWarId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getWars(datasource, ifNoneMatch, maxWarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
         * @summary Get war information
         * @param {number} warId ID for a war
         * @param {GetWarsWarIdDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarsWarId(warId: number, datasource?: GetWarsWarIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetWarsWarIdOk> {
            return localVarFp.getWarsWarId(warId, datasource, ifNoneMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
         * @summary List kills for a war
         * @param {number} warId A valid war ID
         * @param {GetWarsWarIdKillmailsDatasourceEnum} [datasource] The server name you would like data from
         * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {number} [page] Which page of results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWarsWarIdKillmails(warId: number, datasource?: GetWarsWarIdKillmailsDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetWarsWarIdKillmails200Ok>> {
            return localVarFp.getWarsWarIdKillmails(warId, datasource, ifNoneMatch, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WarsApi - object-oriented interface
 */
export class WarsApi extends BaseAPI {
    /**
     * Return a list of wars  --- Alternate route: `/dev/wars/`  Alternate route: `/legacy/wars/`  Alternate route: `/v1/wars/`  --- This route is cached for up to 3600 seconds
     * @summary List wars
     * @param {GetWarsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [maxWarId] Only return wars with ID smaller than this
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWars(datasource?: GetWarsDatasourceEnum, ifNoneMatch?: string, maxWarId?: number, options?: RawAxiosRequestConfig) {
        return WarsApiFp(this.configuration).getWars(datasource, ifNoneMatch, maxWarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return details about a war  --- Alternate route: `/dev/wars/{war_id}/`  Alternate route: `/legacy/wars/{war_id}/`  Alternate route: `/v1/wars/{war_id}/`  --- This route is cached for up to 3600 seconds
     * @summary Get war information
     * @param {number} warId ID for a war
     * @param {GetWarsWarIdDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWarsWarId(warId: number, datasource?: GetWarsWarIdDatasourceEnum, ifNoneMatch?: string, options?: RawAxiosRequestConfig) {
        return WarsApiFp(this.configuration).getWarsWarId(warId, datasource, ifNoneMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of kills related to a war  --- Alternate route: `/dev/wars/{war_id}/killmails/`  Alternate route: `/legacy/wars/{war_id}/killmails/`  Alternate route: `/v1/wars/{war_id}/killmails/`  --- This route is cached for up to 3600 seconds
     * @summary List kills for a war
     * @param {number} warId A valid war ID
     * @param {GetWarsWarIdKillmailsDatasourceEnum} [datasource] The server name you would like data from
     * @param {string} [ifNoneMatch] ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param {number} [page] Which page of results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWarsWarIdKillmails(warId: number, datasource?: GetWarsWarIdKillmailsDatasourceEnum, ifNoneMatch?: string, page?: number, options?: RawAxiosRequestConfig) {
        return WarsApiFp(this.configuration).getWarsWarIdKillmails(warId, datasource, ifNoneMatch, page, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetWarsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetWarsDatasourceEnum = typeof GetWarsDatasourceEnum[keyof typeof GetWarsDatasourceEnum];
export const GetWarsWarIdDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetWarsWarIdDatasourceEnum = typeof GetWarsWarIdDatasourceEnum[keyof typeof GetWarsWarIdDatasourceEnum];
export const GetWarsWarIdKillmailsDatasourceEnum = {
    Tranquility: 'tranquility'
} as const;
export type GetWarsWarIdKillmailsDatasourceEnum = typeof GetWarsWarIdKillmailsDatasourceEnum[keyof typeof GetWarsWarIdKillmailsDatasourceEnum];


